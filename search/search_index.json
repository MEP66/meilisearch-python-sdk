{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Meilisearch Python SDK","text":"<p>Meilisearch Python SDK provides both an async and sync client for the Meilisearch API.</p> <p>The focus of this documentation is on the Meilisearch Python SDK API. More information of Meilisearch itself and how to use it can be found in here.</p>"},{"location":"#which-client-to-chose","title":"Which client to chose","text":"<p>If the code base you are working with uses asyncio, for example if you are using FastAPI, chose the <code>AsyncClint</code> otherwise chose the <code>Client</code>. The functionality of the two clients is the same, the difference being the <code>AsyncClient</code> provides async methods and uses the <code>AsyncIndex</code>, which also provides async methods, while the <code>Client</code> provides blocking methods and uses the <code>Index</code>, which also provides blocking methods.</p>"},{"location":"async_client_api/","title":"AsyncClient","text":""},{"location":"async_client_api/#asyncclient-usage","title":"<code>AsyncClient</code> Usage","text":""},{"location":"async_client_api/#create-a-client-with-a-context-manager","title":"Create a client with a context manager","text":"<p>This client runs in a context manager which ensures that everything is cleaned up after the use of the client is done. To create a client:</p> <pre><code>from meilisearch-python-sdk import AsyncClient\n\n\nasync with AsyncClient(\"http://localhost:7700\", \"masterKey\") as client:\n    index = client.index(\"movies\")\n    ...\n</code></pre>"},{"location":"async_client_api/#create-a-client-without-a-context-manager","title":"Create a client without a context manager","text":"<p>It is also possible to call the client without using a context manager, but in doing so you will need to make sure to do the cleanup yourself:</p> <pre><code>from meilisearch-python-sdk import AsyncClient\n\n\ntry:\n    client = AsyncClient(\"http://localhost:7700\", \"masterKey\")\n    ...\nfinally:\n    await client.aclose()\n\n</code></pre>"},{"location":"async_client_api/#asyncclient-api","title":"<code>AsyncClient</code> API","text":"<p>             Bases: <code>BaseClient</code></p> <p>Async client to connect to the Meilisearch API.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>class AsyncClient(BaseClient):\n    \"\"\"Async client to connect to the Meilisearch API.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        api_key: str | None = None,\n        *,\n        timeout: int | None = None,\n        verify: str | bool | SSLContext = True,\n    ) -&gt; None:\n        \"\"\"Class initializer.\n\n        Args:\n\n            url: The url to the Meilisearch API (ex: http://localhost:7700)\n            api_key: The optional API key for Meilisearch. Defaults to None.\n            timeout: The amount of time in seconds that the client will wait for a response before\n                timing out. Defaults to None.\n            verify: SSL certificates (a.k.a CA bundle) used to\n                verify the identity of requested hosts. Either `True` (default CA bundle),\n                a path to an SSL certificate file, or `False` (disable verification)\n        \"\"\"\n        super().__init__(api_key)\n\n        self.http_client = HttpxAsyncClient(\n            base_url=url, timeout=timeout, headers=self._headers, verify=verify\n        )\n        self._http_requests = AsyncHttpRequests(self.http_client)\n\n    async def __aenter__(self) -&gt; AsyncClient:\n        return self\n\n    async def __aexit__(\n        self,\n        et: type[BaseException] | None,\n        ev: type[BaseException] | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        await self.aclose()\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Closes the client.\n\n        This only needs to be used if the client was not created with a context manager.\n        \"\"\"\n        await self.http_client.aclose()\n\n    async def create_dump(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch dump.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.create_dump()\n        \"\"\"\n        response = await self._http_requests.post(\"dumps\")\n\n        return TaskInfo(**response.json())\n\n    async def create_index(\n        self,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        plugins: AsyncIndexPlugins | None = None,\n    ) -&gt; AsyncIndex:\n        \"\"\"Creates a new index.\n\n        Args:\n\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An instance of AsyncIndex containing the information of the newly created index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.create_index(\"movies\")\n        \"\"\"\n        return await AsyncIndex.create(\n            self.http_client, uid, primary_key, settings=settings, wait=wait, plugins=plugins\n        )\n\n    async def create_snapshot(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.create_snapshot()\n        \"\"\"\n        response = await self._http_requests.post(\"snapshots\")\n\n        return TaskInfo(**response.json())\n\n    async def delete_index_if_exists(self, uid: str) -&gt; bool:\n        \"\"\"Deletes an index if it already exists.\n\n        Args:\n\n            uid: The index's unique identifier.\n\n        Returns:\n\n            True if an index was deleted for False if not.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_index_if_exists()\n        \"\"\"\n        response = await self._http_requests.delete(f\"indexes/{uid}\")\n        status = await self.wait_for_task(response.json()[\"taskUid\"], timeout_in_ms=100000)\n        if status.status == \"succeeded\":\n            return True\n        return False\n\n    async def get_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[AsyncIndex] | None:\n        \"\"\"Get all indexes.\n        Args:\n\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n\n            A list of all indexes.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     indexes = await client.get_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = await self._http_requests.get(url)\n\n        if not response.json()[\"results\"]:\n            return None\n\n        return [\n            AsyncIndex(\n                http_client=self.http_client,\n                uid=x[\"uid\"],\n                primary_key=x[\"primaryKey\"],\n                created_at=x[\"createdAt\"],\n                updated_at=x[\"updatedAt\"],\n            )\n            for x in response.json()[\"results\"]\n        ]\n\n    async def get_index(self, uid: str) -&gt; AsyncIndex:\n        \"\"\"Gets a single index based on the uid of the index.\n\n        Args:\n\n            uid: The index's unique identifier.\n\n        Returns:\n\n            An AsyncIndex instance containing the information of the fetched index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_index()\n        \"\"\"\n        return await AsyncIndex(self.http_client, uid).fetch_info()\n\n    def index(self, uid: str, *, plugins: AsyncIndexPlugins | None = None) -&gt; AsyncIndex:\n        \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n        Because no network call is made this method is not awaitable.\n\n        Args:\n\n            uid: The index's unique identifier.\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An AsyncIndex instance.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n        \"\"\"\n        return AsyncIndex(self.http_client, uid=uid, plugins=plugins)\n\n    async def get_all_stats(self) -&gt; ClientStats:\n        \"\"\"Get stats for all indexes.\n\n        Returns:\n\n            Information about database size and all indexes.\n            https://docs.meilisearch.com/reference/api/stats.html\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     stats = await client.get_all_stats()\n        \"\"\"\n        response = await self._http_requests.get(\"stats\")\n\n        return ClientStats(**response.json())\n\n    async def get_or_create_index(\n        self, uid: str, primary_key: str | None = None, *, plugins: AsyncIndexPlugins | None = None\n    ) -&gt; AsyncIndex:\n        \"\"\"Get an index, or create it if it doesn't exist.\n\n        Args:\n\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An instance of AsyncIndex containing the information of the retrieved or newly created index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_or_create_index(\"movies\")\n        \"\"\"\n        try:\n            index_instance = await self.get_index(uid)\n        except MeilisearchApiError as err:\n            if \"index_not_found\" not in err.code:\n                raise\n            index_instance = await self.create_index(uid, primary_key, plugins=plugins)\n        return index_instance\n\n    async def create_key(self, key: KeyCreate) -&gt; Key:\n        \"\"\"Creates a new API key.\n\n        Args:\n\n            key: The information to use in creating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n\n            The new API key.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     key_info = KeyCreate(\n            &gt;&gt;&gt;         description=\"My new key\",\n            &gt;&gt;&gt;         actions=[\"search\"],\n            &gt;&gt;&gt;         indexes=[\"movies\"],\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     keys = await client.create_key(key_info)\n        \"\"\"\n        if is_pydantic_2():\n            response = await self._http_requests.post(\n                \"keys\", json.loads(key.model_dump_json(by_alias=True))\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = await self._http_requests.post(\"keys\", json.loads(key.json(by_alias=True)))  # type: ignore[attr-defined]\n\n        return Key(**response.json())\n\n    async def delete_key(self, key: str) -&gt; int:\n        \"\"\"Deletes an API key.\n\n        Args:\n\n            key: The key or uid to delete.\n\n        Returns:\n\n            The Response status code. 204 signifies a successful delete.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_key(\"abc123\")\n        \"\"\"\n        response = await self._http_requests.delete(f\"keys/{key}\")\n        return response.status_code\n\n    async def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n        \"\"\"Gets the Meilisearch API keys.\n        Args:\n\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n\n            API keys.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            from meilisearch_python_sdk import AsyncClient\n            async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n                keys = await client.get_keys()\n        \"\"\"\n        url = _build_offset_limit_url(\"keys\", offset, limit)\n        response = await self._http_requests.get(url)\n\n        return KeySearch(**response.json())\n\n    async def get_key(self, key: str) -&gt; Key:\n        \"\"\"Gets information about a specific API key.\n\n        Args:\n\n            key: The key for which to retrieve the information.\n\n        Returns:\n\n            The API key, or `None` if the key is not found.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     keys = await client.get_key(\"abc123\")\n        \"\"\"\n        response = await self._http_requests.get(f\"keys/{key}\")\n\n        return Key(**response.json())\n\n    async def update_key(self, key: KeyUpdate) -&gt; Key:\n        \"\"\"Update an API key.\n\n        Args:\n\n            key: The information to use in updating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n\n            The updated API key.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     key_info = KeyUpdate(\n                        key=\"abc123\",\n            &gt;&gt;&gt;         indexes=[\"*\"],\n            &gt;&gt;&gt;     )\n            &gt;&gt;&gt;     keys = await client.update_key(key_info)\n        \"\"\"\n        payload = _build_update_key_payload(key)\n        response = await self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n        return Key(**response.json())\n\n    async def multi_search(self, queries: list[SearchParams]) -&gt; list[SearchResultsWithUID]:\n        \"\"\"Multi-index search.\n\n        Args:\n\n            queries: List of SearchParameters\n\n        Returns:\n\n            Results of the search\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     queries = [\n            &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n            &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n            &gt;&gt;&gt;     ]\n            &gt;&gt;&gt;     search_results = await client.search(queries)\n        \"\"\"\n        url = \"multi-search\"\n        if is_pydantic_2():\n            response = await self._http_requests.post(\n                url,\n                body={\"queries\": [x.model_dump(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n            )\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = await self._http_requests.post(\n                url,\n                body={\"queries\": [x.dict(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n            )\n\n        return [SearchResultsWithUID(**x) for x in response.json()[\"results\"]]\n\n    async def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n        \"\"\"Gets the index and returns all the index information rather than an AsyncIndex instance.\n\n        Args:\n\n            uid: The index's unique identifier.\n\n        Returns:\n\n            Index information rather than an AsyncIndex instance.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_raw_index(\"movies\")\n        \"\"\"\n        response = await self.http_client.get(f\"indexes/{uid}\")\n\n        if response.status_code == 404:\n            return None\n\n        return IndexInfo(**response.json())\n\n    async def get_raw_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[IndexInfo] | None:\n        \"\"\"Gets all the indexes.\n        Args:\n\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns all the index information rather than an AsyncIndex instance.\n\n        Returns:\n\n            A list of the Index information rather than an AsyncIndex instances.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.get_raw_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = await self._http_requests.get(url)\n\n        if not response.json()[\"results\"]:\n            return None\n\n        return [IndexInfo(**x) for x in response.json()[\"results\"]]\n\n    async def get_version(self) -&gt; Version:\n        \"\"\"Get the Meilisearch version.\n\n        Returns:\n\n            Information about the version of Meilisearch.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     version = await client.get_version()\n        \"\"\"\n        response = await self._http_requests.get(\"version\")\n\n        return Version(**response.json())\n\n    async def health(self) -&gt; Health:\n        \"\"\"Get health of the Meilisearch server.\n\n        Returns:\n\n            The status of the Meilisearch server.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     health = await client.get_health()\n        \"\"\"\n        response = await self._http_requests.get(\"health\")\n\n        return Health(**response.json())\n\n    async def swap_indexes(self, indexes: list[tuple[str, str]]) -&gt; TaskInfo:\n        \"\"\"Swap two indexes.\n\n        Args:\n\n            indexes: A list of tuples, each tuple should contain the indexes to swap.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await client.swap_indexes([(\"index_a\", \"index_b\")])\n        \"\"\"\n        processed_indexes = [{\"indexes\": x} for x in indexes]\n        response = await self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n        return TaskInfo(**response.json())\n\n    async def cancel_tasks(\n        self,\n        *,\n        uids: list[str] | None = None,\n        index_uids: list[str] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Cancel a list of enqueued or processing tasks.\n\n        Defaults to cancelling all tasks.\n\n        Args:\n\n            uids: A list of task UIDs to cancel.\n            index_uids: A list of index UIDs for which to cancel tasks.\n            statuses: A list of statuses to cancel.\n            types: A list of types to cancel.\n            before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n            after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n            before_started_at: Cancel tasks that were started before the specified date time.\n            after_finished_at: Cancel tasks that were finished after the specified date time.\n\n        Returns:\n\n            The details of the task\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.cancel_tasks(uids=[1, 2])\n        \"\"\"\n        return await _task.async_cancel_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    async def get_task(self, task_id: int) -&gt; TaskResult:\n        \"\"\"Get a single task from it's task id.\n\n        Args:\n\n            task_id: Identifier of the task to retrieve.\n\n        Returns:\n\n            Results of a task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.task import get_task\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.get_task(client, 1244)\n        \"\"\"\n        return await _task.async_get_task(self.http_client, task_id=task_id)\n\n    async def delete_tasks(\n        self,\n        *,\n        uids: list[str] | None = None,\n        index_uids: list[str] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Delete a list of tasks.\n\n        Defaults to deleting all tasks.\n\n        Args:\n\n            uids: A list of task UIDs to cancel.\n            index_uids: A list of index UIDs for which to cancel tasks.\n            statuses: A list of statuses to cancel.\n            types: A list of types to cancel.\n            before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n            after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n            before_started_at: Cancel tasks that were started before the specified date time.\n            after_finished_at: Cancel tasks that were finished after the specified date time.\n\n        Returns:\n\n            The details of the task\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.task import delete_tasks\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.delete_tasks(uids=[1, 2])\n        \"\"\"\n        return await _task.async_delete_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    async def get_tasks(\n        self,\n        *,\n        index_ids: list[str] | None = None,\n        types: str | list[str] | None = None,\n    ) -&gt; TaskStatus:\n        \"\"\"Get multiple tasks.\n\n        Args:\n\n            index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n                tasks only for the specified indexes, if not all tasks will be returned. Default = None\n            types: Specify specific task types to retrieve. Default = None\n\n        Returns:\n\n            Task statuses.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     await client.get_tasks()\n        \"\"\"\n        return await _task.async_get_tasks(self.http_client, index_ids=index_ids, types=types)\n\n    async def wait_for_task(\n        self,\n        task_id: int,\n        *,\n        timeout_in_ms: int | None = 5000,\n        interval_in_ms: int = 50,\n        raise_for_status: bool = False,\n    ) -&gt; TaskResult:\n        \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n        Args:\n\n            task_id: Identifier of the task to retrieve.\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to 5000.\n            interval_in_ms: Time interval in miliseconds to sleep between requests. Defaults to 50.\n            raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n                has a failed status. Defaults to False.\n\n        Returns:\n\n            Details of the processed update status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     response = await index.add_documents(documents)\n            &gt;&gt;&gt;     await client.wait_for_task(client, response.update_id)\n        \"\"\"\n        return await _task.async_wait_for_task(\n            self.http_client,\n            task_id=task_id,\n            timeout_in_ms=timeout_in_ms,\n            interval_in_ms=interval_in_ms,\n            raise_for_status=raise_for_status,\n        )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.__init__","title":"<code>__init__(url, api_key=None, *, timeout=None, verify=True)</code>","text":"<p>Class initializer.</p> <p>Args:</p> <pre><code>url: The url to the Meilisearch API (ex: http://localhost:7700)\napi_key: The optional API key for Meilisearch. Defaults to None.\ntimeout: The amount of time in seconds that the client will wait for a response before\n    timing out. Defaults to None.\nverify: SSL certificates (a.k.a CA bundle) used to\n    verify the identity of requested hosts. Either `True` (default CA bundle),\n    a path to an SSL certificate file, or `False` (disable verification)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    api_key: str | None = None,\n    *,\n    timeout: int | None = None,\n    verify: str | bool | SSLContext = True,\n) -&gt; None:\n    \"\"\"Class initializer.\n\n    Args:\n\n        url: The url to the Meilisearch API (ex: http://localhost:7700)\n        api_key: The optional API key for Meilisearch. Defaults to None.\n        timeout: The amount of time in seconds that the client will wait for a response before\n            timing out. Defaults to None.\n        verify: SSL certificates (a.k.a CA bundle) used to\n            verify the identity of requested hosts. Either `True` (default CA bundle),\n            a path to an SSL certificate file, or `False` (disable verification)\n    \"\"\"\n    super().__init__(api_key)\n\n    self.http_client = HttpxAsyncClient(\n        base_url=url, timeout=timeout, headers=self._headers, verify=verify\n    )\n    self._http_requests = AsyncHttpRequests(self.http_client)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Closes the client.</p> <p>This only needs to be used if the client was not created with a context manager.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Closes the client.\n\n    This only needs to be used if the client was not created with a context manager.\n    \"\"\"\n    await self.http_client.aclose()\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.cancel_tasks","title":"<code>cancel_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>  <code>async</code>","text":"<p>Cancel a list of enqueued or processing tasks.</p> <p>Defaults to cancelling all tasks.</p> <p>Args:</p> <pre><code>uids: A list of task UIDs to cancel.\nindex_uids: A list of index UIDs for which to cancel tasks.\nstatuses: A list of statuses to cancel.\ntypes: A list of types to cancel.\nbefore_enqueued_at: Cancel tasks that were enqueued before the specified date time.\nafter_enqueued_at: Cancel tasks that were enqueued after the specified date time.\nbefore_started_at: Cancel tasks that were started before the specified date time.\nafter_finished_at: Cancel tasks that were finished after the specified date time.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt;\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.cancel_tasks(uids=[1, 2])\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def cancel_tasks(\n    self,\n    *,\n    uids: list[str] | None = None,\n    index_uids: list[str] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Cancel a list of enqueued or processing tasks.\n\n    Defaults to cancelling all tasks.\n\n    Args:\n\n        uids: A list of task UIDs to cancel.\n        index_uids: A list of index UIDs for which to cancel tasks.\n        statuses: A list of statuses to cancel.\n        types: A list of types to cancel.\n        before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n        after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n        before_started_at: Cancel tasks that were started before the specified date time.\n        after_finished_at: Cancel tasks that were finished after the specified date time.\n\n    Returns:\n\n        The details of the task\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.cancel_tasks(uids=[1, 2])\n    \"\"\"\n    return await _task.async_cancel_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_dump","title":"<code>create_dump()</code>  <code>async</code>","text":"<p>Trigger the creation of a Meilisearch dump.</p> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.create_dump()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_dump(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch dump.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.create_dump()\n    \"\"\"\n    response = await self._http_requests.post(\"dumps\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_index","title":"<code>create_index(uid, primary_key=None, *, settings=None, wait=True, plugins=None)</code>  <code>async</code>","text":"<p>Creates a new index.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\nsettings: Settings for the index. The settings can also be updated independently of\n    creating the index. The advantage to updating them here is updating the settings after\n    adding documents will cause the documents to be re-indexed. Because of this it will be\n    faster to update them before adding documents. Defaults to None (i.e. default\n    Meilisearch index settings).\nwait: If set to True and settings are being updated, the index will be returned after\n    the settings update has completed. If False it will not wait for settings to complete.\n    Default: True\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An instance of AsyncIndex containing the information of the newly created index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.create_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_index(\n    self,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    plugins: AsyncIndexPlugins | None = None,\n) -&gt; AsyncIndex:\n    \"\"\"Creates a new index.\n\n    Args:\n\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An instance of AsyncIndex containing the information of the newly created index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.create_index(\"movies\")\n    \"\"\"\n    return await AsyncIndex.create(\n        self.http_client, uid, primary_key, settings=settings, wait=wait, plugins=plugins\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_key","title":"<code>create_key(key)</code>  <code>async</code>","text":"<p>Creates a new API key.</p> <p>Args:</p> <pre><code>key: The information to use in creating the key. Note that if an expires_at value\n    is included it should be in UTC time.\n</code></pre> <p>Returns:</p> <pre><code>The new API key.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     key_info = KeyCreate(\n&gt;&gt;&gt;         description=\"My new key\",\n&gt;&gt;&gt;         actions=[\"search\"],\n&gt;&gt;&gt;         indexes=[\"movies\"],\n&gt;&gt;&gt;     )\n&gt;&gt;&gt;     keys = await client.create_key(key_info)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_key(self, key: KeyCreate) -&gt; Key:\n    \"\"\"Creates a new API key.\n\n    Args:\n\n        key: The information to use in creating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n\n        The new API key.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     key_info = KeyCreate(\n        &gt;&gt;&gt;         description=\"My new key\",\n        &gt;&gt;&gt;         actions=[\"search\"],\n        &gt;&gt;&gt;         indexes=[\"movies\"],\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     keys = await client.create_key(key_info)\n    \"\"\"\n    if is_pydantic_2():\n        response = await self._http_requests.post(\n            \"keys\", json.loads(key.model_dump_json(by_alias=True))\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = await self._http_requests.post(\"keys\", json.loads(key.json(by_alias=True)))  # type: ignore[attr-defined]\n\n    return Key(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.create_snapshot","title":"<code>create_snapshot()</code>  <code>async</code>","text":"<p>Trigger the creation of a Meilisearch snapshot.</p> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.create_snapshot()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def create_snapshot(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.create_snapshot()\n    \"\"\"\n    response = await self._http_requests.post(\"snapshots\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_index_if_exists","title":"<code>delete_index_if_exists(uid)</code>  <code>async</code>","text":"<p>Deletes an index if it already exists.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\n</code></pre> <p>Returns:</p> <pre><code>True if an index was deleted for False if not.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.delete_index_if_exists()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_index_if_exists(self, uid: str) -&gt; bool:\n    \"\"\"Deletes an index if it already exists.\n\n    Args:\n\n        uid: The index's unique identifier.\n\n    Returns:\n\n        True if an index was deleted for False if not.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_index_if_exists()\n    \"\"\"\n    response = await self._http_requests.delete(f\"indexes/{uid}\")\n    status = await self.wait_for_task(response.json()[\"taskUid\"], timeout_in_ms=100000)\n    if status.status == \"succeeded\":\n        return True\n    return False\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_key","title":"<code>delete_key(key)</code>  <code>async</code>","text":"<p>Deletes an API key.</p> <p>Args:</p> <pre><code>key: The key or uid to delete.\n</code></pre> <p>Returns:</p> <pre><code>The Response status code. 204 signifies a successful delete.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.delete_key(\"abc123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_key(self, key: str) -&gt; int:\n    \"\"\"Deletes an API key.\n\n    Args:\n\n        key: The key or uid to delete.\n\n    Returns:\n\n        The Response status code. 204 signifies a successful delete.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_key(\"abc123\")\n    \"\"\"\n    response = await self._http_requests.delete(f\"keys/{key}\")\n    return response.status_code\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.delete_tasks","title":"<code>delete_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>  <code>async</code>","text":"<p>Delete a list of tasks.</p> <p>Defaults to deleting all tasks.</p> <p>Args:</p> <pre><code>uids: A list of task UIDs to cancel.\nindex_uids: A list of index UIDs for which to cancel tasks.\nstatuses: A list of statuses to cancel.\ntypes: A list of types to cancel.\nbefore_enqueued_at: Cancel tasks that were enqueued before the specified date time.\nafter_enqueued_at: Cancel tasks that were enqueued after the specified date time.\nbefore_started_at: Cancel tasks that were started before the specified date time.\nafter_finished_at: Cancel tasks that were finished after the specified date time.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.task import delete_tasks\n&gt;&gt;&gt;\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.delete_tasks(uids=[1, 2])\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def delete_tasks(\n    self,\n    *,\n    uids: list[str] | None = None,\n    index_uids: list[str] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Delete a list of tasks.\n\n    Defaults to deleting all tasks.\n\n    Args:\n\n        uids: A list of task UIDs to cancel.\n        index_uids: A list of index UIDs for which to cancel tasks.\n        statuses: A list of statuses to cancel.\n        types: A list of types to cancel.\n        before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n        after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n        before_started_at: Cancel tasks that were started before the specified date time.\n        after_finished_at: Cancel tasks that were finished after the specified date time.\n\n    Returns:\n\n        The details of the task\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.task import delete_tasks\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.delete_tasks(uids=[1, 2])\n    \"\"\"\n    return await _task.async_delete_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_all_stats","title":"<code>get_all_stats()</code>  <code>async</code>","text":"<p>Get stats for all indexes.</p> <p>Returns:</p> <pre><code>Information about database size and all indexes.\nhttps://docs.meilisearch.com/reference/api/stats.html\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     stats = await client.get_all_stats()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_all_stats(self) -&gt; ClientStats:\n    \"\"\"Get stats for all indexes.\n\n    Returns:\n\n        Information about database size and all indexes.\n        https://docs.meilisearch.com/reference/api/stats.html\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     stats = await client.get_all_stats()\n    \"\"\"\n    response = await self._http_requests.get(\"stats\")\n\n    return ClientStats(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_index","title":"<code>get_index(uid)</code>  <code>async</code>","text":"<p>Gets a single index based on the uid of the index.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\n</code></pre> <p>Returns:</p> <pre><code>An AsyncIndex instance containing the information of the fetched index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.get_index()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_index(self, uid: str) -&gt; AsyncIndex:\n    \"\"\"Gets a single index based on the uid of the index.\n\n    Args:\n\n        uid: The index's unique identifier.\n\n    Returns:\n\n        An AsyncIndex instance containing the information of the fetched index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_index()\n    \"\"\"\n    return await AsyncIndex(self.http_client, uid).fetch_info()\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_indexes","title":"<code>get_indexes(*, offset=None, limit=None)</code>  <code>async</code>","text":"<p>Get all indexes. Args:</p> <pre><code>offset: Number of indexes to skip. The default of None will use the Meilisearch\n    default.\nlimit: Number of indexes to return. The default of None will use the Meilisearch\n    default.\n</code></pre> <p>Returns:</p> <pre><code>A list of all indexes.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     indexes = await client.get_indexes()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[AsyncIndex] | None:\n    \"\"\"Get all indexes.\n    Args:\n\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n\n        A list of all indexes.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     indexes = await client.get_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = await self._http_requests.get(url)\n\n    if not response.json()[\"results\"]:\n        return None\n\n    return [\n        AsyncIndex(\n            http_client=self.http_client,\n            uid=x[\"uid\"],\n            primary_key=x[\"primaryKey\"],\n            created_at=x[\"createdAt\"],\n            updated_at=x[\"updatedAt\"],\n        )\n        for x in response.json()[\"results\"]\n    ]\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_key","title":"<code>get_key(key)</code>  <code>async</code>","text":"<p>Gets information about a specific API key.</p> <p>Args:</p> <pre><code>key: The key for which to retrieve the information.\n</code></pre> <p>Returns:</p> <pre><code>The API key, or `None` if the key is not found.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     keys = await client.get_key(\"abc123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_key(self, key: str) -&gt; Key:\n    \"\"\"Gets information about a specific API key.\n\n    Args:\n\n        key: The key for which to retrieve the information.\n\n    Returns:\n\n        The API key, or `None` if the key is not found.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     keys = await client.get_key(\"abc123\")\n    \"\"\"\n    response = await self._http_requests.get(f\"keys/{key}\")\n\n    return Key(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_keys","title":"<code>get_keys(*, offset=None, limit=None)</code>  <code>async</code>","text":"<p>Gets the Meilisearch API keys. Args:</p> <pre><code>offset: Number of indexes to skip. The default of None will use the Meilisearch\n    default.\nlimit: Number of indexes to return. The default of None will use the Meilisearch\n    default.\n</code></pre> <p>Returns:</p> <pre><code>API keys.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>from meilisearch_python_sdk import AsyncClient\nasync with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n    keys = await client.get_keys()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n    \"\"\"Gets the Meilisearch API keys.\n    Args:\n\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n\n        API keys.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        from meilisearch_python_sdk import AsyncClient\n        async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            keys = await client.get_keys()\n    \"\"\"\n    url = _build_offset_limit_url(\"keys\", offset, limit)\n    response = await self._http_requests.get(url)\n\n    return KeySearch(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_or_create_index","title":"<code>get_or_create_index(uid, primary_key=None, *, plugins=None)</code>  <code>async</code>","text":"<p>Get an index, or create it if it doesn't exist.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An instance of AsyncIndex containing the information of the retrieved or newly created index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.get_or_create_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_or_create_index(\n    self, uid: str, primary_key: str | None = None, *, plugins: AsyncIndexPlugins | None = None\n) -&gt; AsyncIndex:\n    \"\"\"Get an index, or create it if it doesn't exist.\n\n    Args:\n\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An instance of AsyncIndex containing the information of the retrieved or newly created index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_or_create_index(\"movies\")\n    \"\"\"\n    try:\n        index_instance = await self.get_index(uid)\n    except MeilisearchApiError as err:\n        if \"index_not_found\" not in err.code:\n            raise\n        index_instance = await self.create_index(uid, primary_key, plugins=plugins)\n    return index_instance\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_raw_index","title":"<code>get_raw_index(uid)</code>  <code>async</code>","text":"<p>Gets the index and returns all the index information rather than an AsyncIndex instance.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\n</code></pre> <p>Returns:</p> <pre><code>Index information rather than an AsyncIndex instance.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.get_raw_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n    \"\"\"Gets the index and returns all the index information rather than an AsyncIndex instance.\n\n    Args:\n\n        uid: The index's unique identifier.\n\n    Returns:\n\n        Index information rather than an AsyncIndex instance.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_raw_index(\"movies\")\n    \"\"\"\n    response = await self.http_client.get(f\"indexes/{uid}\")\n\n    if response.status_code == 404:\n        return None\n\n    return IndexInfo(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_raw_indexes","title":"<code>get_raw_indexes(*, offset=None, limit=None)</code>  <code>async</code>","text":"<p>Gets all the indexes. Args:</p> <pre><code>offset: Number of indexes to skip. The default of None will use the Meilisearch\n    default.\nlimit: Number of indexes to return. The default of None will use the Meilisearch\n    default.\n</code></pre> <p>Returns all the index information rather than an AsyncIndex instance.</p> <p>Returns:</p> <pre><code>A list of the Index information rather than an AsyncIndex instances.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.get_raw_indexes()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_raw_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[IndexInfo] | None:\n    \"\"\"Gets all the indexes.\n    Args:\n\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns all the index information rather than an AsyncIndex instance.\n\n    Returns:\n\n        A list of the Index information rather than an AsyncIndex instances.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.get_raw_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = await self._http_requests.get(url)\n\n    if not response.json()[\"results\"]:\n        return None\n\n    return [IndexInfo(**x) for x in response.json()[\"results\"]]\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_task","title":"<code>get_task(task_id)</code>  <code>async</code>","text":"<p>Get a single task from it's task id.</p> <p>Args:</p> <pre><code>task_id: Identifier of the task to retrieve.\n</code></pre> <p>Returns:</p> <pre><code>Results of a task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.task import get_task\n&gt;&gt;&gt;\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.get_task(client, 1244)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_task(self, task_id: int) -&gt; TaskResult:\n    \"\"\"Get a single task from it's task id.\n\n    Args:\n\n        task_id: Identifier of the task to retrieve.\n\n    Returns:\n\n        Results of a task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.task import get_task\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.get_task(client, 1244)\n    \"\"\"\n    return await _task.async_get_task(self.http_client, task_id=task_id)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_tasks","title":"<code>get_tasks(*, index_ids=None, types=None)</code>  <code>async</code>","text":"<p>Get multiple tasks.</p> <p>Args:</p> <pre><code>index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n    tasks only for the specified indexes, if not all tasks will be returned. Default = None\ntypes: Specify specific task types to retrieve. Default = None\n</code></pre> <p>Returns:</p> <pre><code>Task statuses.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt;\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     await client.get_tasks()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_tasks(\n    self,\n    *,\n    index_ids: list[str] | None = None,\n    types: str | list[str] | None = None,\n) -&gt; TaskStatus:\n    \"\"\"Get multiple tasks.\n\n    Args:\n\n        index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n            tasks only for the specified indexes, if not all tasks will be returned. Default = None\n        types: Specify specific task types to retrieve. Default = None\n\n    Returns:\n\n        Task statuses.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     await client.get_tasks()\n    \"\"\"\n    return await _task.async_get_tasks(self.http_client, index_ids=index_ids, types=types)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.get_version","title":"<code>get_version()</code>  <code>async</code>","text":"<p>Get the Meilisearch version.</p> <p>Returns:</p> <pre><code>Information about the version of Meilisearch.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     version = await client.get_version()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def get_version(self) -&gt; Version:\n    \"\"\"Get the Meilisearch version.\n\n    Returns:\n\n        Information about the version of Meilisearch.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     version = await client.get_version()\n    \"\"\"\n    response = await self._http_requests.get(\"version\")\n\n    return Version(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.health","title":"<code>health()</code>  <code>async</code>","text":"<p>Get health of the Meilisearch server.</p> <p>Returns:</p> <pre><code>The status of the Meilisearch server.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     health = await client.get_health()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def health(self) -&gt; Health:\n    \"\"\"Get health of the Meilisearch server.\n\n    Returns:\n\n        The status of the Meilisearch server.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     health = await client.get_health()\n    \"\"\"\n    response = await self._http_requests.get(\"health\")\n\n    return Health(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.index","title":"<code>index(uid, *, plugins=None)</code>","text":"<p>Create a local reference to an index identified by UID, without making an HTTP call.</p> <p>Because no network call is made this method is not awaitable.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An AsyncIndex instance.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def index(self, uid: str, *, plugins: AsyncIndexPlugins | None = None) -&gt; AsyncIndex:\n    \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n    Because no network call is made this method is not awaitable.\n\n    Args:\n\n        uid: The index's unique identifier.\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An AsyncIndex instance.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n    \"\"\"\n    return AsyncIndex(self.http_client, uid=uid, plugins=plugins)\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.multi_search","title":"<code>multi_search(queries)</code>  <code>async</code>","text":"<p>Multi-index search.</p> <p>Args:</p> <pre><code>queries: List of SearchParameters\n</code></pre> <p>Returns:</p> <pre><code>Results of the search\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     queries = [\n&gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n&gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n&gt;&gt;&gt;     ]\n&gt;&gt;&gt;     search_results = await client.search(queries)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def multi_search(self, queries: list[SearchParams]) -&gt; list[SearchResultsWithUID]:\n    \"\"\"Multi-index search.\n\n    Args:\n\n        queries: List of SearchParameters\n\n    Returns:\n\n        Results of the search\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     queries = [\n        &gt;&gt;&gt;         SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n        &gt;&gt;&gt;         SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n        &gt;&gt;&gt;     ]\n        &gt;&gt;&gt;     search_results = await client.search(queries)\n    \"\"\"\n    url = \"multi-search\"\n    if is_pydantic_2():\n        response = await self._http_requests.post(\n            url,\n            body={\"queries\": [x.model_dump(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n        )\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = await self._http_requests.post(\n            url,\n            body={\"queries\": [x.dict(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n        )\n\n    return [SearchResultsWithUID(**x) for x in response.json()[\"results\"]]\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.swap_indexes","title":"<code>swap_indexes(indexes)</code>  <code>async</code>","text":"<p>Swap two indexes.</p> <p>Args:</p> <pre><code>indexes: A list of tuples, each tuple should contain the indexes to swap.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await client.swap_indexes([(\"index_a\", \"index_b\")])\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def swap_indexes(self, indexes: list[tuple[str, str]]) -&gt; TaskInfo:\n    \"\"\"Swap two indexes.\n\n    Args:\n\n        indexes: A list of tuples, each tuple should contain the indexes to swap.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await client.swap_indexes([(\"index_a\", \"index_b\")])\n    \"\"\"\n    processed_indexes = [{\"indexes\": x} for x in indexes]\n    response = await self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.update_key","title":"<code>update_key(key)</code>  <code>async</code>","text":"<p>Update an API key.</p> <p>Args:</p> <pre><code>key: The information to use in updating the key. Note that if an expires_at value\n    is included it should be in UTC time.\n</code></pre> <p>Returns:</p> <pre><code>The updated API key.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     key_info = KeyUpdate(\n            key=\"abc123\",\n&gt;&gt;&gt;         indexes=[\"*\"],\n&gt;&gt;&gt;     )\n&gt;&gt;&gt;     keys = await client.update_key(key_info)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def update_key(self, key: KeyUpdate) -&gt; Key:\n    \"\"\"Update an API key.\n\n    Args:\n\n        key: The information to use in updating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n\n        The updated API key.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     key_info = KeyUpdate(\n                    key=\"abc123\",\n        &gt;&gt;&gt;         indexes=[\"*\"],\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt;     keys = await client.update_key(key_info)\n    \"\"\"\n    payload = _build_update_key_payload(key)\n    response = await self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n    return Key(**response.json())\n</code></pre>"},{"location":"async_client_api/#meilisearch_python_sdk.AsyncClient.wait_for_task","title":"<code>wait_for_task(task_id, *, timeout_in_ms=5000, interval_in_ms=50, raise_for_status=False)</code>  <code>async</code>","text":"<p>Wait until Meilisearch processes a task, and get its status.</p> <p>Args:</p> <pre><code>task_id: Identifier of the task to retrieve.\ntimeout_in_ms: Amount of time in milliseconds to wait before raising a\n    MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n    if the `None` option is used the wait time could be very long. Defaults to 5000.\ninterval_in_ms: Time interval in miliseconds to sleep between requests. Defaults to 50.\nraise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n    has a failed status. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Details of the processed update status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\nMeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; &gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; async with Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     response = await index.add_documents(documents)\n&gt;&gt;&gt;     await client.wait_for_task(client, response.update_id)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>async def wait_for_task(\n    self,\n    task_id: int,\n    *,\n    timeout_in_ms: int | None = 5000,\n    interval_in_ms: int = 50,\n    raise_for_status: bool = False,\n) -&gt; TaskResult:\n    \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n    Args:\n\n        task_id: Identifier of the task to retrieve.\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to 5000.\n        interval_in_ms: Time interval in miliseconds to sleep between requests. Defaults to 50.\n        raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n            has a failed status. Defaults to False.\n\n    Returns:\n\n        Details of the processed update status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     response = await index.add_documents(documents)\n        &gt;&gt;&gt;     await client.wait_for_task(client, response.update_id)\n    \"\"\"\n    return await _task.async_wait_for_task(\n        self.http_client,\n        task_id=task_id,\n        timeout_in_ms=timeout_in_ms,\n        interval_in_ms=interval_in_ms,\n        raise_for_status=raise_for_status,\n    )\n</code></pre>"},{"location":"async_index_api/","title":"AsyncIndex","text":""},{"location":"async_index_api/#asyncindex-usage","title":"<code>AsyncIndex</code> Usage","text":"<p>The <code>AsyncIndex</code> is the the same as the <code>Index</code>, but gives asyncronous methods to work with, and and should be used when using the <code>AsyncClient</code>. When you create a new index with the <code>AsyncClient</code> it will create an <code>AsyncIndex</code> instance.</p>"},{"location":"async_index_api/#asyncindex-api","title":"<code>AsyncIndex</code> API","text":"<p>             Bases: <code>_BaseIndex</code></p> <p>AsyncIndex class gives access to all indexes routes and child routes.</p> <p>https://docs.meilisearch.com/reference/api/indexes.html</p> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>class AsyncIndex(_BaseIndex):\n    \"\"\"AsyncIndex class gives access to all indexes routes and child routes.\n\n    https://docs.meilisearch.com/reference/api/indexes.html\n    \"\"\"\n\n    def __init__(\n        self,\n        http_client: AsyncClient,\n        uid: str,\n        primary_key: str | None = None,\n        created_at: str | datetime | None = None,\n        updated_at: str | datetime | None = None,\n        plugins: AsyncIndexPlugins | None = None,\n    ):\n        \"\"\"Class initializer.\n\n        Args:\n\n            http_client: An instance of the AsyncClient. This automatically gets passed by the\n                AsyncClient when creating and AsyncIndex instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            created_at: The date and time the index was created. Defaults to None.\n            updated_at: The date and time the index was last updated. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n        \"\"\"\n        super().__init__(uid, primary_key, created_at, updated_at)\n        self.http_client = http_client\n        self._http_requests = AsyncHttpRequests(http_client)\n        self.plugins = plugins\n\n    @cached_property\n    def _concurrent_add_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.add_documents_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_add_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.add_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_add_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.add_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_delete_all_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_all_documents_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_all_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_all_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_all_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_all_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_delete_document_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_document_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_document_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_document_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_document_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_document_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_delete_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_documents_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_delete_documents_by_filter_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_by_filter_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_documents_by_filter_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_by_filter_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_documents_by_filter_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_by_filter_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_facet_search_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.facet_search_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_facet_search_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.facet_search_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_facet_search_plugins(self) -&gt; list[AsyncPlugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.facet_search_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_search_plugins(self) -&gt; list[AsyncPlugin | AsyncPostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.search_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_search_plugins(self) -&gt; list[AsyncPlugin | AsyncPostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.search_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_search_plugins(self) -&gt; list[AsyncPlugin | AsyncPostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.search_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _concurrent_update_documents_plugins(\n        self,\n    ) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.update_documents_plugins:\n            if plugin.CONCURRENT_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_update_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.update_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_update_documents_plugins(self) -&gt; list[AsyncPlugin | AsyncDocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.update_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    async def delete(self) -&gt; TaskInfo:\n        \"\"\"Deletes the index.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete()\n        \"\"\"\n        response = await self._http_requests.delete(self._base_url_with_uid)\n        return TaskInfo(**response.json())\n\n    async def delete_if_exists(self) -&gt; bool:\n        \"\"\"Delete the index if it already exists.\n\n        Returns:\n\n            True if the index was deleted or False if not.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_if_exists()\n        \"\"\"\n        response = await self.delete()\n        status = await async_wait_for_task(\n            self.http_client, response.task_uid, timeout_in_ms=100000\n        )\n        if status.status == \"succeeded\":\n            return True\n\n        return False\n\n    async def update(self, primary_key: str) -&gt; AsyncIndex:\n        \"\"\"Update the index primary key.\n\n        Args:\n\n            primary_key: The primary key of the documents.\n\n        Returns:\n\n            An instance of the AsyncIndex with the updated information.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     updated_index = await index.update()\n        \"\"\"\n        payload = {\"primaryKey\": primary_key}\n        response = await self._http_requests.patch(self._base_url_with_uid, payload)\n        await async_wait_for_task(\n            self.http_client, response.json()[\"taskUid\"], timeout_in_ms=100000\n        )\n        index_response = await self._http_requests.get(f\"{self._base_url_with_uid}\")\n        self.primary_key = index_response.json()[\"primaryKey\"]\n        return self\n\n    async def fetch_info(self) -&gt; AsyncIndex:\n        \"\"\"Gets the infromation about the index.\n\n        Returns:\n\n            An instance of the AsyncIndex containing the retrieved information.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     index_info = await index.fetch_info()\n        \"\"\"\n        response = await self._http_requests.get(self._base_url_with_uid)\n        index_dict = response.json()\n        self._set_fetch_info(\n            index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n        )\n        return self\n\n    async def get_primary_key(self) -&gt; str | None:\n        \"\"\"Get the primary key.\n\n        Returns:\n\n            The primary key for the documents in the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     primary_key = await index.get_primary_key()\n        \"\"\"\n        info = await self.fetch_info()\n        return info.primary_key\n\n    @classmethod\n    async def create(\n        cls,\n        http_client: AsyncClient,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        plugins: AsyncIndexPlugins | None = None,\n    ) -&gt; AsyncIndex:\n        \"\"\"Creates a new index.\n\n        In general this method should not be used directly and instead the index should be created\n        through the `Client`.\n\n        Args:\n\n            http_client: An instance of the AsyncClient. This automatically gets passed by the\n                Client when creating an AsyncIndex instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An instance of AsyncIndex containing the information of the newly created index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = await index.create(client, \"movies\")\n        \"\"\"\n        if not primary_key:\n            payload = {\"uid\": uid}\n        else:\n            payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n        url = \"indexes\"\n        http_request = AsyncHttpRequests(http_client)\n        response = await http_request.post(url, payload)\n        await async_wait_for_task(http_client, response.json()[\"taskUid\"], timeout_in_ms=None)\n\n        index_response = await http_request.get(f\"{url}/{uid}\")\n        index_dict = index_response.json()\n        index = cls(\n            http_client=http_client,\n            uid=index_dict[\"uid\"],\n            primary_key=index_dict[\"primaryKey\"],\n            created_at=index_dict[\"createdAt\"],\n            updated_at=index_dict[\"updatedAt\"],\n            plugins=plugins,\n        )\n\n        if settings:\n            settings_task = await index.update_settings(settings)\n            if wait:\n                await async_wait_for_task(http_client, settings_task.task_uid, timeout_in_ms=None)\n\n        return index\n\n    async def get_stats(self) -&gt; IndexStats:\n        \"\"\"Get stats of the index.\n\n        Returns:\n\n            Stats of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     stats = await index.get_stats()\n        \"\"\"\n        response = await self._http_requests.get(self._stats_url)\n\n        return IndexStats(**response.json())\n\n    async def search(\n        self,\n        query: str | None = None,\n        *,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] = [\"*\"],\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: str = \"all\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        vector: list[float] | None = None,\n        hybrid: Hybrid | None = None,\n    ) -&gt; SearchResults:\n        \"\"\"Search the index.\n\n        Args:\n\n            query: String containing the word(s) to search\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximun number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the matches should be\n                returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words excedes the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n                In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n\n        Returns:\n\n            Results of the search\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = await index.search(\"Tron\")\n        \"\"\"\n\n        body = _process_search_parameters(\n            q=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n        )\n        search_url = f\"{self._base_url_with_uid}/search\"\n\n        if self._pre_search_plugins:\n            await AsyncIndex._run_plugins(\n                self._pre_search_plugins,\n                AsyncEvent.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                vector=vector,\n                hybrid=hybrid,\n            )\n\n        if self._concurrent_search_plugins:\n            if not use_task_groups():\n                concurrent_tasks: Any = []\n                for plugin in self._concurrent_search_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        concurrent_tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                vector=vector,\n                            )\n                        )\n\n                concurrent_tasks.append(self._http_requests.post(search_url, body=body))\n\n                responses = await asyncio.gather(*concurrent_tasks)\n                result = SearchResults(**responses[-1].json())\n                if self._post_search_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_search_plugins, AsyncEvent.POST, search_results=result\n                    )\n                    if post.get(\"search_result\"):\n                        result = post[\"search_result\"]\n\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_search_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                vector=vector,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n            response = await response_coroutine\n            result = SearchResults(**response.json())\n            if self._post_search_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_search_plugins, AsyncEvent.POST, search_results=result\n                )\n                if post.get(\"search_result\"):\n                    result = post[\"search_result\"]\n\n            return result\n\n        response = await self._http_requests.post(search_url, body=body)\n        result = SearchResults(**response.json())\n\n        if self._post_search_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_search_plugins, AsyncEvent.POST, search_results=result\n            )\n            if post.get(\"search_result\"):\n                result = post[\"search_result\"]\n\n        return result\n\n    async def facet_search(\n        self,\n        query: str | None = None,\n        *,\n        facet_name: str,\n        facet_query: str,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] = [\"*\"],\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: str = \"all\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        vector: list[float] | None = None,\n    ) -&gt; FacetSearchResults:\n        \"\"\"Search the index.\n\n        Args:\n\n            query: String containing the word(s) to search\n            facet_name: The name of the facet to search\n            facet_query: The facet search value\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximun number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the matches should be\n                returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words excedes the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n\n        Returns:\n\n            Results of the search\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     search_results = await index.search(\n            &gt;&gt;&gt;         \"Tron\",\n            &gt;&gt;&gt;         facet_name=\"genre\",\n            &gt;&gt;&gt;         facet_query=\"Sci-fi\"\n            &gt;&gt;&gt;     )\n        \"\"\"\n        body = _process_search_parameters(\n            q=query,\n            facet_name=facet_name,\n            facet_query=facet_query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n        )\n        search_url = f\"{self._base_url_with_uid}/facet-search\"\n\n        if self._pre_facet_search_plugins:\n            await AsyncIndex._run_plugins(\n                self._pre_facet_search_plugins,\n                AsyncEvent.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                vector=vector,\n            )\n\n        if self._concurrent_facet_search_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_facet_search_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                vector=vector,\n                            )\n                        )\n\n                tasks.append(self._http_requests.post(search_url, body=body))\n                responses = await asyncio.gather(*tasks)\n                result = FacetSearchResults(**responses[-1].json())\n                if self._post_facet_search_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_facet_search_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post[\"generic_result\"], FacetSearchResults):\n                        result = post[\"generic_result\"]\n\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_facet_search_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                query=query,\n                                offset=offset,\n                                limit=limit,\n                                filter=filter,\n                                facets=facets,\n                                attributes_to_retrieve=attributes_to_retrieve,\n                                attributes_to_crop=attributes_to_crop,\n                                crop_length=crop_length,\n                                attributes_to_highlight=attributes_to_highlight,\n                                sort=sort,\n                                show_matches_position=show_matches_position,\n                                highlight_pre_tag=highlight_pre_tag,\n                                highlight_post_tag=highlight_post_tag,\n                                crop_marker=crop_marker,\n                                matching_strategy=matching_strategy,\n                                hits_per_page=hits_per_page,\n                                page=page,\n                                attributes_to_search_on=attributes_to_search_on,\n                                show_ranking_score=show_ranking_score,\n                                show_ranking_score_details=show_ranking_score_details,\n                                vector=vector,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n            response = await response_coroutine\n            result = FacetSearchResults(**response.json())\n            if self._post_facet_search_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_facet_search_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], FacetSearchResults):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.post(search_url, body=body)\n        result = FacetSearchResults(**response.json())\n        if self._post_facet_search_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_facet_search_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], FacetSearchResults):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def get_document(self, document_id: str) -&gt; JsonDict:\n        \"\"\"Get one document with given document identifier.\n\n        Args:\n\n            document_id: Unique identifier of the document.\n\n        Returns:\n\n            The document information\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     document = await index.get_document(\"1234\")\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._documents_url}/{document_id}\")\n\n        return response.json()\n\n    async def get_documents(\n        self,\n        *,\n        offset: int = 0,\n        limit: int = 20,\n        fields: list[str] | None = None,\n        filter: Filter | None = None,\n    ) -&gt; DocumentsInfo:\n        \"\"\"Get a batch documents from the index.\n\n        Args:\n\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returnedd. Defaults to 20.\n            fields: Document attributes to show. If this value is None then all\n                attributes are retrieved. Defaults to None.\n            filter: Filter value information. Defaults to None. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.2.0\n\n        Returns:\n\n            Documents info.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     documents = await index.get_documents()\n        \"\"\"\n        parameters: JsonDict = {\n            \"offset\": offset,\n            \"limit\": limit,\n        }\n\n        if not filter:\n            if fields:\n                parameters[\"fields\"] = \",\".join(fields)\n\n            url = _build_encoded_url(self._documents_url, parameters)\n            response = await self._http_requests.get(url)\n\n            return DocumentsInfo(**response.json())\n\n        if fields:\n            parameters[\"fields\"] = fields\n\n        parameters[\"filter\"] = filter\n\n        response = await self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n        return DocumentsInfo(**response.json())\n\n    async def add_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index.\n\n        Args:\n\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents(documents)\n        \"\"\"\n        if primary_key:\n            url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n        else:\n            url = self._documents_url\n\n        if self._pre_add_documents_plugins:\n            pre = await AsyncIndex._run_plugins(\n                self._pre_add_documents_plugins,\n                AsyncEvent.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        if self._concurrent_add_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_add_documents_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if _plugin_has_method(plugin, \"run_document_plugin\"):\n                        tasks.append(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                tasks.append(self._http_requests.post(url, documents, compress=compress))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_add_documents_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_add_documents_plugins,\n                        AsyncEvent.POST,\n                        result=result,\n                        documents=documents,\n                        primary_key=primary_key,\n                    )\n                    if isinstance(post[\"generic_result\"], TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_add_documents_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if _plugin_has_method(plugin, \"run_document_plugin\"):\n                        tg.create_task(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(\n                    self._http_requests.post(url, documents, compress=compress)\n                )\n\n            response = await response_coroutine\n            result = TaskInfo(**response.json())\n            if self._post_add_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_add_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.post(url, documents, compress=compress)\n\n        result = TaskInfo(**response.json())\n        if self._post_add_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_add_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def add_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n        Args:\n\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_in_batches(documents)\n        \"\"\"\n        if not use_task_groups():\n            batches = [\n                self.add_documents(x, primary_key, compress=compress)\n                for x in _batch(documents, batch_size)\n            ]\n            return await asyncio.gather(*batches)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = [\n                tg.create_task(self.add_documents(x, primary_key, compress=compress))\n                for x in _batch(documents, batch_size)\n            ]\n\n        return [x.result() for x in tasks]\n\n    async def add_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n            response = await self.add_documents(combined, primary_key, compress=compress)\n\n            return [response]\n\n        if not use_task_groups():\n            add_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    add_documents.append(\n                        self.add_documents(documents, primary_key, compress=compress)\n                    )\n\n            _raise_on_no_documents(add_documents, document_type, directory_path)\n\n            if len(add_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = [await add_documents.pop()]\n\n                responses = await asyncio.gather(*add_documents)\n                responses = [*first_response, *responses]\n            else:\n                responses = [await add_documents[0]]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = []\n            all_results = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    if i == 0:\n                        all_results = [await self.add_documents(documents, compress=compress)]\n                    else:\n                        tasks.append(\n                            tg.create_task(\n                                self.add_documents(documents, primary_key, compress=compress)\n                            )\n                        )\n\n        results = [x.result() for x in tasks]\n        all_results = [*all_results, *results]\n        _raise_on_no_documents(all_results, document_type, directory_path)\n        return all_results\n\n    async def add_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(\n                        path, csv_delimiter=csv_delimiter\n                    )\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n            return await self.add_documents_in_batches(\n                combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n            )\n\n        responses: list[TaskInfo] = []\n\n        add_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                add_documents.append(\n                    self.add_documents_in_batches(\n                        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n                    )\n                )\n\n        _raise_on_no_documents(add_documents, document_type, directory_path)\n\n        if len(add_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = await add_documents.pop()\n            responses_gather = await asyncio.gather(*add_documents)\n            responses = [*first_response, *[x for y in responses_gather for x in y]]\n        else:\n            responses = await add_documents[0]\n\n        return responses\n\n    async def add_documents_from_file(\n        self, file_path: Path | str, primary_key: str | None = None, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index from a json file.\n\n        Args:\n\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_file(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(file_path)\n\n        return await self.add_documents(documents, primary_key=primary_key, compress=compress)\n\n    async def add_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(file_path, csv_delimiter)\n\n        return await self.add_documents_in_batches(\n            documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    async def add_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        *,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.add_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n        if not upload_path.exists():\n            raise MeilisearchError(\"No file found at the specified path\")\n\n        if upload_path.suffix not in (\".csv\", \".ndjson\"):\n            raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n        if csv_delimiter and upload_path.suffix != \".csv\":\n            raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n        if (\n            csv_delimiter\n            and len(csv_delimiter) != 1\n            or csv_delimiter\n            and not csv_delimiter.isascii()\n        ):\n            raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n        content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n\n        if parameters:\n            url = _build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        async with aiofiles.open(upload_path, \"r\") as f:\n            data = await f.read()\n\n        response = await self._http_requests.post(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def update_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Update documents in the index.\n\n        Args:\n\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents(documents)\n        \"\"\"\n        if primary_key:\n            url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n        else:\n            url = self._documents_url\n\n        if self._pre_update_documents_plugins:\n            pre = await AsyncIndex._run_plugins(\n                self._pre_update_documents_plugins,\n                AsyncEvent.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        if self._concurrent_update_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_update_documents_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tasks.append(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if _plugin_has_method(plugin, \"run_document_plugin\"):\n                        tasks.append(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                tasks.append(self._http_requests.put(url, documents, compress=compress))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_update_documents_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_update_documents_plugins,\n                        AsyncEvent.POST,\n                        result=result,\n                        documents=documents,\n                        primary_key=primary_key,\n                    )\n                    if isinstance(post[\"generic_result\"], TaskInfo):\n                        result = post[\"generic_result\"]\n\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_update_documents_plugins:\n                    if _plugin_has_method(plugin, \"run_plugin\"):\n                        tg.create_task(\n                            plugin.run_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n                    if _plugin_has_method(plugin, \"run_document_plugin\"):\n                        tg.create_task(\n                            plugin.run_document_plugin(  # type: ignore[union-attr]\n                                event=AsyncEvent.CONCURRENT,\n                                documents=documents,\n                                primary_key=primary_key,\n                            )\n                        )\n\n                response_coroutine = tg.create_task(\n                    self._http_requests.put(url, documents, compress=compress)\n                )\n\n            response = await response_coroutine\n            result = TaskInfo(**response.json())\n            if self._post_update_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_update_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.put(url, documents, compress=compress)\n        result = TaskInfo(**response.json())\n        if self._post_update_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_update_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def update_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n        Each batch tries to fill the max_payload_size\n\n        Args:\n\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_in_batches(documents)\n        \"\"\"\n        if not use_task_groups():\n            batches = [\n                self.update_documents(x, primary_key, compress=compress)\n                for x in _batch(documents, batch_size)\n            ]\n            return await asyncio.gather(*batches)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = [\n                tg.create_task(self.update_documents(x, primary_key, compress=compress))\n                for x in _batch(documents, batch_size)\n            ]\n        return [x.result() for x in tasks]\n\n    async def update_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n            response = await self.update_documents(combined, primary_key, compress=compress)\n            return [response]\n\n        if not use_task_groups():\n            update_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    update_documents.append(\n                        self.update_documents(documents, primary_key, compress=compress)\n                    )\n\n            _raise_on_no_documents(update_documents, document_type, directory_path)\n\n            if len(update_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = [await update_documents.pop()]\n                responses = await asyncio.gather(*update_documents)\n                responses = [*first_response, *responses]\n            else:\n                responses = [await update_documents[0]]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tasks = []\n            results = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    if i == 0:\n                        results = [\n                            await self.update_documents(documents, primary_key, compress=compress)\n                        ]\n                    else:\n                        tasks.append(\n                            tg.create_task(\n                                self.update_documents(documents, primary_key, compress=compress)\n                            )\n                        )\n\n        results = [*results, *[x.result() for x in tasks]]\n        _raise_on_no_documents(results, document_type, directory_path)\n        return results\n\n    async def update_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            loop = asyncio.get_running_loop()\n            combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n            return await self.update_documents_in_batches(\n                combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n            )\n\n        if not use_task_groups():\n            responses: list[TaskInfo] = []\n\n            update_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    update_documents.append(\n                        self.update_documents_in_batches(\n                            documents,\n                            batch_size=batch_size,\n                            primary_key=primary_key,\n                            compress=compress,\n                        )\n                    )\n\n            _raise_on_no_documents(update_documents, document_type, directory_path)\n\n            if len(update_documents) &gt; 1:\n                # Send the first document on its own before starting the gather. Otherwise Meilisearch\n                # returns an error because it thinks all entries are trying to create the same index.\n                first_response = await update_documents.pop()\n                responses_gather = await asyncio.gather(*update_documents)\n                responses = [*first_response, *[x for y in responses_gather for x in y]]\n            else:\n                responses = await update_documents[0]\n\n            return responses\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            results = []\n            tasks = []\n            for i, path in enumerate(directory.iterdir()):\n                if path.suffix == f\".{document_type}\":\n                    documents = await _async_load_documents_from_file(path, csv_delimiter)\n                    if i == 0:\n                        results = await self.update_documents_in_batches(\n                            documents,\n                            batch_size=batch_size,\n                            primary_key=primary_key,\n                            compress=compress,\n                        )\n                    else:\n                        tasks.append(\n                            tg.create_task(\n                                self.update_documents_in_batches(\n                                    documents,\n                                    batch_size=batch_size,\n                                    primary_key=primary_key,\n                                    compress=compress,\n                                )\n                            )\n                        )\n\n        results = [*results, *[x for y in tasks for x in y.result()]]\n        _raise_on_no_documents(results, document_type, directory_path)\n        return results\n\n    async def update_documents_from_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents in the index from a json file.\n\n        Args:\n\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_file(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(file_path, csv_delimiter)\n\n        return await self.update_documents(documents, primary_key=primary_key, compress=compress)\n\n    async def update_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = await _async_load_documents_from_file(file_path)\n\n        return await self.update_documents_in_batches(\n            documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    async def update_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n        if not upload_path.exists():\n            raise MeilisearchError(\"No file found at the specified path\")\n\n        if upload_path.suffix not in (\".csv\", \".ndjson\"):\n            raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n        if csv_delimiter and upload_path.suffix != \".csv\":\n            raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n        if (\n            csv_delimiter\n            and len(csv_delimiter) != 1\n            or csv_delimiter\n            and not csv_delimiter.isascii()\n        ):\n            raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n        content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n\n        if parameters:\n            url = _build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        async with aiofiles.open(upload_path, \"r\") as f:\n            data = await f.read()\n\n        response = await self._http_requests.put(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def delete_document(self, document_id: str) -&gt; TaskInfo:\n        \"\"\"Delete one document from the index.\n\n        Args:\n\n            document_id: Unique identifier of the document.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_document(\"1234\")\n        \"\"\"\n        url = f\"{self._documents_url}/{document_id}\"\n\n        if self._pre_delete_document_plugins:\n            await AsyncIndex._run_plugins(\n                self._pre_delete_document_plugins, AsyncEvent.PRE, document_id=document_id\n            )\n\n        if self._concurrent_delete_document_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_document_plugins:\n                    tasks.append(\n                        plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                    )\n\n                tasks.append(self._http_requests.delete(url))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_document_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_delete_document_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post.get(\"generic_result\"), TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_document_plugins:\n                    tg.create_task(\n                        plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                    )\n\n                response_coroutine = tg.create_task(self._http_requests.delete(url))\n\n            response = await response_coroutine\n            result = TaskInfo(**response.json())\n            if self._post_delete_document_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_document_plugins, event=AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        response = await self._http_requests.delete(url)\n        result = TaskInfo(**response.json())\n        if self._post_delete_document_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_document_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def delete_documents(self, ids: list[str]) -&gt; TaskInfo:\n        \"\"\"Delete multiple documents from the index.\n\n        Args:\n\n            ids: List of unique identifiers of documents.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_documents([\"1234\", \"5678\"])\n        \"\"\"\n        url = f\"{self._documents_url}/delete-batch\"\n\n        if self._pre_delete_documents_plugins:\n            await AsyncIndex._run_plugins(\n                self._pre_delete_documents_plugins, AsyncEvent.PRE, ids=ids\n            )\n\n        if self._concurrent_delete_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_documents_plugins:\n                    tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n                tasks.append(self._http_requests.post(url, ids))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_documents_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post.get(\"generic_result\"), TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_documents_plugins:\n                    tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n                response_coroutine = tg.create_task(self._http_requests.post(url, ids))\n\n            response = await response_coroutine\n            result = TaskInfo(**response.json())\n            if self._post_delete_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        response = await self._http_requests.post(url, ids)\n        result = TaskInfo(**response.json())\n        if self._post_delete_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    async def delete_documents_by_filter(self, filter: Filter) -&gt; TaskInfo:\n        \"\"\"Delete documents from the index by filter.\n\n        Args:\n\n            filter: The filter value information.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_pyrhon_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_documents_by_filter(\"genre=horor\"))\n        \"\"\"\n        url = f\"{self._documents_url}/delete\"\n\n        if self._pre_delete_documents_by_filter_plugins:\n            await AsyncIndex._run_plugins(\n                self._pre_delete_documents_by_filter_plugins, AsyncEvent.PRE, filter=filter\n            )\n\n        if self._concurrent_delete_documents_by_filter_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                    tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n                tasks.append(self._http_requests.post(url, body={\"filter\": filter}))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_documents_by_filter_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_delete_documents_by_filter_plugins,\n                        AsyncEvent.POST,\n                        result=result,\n                    )\n                    if isinstance(post[\"generic_result\"], TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                    tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n                response_coroutine = tg.create_task(\n                    self._http_requests.post(url, body={\"filter\": filter})\n                )\n\n            response = await response_coroutine\n            result = TaskInfo(**response.json())\n            if self._post_delete_documents_by_filter_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        response = await self._http_requests.post(url, body={\"filter\": filter})\n        result = TaskInfo(**response.json())\n        if self._post_delete_documents_by_filter_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    async def delete_documents_in_batches_by_filter(\n        self, filters: list[str | list[str | list[str]]]\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Delete batches of documents from the index by filter.\n\n        Args:\n\n            filters: A list of filter value information.\n\n        Returns:\n\n            The a list of details of the task statuses.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_documents_in_batches_by_filter(\n            &gt;&gt;&gt;         [\n            &gt;&gt;&gt;             \"genre=horor\"),\n            &gt;&gt;&gt;             \"release_date=1520035200\"),\n            &gt;&gt;&gt;         ]\n            &gt;&gt;&gt;     )\n        \"\"\"\n        if not use_task_groups():\n            tasks = [self.delete_documents_by_filter(filter) for filter in filters]\n            return await asyncio.gather(*tasks)\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            tg_tasks = [\n                tg.create_task(self.delete_documents_by_filter(filter)) for filter in filters\n            ]\n\n        return [x.result() for x in tg_tasks]\n\n    async def delete_all_documents(self) -&gt; TaskInfo:\n        \"\"\"Delete all documents from the index.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.delete_all_document()\n        \"\"\"\n        if self._pre_delete_all_documents_plugins:\n            await AsyncIndex._run_plugins(self._pre_delete_all_documents_plugins, AsyncEvent.PRE)\n\n        if self._concurrent_delete_all_documents_plugins:\n            if not use_task_groups():\n                tasks: Any = []\n                for plugin in self._concurrent_delete_all_documents_plugins:\n                    tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n                tasks.append(self._http_requests.delete(self._documents_url))\n\n                responses = await asyncio.gather(*tasks)\n                result = TaskInfo(**responses[-1].json())\n                if self._post_delete_all_documents_plugins:\n                    post = await AsyncIndex._run_plugins(\n                        self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n                    )\n                    if isinstance(post.get(\"generic_result\"), TaskInfo):\n                        result = post[\"generic_result\"]\n                return result\n\n            async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n                for plugin in self._concurrent_delete_all_documents_plugins:\n                    tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n                response_coroutine = tg.create_task(self._http_requests.delete(self._documents_url))\n\n            response = await response_coroutine\n            result = TaskInfo(**response.json())\n            if self._post_delete_all_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        response = await self._http_requests.delete(self._documents_url)\n        result = TaskInfo(**response.json())\n        if self._post_delete_all_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    async def get_settings(self) -&gt; MeilisearchSettings:\n        \"\"\"Get settings of the index.\n\n        Returns:\n\n            Settings of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     settings = await index.get_settings()\n        \"\"\"\n        response = await self._http_requests.get(self._settings_url)\n        response_json = response.json()\n        settings = MeilisearchSettings(**response_json)\n\n        if response_json.get(\"embedders\"):\n            settings.embedders = _embedder_json_to_settings_model(response_json[\"embedders\"])\n\n        return settings\n\n    async def update_settings(\n        self, body: MeilisearchSettings, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update settings of the index.\n\n        Args:\n\n            body: Settings of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n            &gt;&gt;&gt; new_settings = MeilisearchSettings(\n            &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n            &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n            &gt;&gt;&gt;     ranking_rules=[\n            &gt;&gt;&gt;         \"words\",\n            &gt;&gt;&gt;         \"typo\",\n            &gt;&gt;&gt;         \"proximity\",\n            &gt;&gt;&gt;         \"attribute\",\n            &gt;&gt;&gt;         \"sort\",\n            &gt;&gt;&gt;         \"exactness\",\n            &gt;&gt;&gt;         \"release_date:desc\",\n            &gt;&gt;&gt;         \"rank:desc\",\n            &gt;&gt;&gt;    ],\n            &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n            &gt;&gt;&gt;    distinct_attribute=\"url\",\n            &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n            &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n            &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_settings(new_settings)\n        \"\"\"\n        if is_pydantic_2():\n            body_dict = {k: v for k, v in body.model_dump(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            body_dict = {k: v for k, v in body.dict(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n\n        response = await self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n        return TaskInfo(**response.json())\n\n    async def reset_settings(self) -&gt; TaskInfo:\n        \"\"\"Reset settings of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_settings()\n        \"\"\"\n        response = await self._http_requests.delete(self._settings_url)\n\n        return TaskInfo(**response.json())\n\n    async def get_ranking_rules(self) -&gt; list[str]:\n        \"\"\"Get ranking rules of the index.\n\n        Returns:\n\n            List containing the ranking rules of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     ranking_rules = await index.get_ranking_rules()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n        return response.json()\n\n    async def update_ranking_rules(\n        self, ranking_rules: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update ranking rules of the index.\n\n        Args:\n\n            ranking_rules: List containing the ranking rules.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; ranking_rules=[\n            &gt;&gt;&gt;      \"words\",\n            &gt;&gt;&gt;      \"typo\",\n            &gt;&gt;&gt;      \"proximity\",\n            &gt;&gt;&gt;      \"attribute\",\n            &gt;&gt;&gt;      \"sort\",\n            &gt;&gt;&gt;      \"exactness\",\n            &gt;&gt;&gt;      \"release_date:desc\",\n            &gt;&gt;&gt;      \"rank:desc\",\n            &gt;&gt;&gt; ],\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_ranking_rules(ranking_rules)\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_ranking_rules(self) -&gt; TaskInfo:\n        \"\"\"Reset ranking rules of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_ranking_rules()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n        return TaskInfo(**response.json())\n\n    async def get_distinct_attribute(self) -&gt; str | None:\n        \"\"\"Get distinct attribute of the index.\n\n        Returns:\n\n            String containing the distinct attribute of the index. If no distinct attribute\n                `None` is returned.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     distinct_attribute = await index.get_distinct_attribute()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n        if not response.json():\n            None\n\n        return response.json()\n\n    async def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update distinct attribute of the index.\n\n        Args:\n\n            body: Distinct attribute.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_distinct_attribute(\"url\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_distinct_attribute(self) -&gt; TaskInfo:\n        \"\"\"Reset distinct attribute of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_distinct_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n        return TaskInfo(**response.json())\n\n    async def get_searchable_attributes(self) -&gt; list[str]:\n        \"\"\"Get searchable attributes of the index.\n\n        Returns:\n\n            List containing the searchable attributes of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     searchable_attributes = await index.get_searchable_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n        return response.json()\n\n    async def update_searchable_attributes(\n        self, body: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update searchable attributes of the index.\n\n        Args:\n\n            body: List containing the searchable attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_searchable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset searchable attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_searchable_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n        return TaskInfo(**response.json())\n\n    async def get_displayed_attributes(self) -&gt; list[str]:\n        \"\"\"Get displayed attributes of the index.\n\n        Returns:\n\n            List containing the displayed attributes of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     displayed_attributes = await index.get_displayed_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n        return response.json()\n\n    async def update_displayed_attributes(\n        self, body: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update displayed attributes of the index.\n\n        Args:\n\n            body: List containing the displayed attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_displayed_attributes(\n            &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n            &gt;&gt;&gt;     )\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_displayed_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset displayed attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_displayed_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n        return TaskInfo(**response.json())\n\n    async def get_stop_words(self) -&gt; list[str] | None:\n        \"\"\"Get stop words of the index.\n\n        Returns:\n\n            List containing the stop words of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     stop_words = await index.get_stop_words()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n        if not response.json():\n            return None\n\n        return response.json()\n\n    async def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update stop words of the index.\n\n        Args:\n\n            body: List containing the stop words of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_stop_words([\"the\", \"a\", \"an\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/stop-words\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_stop_words(self) -&gt; TaskInfo:\n        \"\"\"Reset stop words of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_stop_words()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n        return TaskInfo(**response.json())\n\n    async def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n        \"\"\"Get synonyms of the index.\n\n        Returns:\n\n            The synonyms of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     synonyms = await index.get_synonyms()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n        if not response.json():\n            return None\n\n        return response.json()\n\n    async def update_synonyms(\n        self, body: dict[str, list[str]], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update synonyms of the index.\n\n        Args:\n\n            body: The synonyms of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_synonyms(\n            &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n            &gt;&gt;&gt;     )\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/synonyms\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_synonyms(self) -&gt; TaskInfo:\n        \"\"\"Reset synonyms of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_synonyms()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n        return TaskInfo(**response.json())\n\n    async def get_filterable_attributes(self) -&gt; list[str] | None:\n        \"\"\"Get filterable attributes of the index.\n\n        Returns:\n\n            List containing the filterable attributes of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     filterable_attributes = await index.get_filterable_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n        if not response.json():\n            return None\n\n        return response.json()\n\n    async def update_filterable_attributes(\n        self, body: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update filterable attributes of the index.\n\n        Args:\n\n            body: List containing the filterable attributes of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_filterable_attributes([\"genre\", \"director\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/filterable-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_filterable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset filterable attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_filterable_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n        return TaskInfo(**response.json())\n\n    async def get_sortable_attributes(self) -&gt; list[str]:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Returns:\n\n            List containing the sortable attributes of the AsyncIndex.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     sortable_attributes = await index.get_sortable_attributes()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n        return response.json()\n\n    async def update_sortable_attributes(\n        self, sortable_attributes: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Args:\n\n            sortable_attributes: List of attributes for searching.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_sortable_attributes([\"title\", \"release_date\"])\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_sortable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset sortable attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_sortable_attributes()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n        return TaskInfo(**response.json())\n\n    async def get_typo_tolerance(self) -&gt; TypoTolerance:\n        \"\"\"Get typo tolerance for the index.\n\n        Returns:\n\n            TypoTolerance for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     sortable_attributes = await index.get_typo_tolerance()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n        return TypoTolerance(**response.json())\n\n    async def update_typo_tolerance(\n        self, typo_tolerance: TypoTolerance, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update typo tolerance.\n\n        Args:\n\n            typo_tolerance: Typo tolerance settings.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     TypoTolerance(enabled=False)\n            &gt;&gt;&gt;     await index.update_typo_tolerance()\n        \"\"\"\n        if is_pydantic_2():\n            response = await self._http_requests.patch(\n                f\"{self._settings_url}/typo-tolerance\",\n                typo_tolerance.model_dump(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = await self._http_requests.patch(\n                f\"{self._settings_url}/typo-tolerance\",\n                typo_tolerance.dict(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n\n        return TaskInfo(**response.json())\n\n    async def reset_typo_tolerance(self) -&gt; TaskInfo:\n        \"\"\"Reset typo tolerance to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_typo_tolerance()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n        return TaskInfo(**response.json())\n\n    async def get_faceting(self) -&gt; Faceting:\n        \"\"\"Get faceting for the index.\n\n        Returns:\n\n            Faceting for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     faceting = await index.get_faceting()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n        return Faceting(**response.json())\n\n    async def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the faceting settings for an index.\n\n        Args:\n\n            faceting: Faceting values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n        \"\"\"\n        if is_pydantic_2():\n            response = await self._http_requests.patch(\n                f\"{self._settings_url}/faceting\",\n                faceting.model_dump(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = await self._http_requests.patch(\n                f\"{self._settings_url}/faceting\", faceting.dict(by_alias=True), compress=compress\n            )  # type: ignore[attr-defined]\n\n        return TaskInfo(**response.json())\n\n    async def reset_faceting(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's faceting settings to their default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_faceting()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n        return TaskInfo(**response.json())\n\n    async def get_pagination(self) -&gt; Pagination:\n        \"\"\"Get pagination settings for the index.\n\n        Returns:\n\n            Pagination for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     pagination_settings = await index.get_pagination()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n        return Pagination(**response.json())\n\n    async def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the pagination settings for an index.\n\n        Args:\n\n            settings: settings for pagination.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_pagination(settings=Pagination(max_total_hits=123))\n        \"\"\"\n        if is_pydantic_2():\n            response = await self._http_requests.patch(\n                f\"{self._settings_url}/pagination\",\n                settings.model_dump(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = await self._http_requests.patch(\n                f\"{self._settings_url}/pagination\", settings.dict(by_alias=True), compress=compress\n            )  # type: ignore[attr-defined]\n\n        return TaskInfo(**response.json())\n\n    async def reset_pagination(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's pagination settings to their default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_pagination()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n        return TaskInfo(**response.json())\n\n    async def get_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get separator token settings for the index.\n\n        Returns:\n\n            Separator tokens for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     separator_token_settings = await index.get_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n        return response.json()\n\n    async def update_separator_tokens(\n        self, separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the separator tokens settings for an index.\n\n        Args:\n\n            separator_tokens: List of separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's separator tokens settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n        return TaskInfo(**response.json())\n\n    async def get_non_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get non-separator token settings for the index.\n\n        Returns:\n\n            Non-separator tokens for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     non_separator_token_settings = await index.get_non_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n        return response.json()\n\n    async def update_non_separator_tokens(\n        self, non_separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the non-separator tokens settings for an index.\n\n        Args:\n\n            non_separator_tokens: List of non-separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_non_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_non_separator_tokens()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n        return TaskInfo(**response.json())\n\n    async def get_word_dictionary(self) -&gt; list[str]:\n        \"\"\"Get word dictionary settings for the index.\n\n        Returns:\n\n            Word dictionary for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     word_dictionary = await index.get_word_dictionary()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n        return response.json()\n\n    async def update_word_dictionary(\n        self, dictionary: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the word dictionary settings for an index.\n\n        Args:\n\n            dictionary: List of dictionary values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_word_dictionary(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's word dictionary settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_word_dictionary()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n        return TaskInfo(**response.json())\n\n    async def get_proximity_precision(self) -&gt; ProximityPrecision:\n        \"\"\"Get proximity precision settings for the index.\n\n        Returns:\n\n            Proximity precision for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     proximity_precision = await index.get_proximity_precision()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n        return ProximityPrecision[to_snake(response.json()).upper()]\n\n    async def update_proximity_precision(\n        self, proximity_precision: ProximityPrecision, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the proximity precision settings for an index.\n\n        Args:\n\n            proximity_precision: The proximity precision value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n        \"\"\"\n        response = await self._http_requests.put(\n            f\"{self._settings_url}/proximity-precision\",\n            proximity_precision.value,\n            compress=compress,\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_proximity_precision(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's proximity precision settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_proximity_precision()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n        return TaskInfo(**response.json())\n\n    async def get_embedders(self) -&gt; Embedders | None:\n        \"\"\"Get embedder settings for the index.\n\n        Returns:\n\n            Embedders for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     embedders = await index.get_embedders()\n        \"\"\"\n        response = await self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n        return _embedder_json_to_embedders_model(response.json())\n\n    async def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the embedders settings for an index.\n\n        Args:\n\n            embedders: The embedders value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n            &gt;&gt;&gt;\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.update_embedders(\n            &gt;&gt;&gt;         Embedders(embedders={\"default\": UserProvidedEmbedder(dimensions=512)})\n            &gt;&gt;&gt;     )\n        \"\"\"\n        payload = {}\n        for key, embedder in embedders.embedders.items():\n            if is_pydantic_2():\n                payload[key] = {\n                    k: v for k, v in embedder.model_dump(by_alias=True).items() if v is not None\n                }  # type: ignore[attr-defined]\n            else:  # pragma: no cover\n                warn(\n                    \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                    DeprecationWarning,\n                )\n                payload[key] = {\n                    k: v for k, v in embedder.dict(by_alias=True).items() if v is not None\n                }  # type: ignore[attr-defined]\n\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/embedders\", payload, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    async def reset_embedders(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's embedders settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n            &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt;     index = client.index(\"movies\")\n            &gt;&gt;&gt;     await index.reset_embedders()\n        \"\"\"\n        response = await self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n        return TaskInfo(**response.json())\n\n    @staticmethod\n    async def _run_plugins(\n        plugins: Sequence[AsyncPlugin | AsyncDocumentPlugin | AsyncPostSearchPlugin],\n        event: AsyncEvent,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        generic_plugins = []\n        document_plugins = []\n        search_plugins = []\n        results: dict[str, Any] = {\n            \"generic_result\": None,\n            \"document_result\": None,\n            \"search_result\": None,\n        }\n        if not use_task_groups():\n            for plugin in plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    generic_plugins.append(plugin.run_plugin(event=event, **kwargs))  # type: ignore[union-attr]\n                if _plugin_has_method(plugin, \"run_document_plugin\"):\n                    document_plugins.append(plugin.run_document_plugin(event=event, **kwargs))  # type: ignore[union-attr]\n                if _plugin_has_method(plugin, \"run_post_search_plugin\"):\n                    search_plugins.append(plugin.run_post_search_plugin(event=event, **kwargs))  # type: ignore[union-attr]\n            if generic_plugins:\n                generic_results = await asyncio.gather(*generic_plugins)\n                if generic_results:\n                    results[\"generic_result\"] = generic_results[-1]\n\n            if document_plugins:\n                document_results = await asyncio.gather(*document_plugins)\n                if document_results:\n                    results[\"document_result\"] = document_results[-1]\n            if search_plugins:\n                search_results = await asyncio.gather(*search_plugins)\n                if search_results:\n                    results[\"search_result\"] = search_results[-1]\n\n            return results\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            generic_tasks = []\n            document_tasks = []\n            search_tasks = []\n            for plugin in plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    generic_tasks.append(tg.create_task(plugin.run_plugin(event=event, **kwargs)))  # type: ignore[union-attr]\n                if _plugin_has_method(plugin, \"run_document_plugin\"):\n                    document_tasks.append(\n                        tg.create_task(plugin.run_document_plugin(event=event, **kwargs))  # type: ignore[union-attr]\n                    )\n                if _plugin_has_method(plugin, \"run_post_search_plugin\"):\n                    search_tasks.append(\n                        tg.create_task(plugin.run_post_search_plugin(event=event, **kwargs))  # type: ignore[union-attr]\n                    )\n\n        if generic_tasks:\n            for result in reversed(generic_tasks):\n                if result:\n                    results[\"generic_result\"] = await result\n                    break\n\n        if document_tasks:\n            results[\"document_result\"] = await document_tasks[-1]\n\n        if search_tasks:\n            results[\"search_result\"] = await search_tasks[-1]\n\n        return results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.__init__","title":"<code>__init__(http_client, uid, primary_key=None, created_at=None, updated_at=None, plugins=None)</code>","text":"<p>Class initializer.</p> <p>Args:</p> <pre><code>http_client: An instance of the AsyncClient. This automatically gets passed by the\n    AsyncClient when creating and AsyncIndex instance.\nuid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\ncreated_at: The date and time the index was created. Defaults to None.\nupdated_at: The date and time the index was last updated. Defaults to None.\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def __init__(\n    self,\n    http_client: AsyncClient,\n    uid: str,\n    primary_key: str | None = None,\n    created_at: str | datetime | None = None,\n    updated_at: str | datetime | None = None,\n    plugins: AsyncIndexPlugins | None = None,\n):\n    \"\"\"Class initializer.\n\n    Args:\n\n        http_client: An instance of the AsyncClient. This automatically gets passed by the\n            AsyncClient when creating and AsyncIndex instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        created_at: The date and time the index was created. Defaults to None.\n        updated_at: The date and time the index was last updated. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n    \"\"\"\n    super().__init__(uid, primary_key, created_at, updated_at)\n    self.http_client = http_client\n    self._http_requests = AsyncHttpRequests(http_client)\n    self.plugins = plugins\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents","title":"<code>add_documents(documents, primary_key=None, *, compress=False)</code>  <code>async</code>","text":"<p>Add documents to the index.</p> <p>Args:</p> <pre><code>documents: List of documents.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index.\n\n    Args:\n\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents(documents)\n    \"\"\"\n    if primary_key:\n        url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n    else:\n        url = self._documents_url\n\n    if self._pre_add_documents_plugins:\n        pre = await AsyncIndex._run_plugins(\n            self._pre_add_documents_plugins,\n            AsyncEvent.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    if self._concurrent_add_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_add_documents_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if _plugin_has_method(plugin, \"run_document_plugin\"):\n                    tasks.append(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            tasks.append(self._http_requests.post(url, documents, compress=compress))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_add_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_add_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_add_documents_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if _plugin_has_method(plugin, \"run_document_plugin\"):\n                    tg.create_task(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(\n                self._http_requests.post(url, documents, compress=compress)\n            )\n\n        response = await response_coroutine\n        result = TaskInfo(**response.json())\n        if self._post_add_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_add_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.post(url, documents, compress=compress)\n\n    result = TaskInfo(**response.json())\n    if self._post_add_documents_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_add_documents_plugins,\n            AsyncEvent.POST,\n            result=result,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_directory","title":"<code>add_documents_from_directory(directory_path, *, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>  <code>async</code>","text":"<p>Load all json files from a directory and add the documents to the index.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents_from_directory(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n        response = await self.add_documents(combined, primary_key, compress=compress)\n\n        return [response]\n\n    if not use_task_groups():\n        add_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                add_documents.append(\n                    self.add_documents(documents, primary_key, compress=compress)\n                )\n\n        _raise_on_no_documents(add_documents, document_type, directory_path)\n\n        if len(add_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = [await add_documents.pop()]\n\n            responses = await asyncio.gather(*add_documents)\n            responses = [*first_response, *responses]\n        else:\n            responses = [await add_documents[0]]\n\n        return responses\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = []\n        all_results = []\n        for i, path in enumerate(directory.iterdir()):\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                if i == 0:\n                    all_results = [await self.add_documents(documents, compress=compress)]\n                else:\n                    tasks.append(\n                        tg.create_task(\n                            self.add_documents(documents, primary_key, compress=compress)\n                        )\n                    )\n\n    results = [x.result() for x in tasks]\n    all_results = [*all_results, *results]\n    _raise_on_no_documents(all_results, document_type, directory_path)\n    return all_results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_directory_in_batches","title":"<code>add_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>  <code>async</code>","text":"<p>Load all json files from a directory and add the documents to the index in batches.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents_from_directory_in_batches(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(\n                    path, csv_delimiter=csv_delimiter\n                )\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n        return await self.add_documents_in_batches(\n            combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    responses: list[TaskInfo] = []\n\n    add_documents = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = await _async_load_documents_from_file(path, csv_delimiter)\n            add_documents.append(\n                self.add_documents_in_batches(\n                    documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n                )\n            )\n\n    _raise_on_no_documents(add_documents, document_type, directory_path)\n\n    if len(add_documents) &gt; 1:\n        # Send the first document on its own before starting the gather. Otherwise Meilisearch\n        # returns an error because it thinks all entries are trying to create the same index.\n        first_response = await add_documents.pop()\n        responses_gather = await asyncio.gather(*add_documents)\n        responses = [*first_response, *[x for y in responses_gather for x in y]]\n    else:\n        responses = await add_documents[0]\n\n    return responses\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_file","title":"<code>add_documents_from_file(file_path, primary_key=None, *, compress=False)</code>  <code>async</code>","text":"<p>Add documents to the index from a json file.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents_from_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents_from_file(\n    self, file_path: Path | str, primary_key: str | None = None, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index from a json file.\n\n    Args:\n\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_file(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(file_path)\n\n    return await self.add_documents(documents, primary_key=primary_key, compress=compress)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_file_in_batches","title":"<code>add_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, csv_delimiter=None, compress=False)</code>  <code>async</code>","text":"<p>Adds documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents_from_file_in_batches(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(file_path, csv_delimiter)\n\n    return await self.add_documents_in_batches(\n        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_from_raw_file","title":"<code>add_documents_from_raw_file(file_path, primary_key=None, *, csv_delimiter=None, compress=False)</code>  <code>async</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Args:</p> <pre><code>file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n    allowed.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n    a non-csv file.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents_from_raw_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    *,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n    if not upload_path.exists():\n        raise MeilisearchError(\"No file found at the specified path\")\n\n    if upload_path.suffix not in (\".csv\", \".ndjson\"):\n        raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n    if csv_delimiter and upload_path.suffix != \".csv\":\n        raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n    if (\n        csv_delimiter\n        and len(csv_delimiter) != 1\n        or csv_delimiter\n        and not csv_delimiter.isascii()\n    ):\n        raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n    content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n\n    if parameters:\n        url = _build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    async with aiofiles.open(upload_path, \"r\") as f:\n        data = await f.read()\n\n    response = await self._http_requests.post(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.add_documents_in_batches","title":"<code>add_documents_in_batches(documents, *, batch_size=1000, primary_key=None, compress=False)</code>  <code>async</code>","text":"<p>Adds documents in batches to reduce RAM usage with indexing.</p> <p>Args:</p> <pre><code>documents: List of documents.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; &gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.add_documents_in_batches(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def add_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n    Args:\n\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.add_documents_in_batches(documents)\n    \"\"\"\n    if not use_task_groups():\n        batches = [\n            self.add_documents(x, primary_key, compress=compress)\n            for x in _batch(documents, batch_size)\n        ]\n        return await asyncio.gather(*batches)\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = [\n            tg.create_task(self.add_documents(x, primary_key, compress=compress))\n            for x in _batch(documents, batch_size)\n        ]\n\n    return [x.result() for x in tasks]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.create","title":"<code>create(http_client, uid, primary_key=None, *, settings=None, wait=True, plugins=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates a new index.</p> <p>In general this method should not be used directly and instead the index should be created through the <code>Client</code>.</p> <p>Args:</p> <pre><code>http_client: An instance of the AsyncClient. This automatically gets passed by the\n    Client when creating an AsyncIndex instance.\nuid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\nsettings: Settings for the index. The settings can also be updated independently of\n    creating the index. The advantage to updating them here is updating the settings after\n    adding documents will cause the documents to be re-indexed. Because of this it will be\n    faster to update them before adding documents. Defaults to None (i.e. default\n    Meilisearch index settings).\nwait: If set to True and settings are being updated, the index will be returned after\n    the settings update has completed. If False it will not wait for settings to complete.\n    Default: True\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An instance of AsyncIndex containing the information of the newly created index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = await index.create(client, \"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>@classmethod\nasync def create(\n    cls,\n    http_client: AsyncClient,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    plugins: AsyncIndexPlugins | None = None,\n) -&gt; AsyncIndex:\n    \"\"\"Creates a new index.\n\n    In general this method should not be used directly and instead the index should be created\n    through the `Client`.\n\n    Args:\n\n        http_client: An instance of the AsyncClient. This automatically gets passed by the\n            Client when creating an AsyncIndex instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An instance of AsyncIndex containing the information of the newly created index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = await index.create(client, \"movies\")\n    \"\"\"\n    if not primary_key:\n        payload = {\"uid\": uid}\n    else:\n        payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n    url = \"indexes\"\n    http_request = AsyncHttpRequests(http_client)\n    response = await http_request.post(url, payload)\n    await async_wait_for_task(http_client, response.json()[\"taskUid\"], timeout_in_ms=None)\n\n    index_response = await http_request.get(f\"{url}/{uid}\")\n    index_dict = index_response.json()\n    index = cls(\n        http_client=http_client,\n        uid=index_dict[\"uid\"],\n        primary_key=index_dict[\"primaryKey\"],\n        created_at=index_dict[\"createdAt\"],\n        updated_at=index_dict[\"updatedAt\"],\n        plugins=plugins,\n    )\n\n    if settings:\n        settings_task = await index.update_settings(settings)\n        if wait:\n            await async_wait_for_task(http_client, settings_task.task_uid, timeout_in_ms=None)\n\n    return index\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Deletes the index.</p> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete(self) -&gt; TaskInfo:\n    \"\"\"Deletes the index.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete()\n    \"\"\"\n    response = await self._http_requests.delete(self._base_url_with_uid)\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_all_documents","title":"<code>delete_all_documents()</code>  <code>async</code>","text":"<p>Delete all documents from the index.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete_all_document()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete_all_documents(self) -&gt; TaskInfo:\n    \"\"\"Delete all documents from the index.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_all_document()\n    \"\"\"\n    if self._pre_delete_all_documents_plugins:\n        await AsyncIndex._run_plugins(self._pre_delete_all_documents_plugins, AsyncEvent.PRE)\n\n    if self._concurrent_delete_all_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_all_documents_plugins:\n                tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n            tasks.append(self._http_requests.delete(self._documents_url))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_all_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_all_documents_plugins:\n                tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT))\n\n            response_coroutine = tg.create_task(self._http_requests.delete(self._documents_url))\n\n        response = await response_coroutine\n        result = TaskInfo(**response.json())\n        if self._post_delete_all_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    response = await self._http_requests.delete(self._documents_url)\n    result = TaskInfo(**response.json())\n    if self._post_delete_all_documents_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_delete_all_documents_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_document","title":"<code>delete_document(document_id)</code>  <code>async</code>","text":"<p>Delete one document from the index.</p> <p>Args:</p> <pre><code>document_id: Unique identifier of the document.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete_document(\"1234\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete_document(self, document_id: str) -&gt; TaskInfo:\n    \"\"\"Delete one document from the index.\n\n    Args:\n\n        document_id: Unique identifier of the document.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_document(\"1234\")\n    \"\"\"\n    url = f\"{self._documents_url}/{document_id}\"\n\n    if self._pre_delete_document_plugins:\n        await AsyncIndex._run_plugins(\n            self._pre_delete_document_plugins, AsyncEvent.PRE, document_id=document_id\n        )\n\n    if self._concurrent_delete_document_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_document_plugins:\n                tasks.append(\n                    plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                )\n\n            tasks.append(self._http_requests.delete(url))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_document_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_document_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_document_plugins:\n                tg.create_task(\n                    plugin.run_plugin(event=AsyncEvent.CONCURRENT, document_id=document_id)\n                )\n\n            response_coroutine = tg.create_task(self._http_requests.delete(url))\n\n        response = await response_coroutine\n        result = TaskInfo(**response.json())\n        if self._post_delete_document_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_document_plugins, event=AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    response = await self._http_requests.delete(url)\n    result = TaskInfo(**response.json())\n    if self._post_delete_document_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_delete_document_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_documents","title":"<code>delete_documents(ids)</code>  <code>async</code>","text":"<p>Delete multiple documents from the index.</p> <p>Args:</p> <pre><code>ids: List of unique identifiers of documents.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete_documents([\"1234\", \"5678\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete_documents(self, ids: list[str]) -&gt; TaskInfo:\n    \"\"\"Delete multiple documents from the index.\n\n    Args:\n\n        ids: List of unique identifiers of documents.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_documents([\"1234\", \"5678\"])\n    \"\"\"\n    url = f\"{self._documents_url}/delete-batch\"\n\n    if self._pre_delete_documents_plugins:\n        await AsyncIndex._run_plugins(\n            self._pre_delete_documents_plugins, AsyncEvent.PRE, ids=ids\n        )\n\n    if self._concurrent_delete_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_documents_plugins:\n                tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n            tasks.append(self._http_requests.post(url, ids))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post.get(\"generic_result\"), TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_documents_plugins:\n                tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, ids=ids))\n\n            response_coroutine = tg.create_task(self._http_requests.post(url, ids))\n\n        response = await response_coroutine\n        result = TaskInfo(**response.json())\n        if self._post_delete_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n        return result\n\n    response = await self._http_requests.post(url, ids)\n    result = TaskInfo(**response.json())\n    if self._post_delete_documents_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_delete_documents_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_documents_by_filter","title":"<code>delete_documents_by_filter(filter)</code>  <code>async</code>","text":"<p>Delete documents from the index by filter.</p> <p>Args:</p> <pre><code>filter: The filter value information.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_pyrhon_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete_documents_by_filter(\"genre=horor\"))\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete_documents_by_filter(self, filter: Filter) -&gt; TaskInfo:\n    \"\"\"Delete documents from the index by filter.\n\n    Args:\n\n        filter: The filter value information.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_pyrhon_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_documents_by_filter(\"genre=horor\"))\n    \"\"\"\n    url = f\"{self._documents_url}/delete\"\n\n    if self._pre_delete_documents_by_filter_plugins:\n        await AsyncIndex._run_plugins(\n            self._pre_delete_documents_by_filter_plugins, AsyncEvent.PRE, filter=filter\n        )\n\n    if self._concurrent_delete_documents_by_filter_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                tasks.append(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n            tasks.append(self._http_requests.post(url, body={\"filter\": filter}))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_delete_documents_by_filter_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_delete_documents_by_filter_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_delete_documents_by_filter_plugins:\n                tg.create_task(plugin.run_plugin(event=AsyncEvent.CONCURRENT, filter=filter))\n\n            response_coroutine = tg.create_task(\n                self._http_requests.post(url, body={\"filter\": filter})\n            )\n\n        response = await response_coroutine\n        result = TaskInfo(**response.json())\n        if self._post_delete_documents_by_filter_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.post(url, body={\"filter\": filter})\n    result = TaskInfo(**response.json())\n    if self._post_delete_documents_by_filter_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_delete_documents_by_filter_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_documents_in_batches_by_filter","title":"<code>delete_documents_in_batches_by_filter(filters)</code>  <code>async</code>","text":"<p>Delete batches of documents from the index by filter.</p> <p>Args:</p> <pre><code>filters: A list of filter value information.\n</code></pre> <p>Returns:</p> <pre><code>The a list of details of the task statuses.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete_documents_in_batches_by_filter(\n&gt;&gt;&gt;         [\n&gt;&gt;&gt;             \"genre=horor\"),\n&gt;&gt;&gt;             \"release_date=1520035200\"),\n&gt;&gt;&gt;         ]\n&gt;&gt;&gt;     )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete_documents_in_batches_by_filter(\n    self, filters: list[str | list[str | list[str]]]\n) -&gt; list[TaskInfo]:\n    \"\"\"Delete batches of documents from the index by filter.\n\n    Args:\n\n        filters: A list of filter value information.\n\n    Returns:\n\n        The a list of details of the task statuses.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_documents_in_batches_by_filter(\n        &gt;&gt;&gt;         [\n        &gt;&gt;&gt;             \"genre=horor\"),\n        &gt;&gt;&gt;             \"release_date=1520035200\"),\n        &gt;&gt;&gt;         ]\n        &gt;&gt;&gt;     )\n    \"\"\"\n    if not use_task_groups():\n        tasks = [self.delete_documents_by_filter(filter) for filter in filters]\n        return await asyncio.gather(*tasks)\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tg_tasks = [\n            tg.create_task(self.delete_documents_by_filter(filter)) for filter in filters\n        ]\n\n    return [x.result() for x in tg_tasks]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.delete_if_exists","title":"<code>delete_if_exists()</code>  <code>async</code>","text":"<p>Delete the index if it already exists.</p> <p>Returns:</p> <pre><code>True if the index was deleted or False if not.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.delete_if_exists()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def delete_if_exists(self) -&gt; bool:\n    \"\"\"Delete the index if it already exists.\n\n    Returns:\n\n        True if the index was deleted or False if not.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.delete_if_exists()\n    \"\"\"\n    response = await self.delete()\n    status = await async_wait_for_task(\n        self.http_client, response.task_uid, timeout_in_ms=100000\n    )\n    if status.status == \"succeeded\":\n        return True\n\n    return False\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.facet_search","title":"<code>facet_search(query=None, *, facet_name, facet_query, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=['*'], attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='all', hits_per_page=None, page=None, attributes_to_search_on=None, show_ranking_score=False, show_ranking_score_details=False, vector=None)</code>  <code>async</code>","text":"<p>Search the index.</p> <p>Args:</p> <pre><code>query: String containing the word(s) to search\nfacet_name: The name of the facet to search\nfacet_query: The facet search value\noffset: Number of documents to skip. Defaults to 0.\nlimit: Maximum number of documents returned. Defaults to 20.\nfilter: Filter queries by an attribute value. Defaults to None.\nfacets: Facets for which to retrieve the matching count. Defaults to None.\nattributes_to_retrieve: Attributes to display in the returned documents.\n    Defaults to [\"*\"].\nattributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\ncrop_length: The maximun number of words to display. Defaults to 200.\nattributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n    Defaults to None.\nsort: Attributes by which to sort the results. Defaults to None.\nshow_matches_position: Defines whether an object that contains information about the matches should be\n    returned or not. Defaults to False.\nhighlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\nhighlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\ncrop_marker: Marker to display when the number of words excedes the `crop_length`.\n    Defaults to ...\nmatching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\nhits_per_page: Sets the number of results returned per page.\npage: Sets the specific results page to fetch.\nattributes_to_search_on: List of field names. Allow search over a subset of searchable\n    attributes without modifying the index settings. Defaults to None.\nshow_ranking_score: If set to True the ranking score will be returned with each document\n    in the search. Defaults to False.\nshow_ranking_score_details: If set to True the ranking details will be returned with\n    each document in the search. Defaults to False. Note: This parameter can only be\n    used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n    to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n    sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n    Because this feature is experimental it may be removed or updated causing breaking\n    changes in this library without a major version bump so use with caution. This\n    feature became stable in Meiliseach v1.7.0.\nvector: List of vectors for vector search. Defaults to None. Note: This parameter can\n    only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n    In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n    feature by sending a PATCH request to /experimental-features with\n    { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n    updated causing breaking changes in this library without a major version bump so use\n    with caution.\n</code></pre> <p>Returns:</p> <pre><code>Results of the search\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     search_results = await index.search(\n&gt;&gt;&gt;         \"Tron\",\n&gt;&gt;&gt;         facet_name=\"genre\",\n&gt;&gt;&gt;         facet_query=\"Sci-fi\"\n&gt;&gt;&gt;     )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def facet_search(\n    self,\n    query: str | None = None,\n    *,\n    facet_name: str,\n    facet_query: str,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] = [\"*\"],\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: str = \"all\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    vector: list[float] | None = None,\n) -&gt; FacetSearchResults:\n    \"\"\"Search the index.\n\n    Args:\n\n        query: String containing the word(s) to search\n        facet_name: The name of the facet to search\n        facet_query: The facet search value\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximun number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the matches should be\n            returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words excedes the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n\n    Returns:\n\n        Results of the search\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = await index.search(\n        &gt;&gt;&gt;         \"Tron\",\n        &gt;&gt;&gt;         facet_name=\"genre\",\n        &gt;&gt;&gt;         facet_query=\"Sci-fi\"\n        &gt;&gt;&gt;     )\n    \"\"\"\n    body = _process_search_parameters(\n        q=query,\n        facet_name=facet_name,\n        facet_query=facet_query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        vector=vector,\n    )\n    search_url = f\"{self._base_url_with_uid}/facet-search\"\n\n    if self._pre_facet_search_plugins:\n        await AsyncIndex._run_plugins(\n            self._pre_facet_search_plugins,\n            AsyncEvent.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n        )\n\n    if self._concurrent_facet_search_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_facet_search_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            vector=vector,\n                        )\n                    )\n\n            tasks.append(self._http_requests.post(search_url, body=body))\n            responses = await asyncio.gather(*tasks)\n            result = FacetSearchResults(**responses[-1].json())\n            if self._post_facet_search_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_facet_search_plugins, AsyncEvent.POST, result=result\n                )\n                if isinstance(post[\"generic_result\"], FacetSearchResults):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_facet_search_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            vector=vector,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n        response = await response_coroutine\n        result = FacetSearchResults(**response.json())\n        if self._post_facet_search_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_facet_search_plugins, AsyncEvent.POST, result=result\n            )\n            if isinstance(post[\"generic_result\"], FacetSearchResults):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.post(search_url, body=body)\n    result = FacetSearchResults(**response.json())\n    if self._post_facet_search_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_facet_search_plugins, AsyncEvent.POST, result=result\n        )\n        if isinstance(post[\"generic_result\"], FacetSearchResults):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.fetch_info","title":"<code>fetch_info()</code>  <code>async</code>","text":"<p>Gets the infromation about the index.</p> <p>Returns:</p> <pre><code>An instance of the AsyncIndex containing the retrieved information.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     index_info = await index.fetch_info()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def fetch_info(self) -&gt; AsyncIndex:\n    \"\"\"Gets the infromation about the index.\n\n    Returns:\n\n        An instance of the AsyncIndex containing the retrieved information.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     index_info = await index.fetch_info()\n    \"\"\"\n    response = await self._http_requests.get(self._base_url_with_uid)\n    index_dict = response.json()\n    self._set_fetch_info(\n        index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n    )\n    return self\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_displayed_attributes","title":"<code>get_displayed_attributes()</code>  <code>async</code>","text":"<p>Get displayed attributes of the index.</p> <p>Returns:</p> <pre><code>List containing the displayed attributes of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     displayed_attributes = await index.get_displayed_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_displayed_attributes(self) -&gt; list[str]:\n    \"\"\"Get displayed attributes of the index.\n\n    Returns:\n\n        List containing the displayed attributes of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     displayed_attributes = await index.get_displayed_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_distinct_attribute","title":"<code>get_distinct_attribute()</code>  <code>async</code>","text":"<p>Get distinct attribute of the index.</p> <p>Returns:</p> <pre><code>String containing the distinct attribute of the index. If no distinct attribute\n    `None` is returned.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     distinct_attribute = await index.get_distinct_attribute()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_distinct_attribute(self) -&gt; str | None:\n    \"\"\"Get distinct attribute of the index.\n\n    Returns:\n\n        String containing the distinct attribute of the index. If no distinct attribute\n            `None` is returned.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     distinct_attribute = await index.get_distinct_attribute()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n    if not response.json():\n        None\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_document","title":"<code>get_document(document_id)</code>  <code>async</code>","text":"<p>Get one document with given document identifier.</p> <p>Args:</p> <pre><code>document_id: Unique identifier of the document.\n</code></pre> <p>Returns:</p> <pre><code>The document information\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     document = await index.get_document(\"1234\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_document(self, document_id: str) -&gt; JsonDict:\n    \"\"\"Get one document with given document identifier.\n\n    Args:\n\n        document_id: Unique identifier of the document.\n\n    Returns:\n\n        The document information\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     document = await index.get_document(\"1234\")\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._documents_url}/{document_id}\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_documents","title":"<code>get_documents(*, offset=0, limit=20, fields=None, filter=None)</code>  <code>async</code>","text":"<p>Get a batch documents from the index.</p> <p>Args:</p> <pre><code>offset: Number of documents to skip. Defaults to 0.\nlimit: Maximum number of documents returnedd. Defaults to 20.\nfields: Document attributes to show. If this value is None then all\n    attributes are retrieved. Defaults to None.\nfilter: Filter value information. Defaults to None. Note: This parameter can only be\n    used with Meilisearch &gt;= v1.2.0\n</code></pre> <p>Returns:</p> <pre><code>Documents info.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     documents = await index.get_documents()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_documents(\n    self,\n    *,\n    offset: int = 0,\n    limit: int = 20,\n    fields: list[str] | None = None,\n    filter: Filter | None = None,\n) -&gt; DocumentsInfo:\n    \"\"\"Get a batch documents from the index.\n\n    Args:\n\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returnedd. Defaults to 20.\n        fields: Document attributes to show. If this value is None then all\n            attributes are retrieved. Defaults to None.\n        filter: Filter value information. Defaults to None. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.2.0\n\n    Returns:\n\n        Documents info.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     documents = await index.get_documents()\n    \"\"\"\n    parameters: JsonDict = {\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    if not filter:\n        if fields:\n            parameters[\"fields\"] = \",\".join(fields)\n\n        url = _build_encoded_url(self._documents_url, parameters)\n        response = await self._http_requests.get(url)\n\n        return DocumentsInfo(**response.json())\n\n    if fields:\n        parameters[\"fields\"] = fields\n\n    parameters[\"filter\"] = filter\n\n    response = await self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n    return DocumentsInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_embedders","title":"<code>get_embedders()</code>  <code>async</code>","text":"<p>Get embedder settings for the index.</p> <p>Returns:</p> <pre><code>Embedders for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     embedders = await index.get_embedders()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_embedders(self) -&gt; Embedders | None:\n    \"\"\"Get embedder settings for the index.\n\n    Returns:\n\n        Embedders for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     embedders = await index.get_embedders()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n    return _embedder_json_to_embedders_model(response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_faceting","title":"<code>get_faceting()</code>  <code>async</code>","text":"<p>Get faceting for the index.</p> <p>Returns:</p> <pre><code>Faceting for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     faceting = await index.get_faceting()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_faceting(self) -&gt; Faceting:\n    \"\"\"Get faceting for the index.\n\n    Returns:\n\n        Faceting for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     faceting = await index.get_faceting()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n    return Faceting(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_filterable_attributes","title":"<code>get_filterable_attributes()</code>  <code>async</code>","text":"<p>Get filterable attributes of the index.</p> <p>Returns:</p> <pre><code>List containing the filterable attributes of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     filterable_attributes = await index.get_filterable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_filterable_attributes(self) -&gt; list[str] | None:\n    \"\"\"Get filterable attributes of the index.\n\n    Returns:\n\n        List containing the filterable attributes of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     filterable_attributes = await index.get_filterable_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n    if not response.json():\n        return None\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_non_separator_tokens","title":"<code>get_non_separator_tokens()</code>  <code>async</code>","text":"<p>Get non-separator token settings for the index.</p> <p>Returns:</p> <pre><code>Non-separator tokens for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     non_separator_token_settings = await index.get_non_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_non_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get non-separator token settings for the index.\n\n    Returns:\n\n        Non-separator tokens for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     non_separator_token_settings = await index.get_non_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_pagination","title":"<code>get_pagination()</code>  <code>async</code>","text":"<p>Get pagination settings for the index.</p> <p>Returns:</p> <pre><code>Pagination for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     pagination_settings = await index.get_pagination()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_pagination(self) -&gt; Pagination:\n    \"\"\"Get pagination settings for the index.\n\n    Returns:\n\n        Pagination for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     pagination_settings = await index.get_pagination()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n    return Pagination(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_primary_key","title":"<code>get_primary_key()</code>  <code>async</code>","text":"<p>Get the primary key.</p> <p>Returns:</p> <pre><code>The primary key for the documents in the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     primary_key = await index.get_primary_key()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_primary_key(self) -&gt; str | None:\n    \"\"\"Get the primary key.\n\n    Returns:\n\n        The primary key for the documents in the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     primary_key = await index.get_primary_key()\n    \"\"\"\n    info = await self.fetch_info()\n    return info.primary_key\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_proximity_precision","title":"<code>get_proximity_precision()</code>  <code>async</code>","text":"<p>Get proximity precision settings for the index.</p> <p>Returns:</p> <pre><code>Proximity precision for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     proximity_precision = await index.get_proximity_precision()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_proximity_precision(self) -&gt; ProximityPrecision:\n    \"\"\"Get proximity precision settings for the index.\n\n    Returns:\n\n        Proximity precision for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     proximity_precision = await index.get_proximity_precision()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n    return ProximityPrecision[to_snake(response.json()).upper()]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_ranking_rules","title":"<code>get_ranking_rules()</code>  <code>async</code>","text":"<p>Get ranking rules of the index.</p> <p>Returns:</p> <pre><code>List containing the ranking rules of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     ranking_rules = await index.get_ranking_rules()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_ranking_rules(self) -&gt; list[str]:\n    \"\"\"Get ranking rules of the index.\n\n    Returns:\n\n        List containing the ranking rules of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     ranking_rules = await index.get_ranking_rules()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_searchable_attributes","title":"<code>get_searchable_attributes()</code>  <code>async</code>","text":"<p>Get searchable attributes of the index.</p> <p>Returns:</p> <pre><code>List containing the searchable attributes of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     searchable_attributes = await index.get_searchable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_searchable_attributes(self) -&gt; list[str]:\n    \"\"\"Get searchable attributes of the index.\n\n    Returns:\n\n        List containing the searchable attributes of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     searchable_attributes = await index.get_searchable_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_separator_tokens","title":"<code>get_separator_tokens()</code>  <code>async</code>","text":"<p>Get separator token settings for the index.</p> <p>Returns:</p> <pre><code>Separator tokens for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     separator_token_settings = await index.get_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get separator token settings for the index.\n\n    Returns:\n\n        Separator tokens for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     separator_token_settings = await index.get_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_settings","title":"<code>get_settings()</code>  <code>async</code>","text":"<p>Get settings of the index.</p> <p>Returns:</p> <pre><code>Settings of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     settings = await index.get_settings()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_settings(self) -&gt; MeilisearchSettings:\n    \"\"\"Get settings of the index.\n\n    Returns:\n\n        Settings of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     settings = await index.get_settings()\n    \"\"\"\n    response = await self._http_requests.get(self._settings_url)\n    response_json = response.json()\n    settings = MeilisearchSettings(**response_json)\n\n    if response_json.get(\"embedders\"):\n        settings.embedders = _embedder_json_to_settings_model(response_json[\"embedders\"])\n\n    return settings\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_sortable_attributes","title":"<code>get_sortable_attributes()</code>  <code>async</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Returns:</p> <pre><code>List containing the sortable attributes of the AsyncIndex.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     sortable_attributes = await index.get_sortable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_sortable_attributes(self) -&gt; list[str]:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Returns:\n\n        List containing the sortable attributes of the AsyncIndex.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     sortable_attributes = await index.get_sortable_attributes()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_stats","title":"<code>get_stats()</code>  <code>async</code>","text":"<p>Get stats of the index.</p> <p>Returns:</p> <pre><code>Stats of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     stats = await index.get_stats()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_stats(self) -&gt; IndexStats:\n    \"\"\"Get stats of the index.\n\n    Returns:\n\n        Stats of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     stats = await index.get_stats()\n    \"\"\"\n    response = await self._http_requests.get(self._stats_url)\n\n    return IndexStats(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_stop_words","title":"<code>get_stop_words()</code>  <code>async</code>","text":"<p>Get stop words of the index.</p> <p>Returns:</p> <pre><code>List containing the stop words of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     stop_words = await index.get_stop_words()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_stop_words(self) -&gt; list[str] | None:\n    \"\"\"Get stop words of the index.\n\n    Returns:\n\n        List containing the stop words of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     stop_words = await index.get_stop_words()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n    if not response.json():\n        return None\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_synonyms","title":"<code>get_synonyms()</code>  <code>async</code>","text":"<p>Get synonyms of the index.</p> <p>Returns:</p> <pre><code>The synonyms of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     synonyms = await index.get_synonyms()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n    \"\"\"Get synonyms of the index.\n\n    Returns:\n\n        The synonyms of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     synonyms = await index.get_synonyms()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n    if not response.json():\n        return None\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_typo_tolerance","title":"<code>get_typo_tolerance()</code>  <code>async</code>","text":"<p>Get typo tolerance for the index.</p> <p>Returns:</p> <pre><code>TypoTolerance for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     sortable_attributes = await index.get_typo_tolerance()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_typo_tolerance(self) -&gt; TypoTolerance:\n    \"\"\"Get typo tolerance for the index.\n\n    Returns:\n\n        TypoTolerance for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     sortable_attributes = await index.get_typo_tolerance()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n    return TypoTolerance(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.get_word_dictionary","title":"<code>get_word_dictionary()</code>  <code>async</code>","text":"<p>Get word dictionary settings for the index.</p> <p>Returns:</p> <pre><code>Word dictionary for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     word_dictionary = await index.get_word_dictionary()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def get_word_dictionary(self) -&gt; list[str]:\n    \"\"\"Get word dictionary settings for the index.\n\n    Returns:\n\n        Word dictionary for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     word_dictionary = await index.get_word_dictionary()\n    \"\"\"\n    response = await self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n    return response.json()\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_displayed_attributes","title":"<code>reset_displayed_attributes()</code>  <code>async</code>","text":"<p>Reset displayed attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_displayed_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_displayed_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset displayed attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_displayed_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_distinct_attribute","title":"<code>reset_distinct_attribute()</code>  <code>async</code>","text":"<p>Reset distinct attribute of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_distinct_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_distinct_attribute(self) -&gt; TaskInfo:\n    \"\"\"Reset distinct attribute of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_distinct_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_embedders","title":"<code>reset_embedders()</code>  <code>async</code>","text":"<p>Reset an index's embedders settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_embedders()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_embedders(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's embedders settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_embedders()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_faceting","title":"<code>reset_faceting()</code>  <code>async</code>","text":"<p>Reset an index's faceting settings to their default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_faceting()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_faceting(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's faceting settings to their default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_faceting()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_filterable_attributes","title":"<code>reset_filterable_attributes()</code>  <code>async</code>","text":"<p>Reset filterable attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_filterable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_filterable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset filterable attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_filterable_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_non_separator_tokens","title":"<code>reset_non_separator_tokens()</code>  <code>async</code>","text":"<p>Reset an index's non-separator tokens settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_non_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_non_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_non_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_pagination","title":"<code>reset_pagination()</code>  <code>async</code>","text":"<p>Reset an index's pagination settings to their default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_pagination()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_pagination(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's pagination settings to their default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_pagination()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_proximity_precision","title":"<code>reset_proximity_precision()</code>  <code>async</code>","text":"<p>Reset an index's proximity precision settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_proximity_precision()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_proximity_precision(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's proximity precision settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_proximity_precision()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_ranking_rules","title":"<code>reset_ranking_rules()</code>  <code>async</code>","text":"<p>Reset ranking rules of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_ranking_rules()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_ranking_rules(self) -&gt; TaskInfo:\n    \"\"\"Reset ranking rules of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_ranking_rules()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_searchable_attributes","title":"<code>reset_searchable_attributes()</code>  <code>async</code>","text":"<p>Reset searchable attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_searchable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_searchable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset searchable attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_searchable_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_separator_tokens","title":"<code>reset_separator_tokens()</code>  <code>async</code>","text":"<p>Reset an index's separator tokens settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's separator tokens settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_separator_tokens()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_settings","title":"<code>reset_settings()</code>  <code>async</code>","text":"<p>Reset settings of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_settings()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_settings(self) -&gt; TaskInfo:\n    \"\"\"Reset settings of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_settings()\n    \"\"\"\n    response = await self._http_requests.delete(self._settings_url)\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_sortable_attributes","title":"<code>reset_sortable_attributes()</code>  <code>async</code>","text":"<p>Reset sortable attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_sortable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_sortable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset sortable attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_sortable_attributes()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_stop_words","title":"<code>reset_stop_words()</code>  <code>async</code>","text":"<p>Reset stop words of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_stop_words()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_stop_words(self) -&gt; TaskInfo:\n    \"\"\"Reset stop words of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_stop_words()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_synonyms","title":"<code>reset_synonyms()</code>  <code>async</code>","text":"<p>Reset synonyms of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_synonyms()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_synonyms(self) -&gt; TaskInfo:\n    \"\"\"Reset synonyms of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_synonyms()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_typo_tolerance","title":"<code>reset_typo_tolerance()</code>  <code>async</code>","text":"<p>Reset typo tolerance to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_typo_tolerance()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_typo_tolerance(self) -&gt; TaskInfo:\n    \"\"\"Reset typo tolerance to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_typo_tolerance()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.reset_word_dictionary","title":"<code>reset_word_dictionary()</code>  <code>async</code>","text":"<p>Reset an index's word dictionary settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.reset_word_dictionary()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def reset_word_dictionary(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's word dictionary settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.reset_word_dictionary()\n    \"\"\"\n    response = await self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.search","title":"<code>search(query=None, *, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=['*'], attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='all', hits_per_page=None, page=None, attributes_to_search_on=None, show_ranking_score=False, show_ranking_score_details=False, vector=None, hybrid=None)</code>  <code>async</code>","text":"<p>Search the index.</p> <p>Args:</p> <pre><code>query: String containing the word(s) to search\noffset: Number of documents to skip. Defaults to 0.\nlimit: Maximum number of documents returned. Defaults to 20.\nfilter: Filter queries by an attribute value. Defaults to None.\nfacets: Facets for which to retrieve the matching count. Defaults to None.\nattributes_to_retrieve: Attributes to display in the returned documents.\n    Defaults to [\"*\"].\nattributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\ncrop_length: The maximun number of words to display. Defaults to 200.\nattributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n    Defaults to None.\nsort: Attributes by which to sort the results. Defaults to None.\nshow_matches_position: Defines whether an object that contains information about the matches should be\n    returned or not. Defaults to False.\nhighlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\nhighlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\ncrop_marker: Marker to display when the number of words excedes the `crop_length`.\n    Defaults to ...\nmatching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\nhits_per_page: Sets the number of results returned per page.\npage: Sets the specific results page to fetch.\nattributes_to_search_on: List of field names. Allow search over a subset of searchable\n    attributes without modifying the index settings. Defaults to None.\nshow_ranking_score: If set to True the ranking score will be returned with each document\n    in the search. Defaults to False.\nshow_ranking_score_details: If set to True the ranking details will be returned with\n    each document in the search. Defaults to False. Note: This parameter can only be\n    used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n    to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n    sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n    Because this feature is experimental it may be removed or updated causing breaking\n    changes in this library without a major version bump so use with caution. This\n    feature became stable in Meiliseach v1.7.0.\nvector: List of vectors for vector search. Defaults to None. Note: This parameter can\n    only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n    In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n    feature by sending a PATCH request to /experimental-features with\n    { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n    updated causing breaking changes in this library without a major version bump so use\n    with caution.\nhybrid: Hybrid search information. Defaults to None. Note: This parameter can\n    only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n    In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n    feature by sending a PATCH request to /experimental-features with\n    { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n    updated causing breaking changes in this library without a major version bump so use\n    with caution.\n</code></pre> <p>Returns:</p> <pre><code>Results of the search\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     search_results = await index.search(\"Tron\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def search(\n    self,\n    query: str | None = None,\n    *,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] = [\"*\"],\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: str = \"all\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    vector: list[float] | None = None,\n    hybrid: Hybrid | None = None,\n) -&gt; SearchResults:\n    \"\"\"Search the index.\n\n    Args:\n\n        query: String containing the word(s) to search\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximun number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the matches should be\n            returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words excedes the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n            In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n\n    Returns:\n\n        Results of the search\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     search_results = await index.search(\"Tron\")\n    \"\"\"\n\n    body = _process_search_parameters(\n        q=query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        vector=vector,\n        hybrid=hybrid,\n    )\n    search_url = f\"{self._base_url_with_uid}/search\"\n\n    if self._pre_search_plugins:\n        await AsyncIndex._run_plugins(\n            self._pre_search_plugins,\n            AsyncEvent.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n        )\n\n    if self._concurrent_search_plugins:\n        if not use_task_groups():\n            concurrent_tasks: Any = []\n            for plugin in self._concurrent_search_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    concurrent_tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            vector=vector,\n                        )\n                    )\n\n            concurrent_tasks.append(self._http_requests.post(search_url, body=body))\n\n            responses = await asyncio.gather(*concurrent_tasks)\n            result = SearchResults(**responses[-1].json())\n            if self._post_search_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_search_plugins, AsyncEvent.POST, search_results=result\n                )\n                if post.get(\"search_result\"):\n                    result = post[\"search_result\"]\n\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_search_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            query=query,\n                            offset=offset,\n                            limit=limit,\n                            filter=filter,\n                            facets=facets,\n                            attributes_to_retrieve=attributes_to_retrieve,\n                            attributes_to_crop=attributes_to_crop,\n                            crop_length=crop_length,\n                            attributes_to_highlight=attributes_to_highlight,\n                            sort=sort,\n                            show_matches_position=show_matches_position,\n                            highlight_pre_tag=highlight_pre_tag,\n                            highlight_post_tag=highlight_post_tag,\n                            crop_marker=crop_marker,\n                            matching_strategy=matching_strategy,\n                            hits_per_page=hits_per_page,\n                            page=page,\n                            attributes_to_search_on=attributes_to_search_on,\n                            show_ranking_score=show_ranking_score,\n                            show_ranking_score_details=show_ranking_score_details,\n                            vector=vector,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(self._http_requests.post(search_url, body=body))\n\n        response = await response_coroutine\n        result = SearchResults(**response.json())\n        if self._post_search_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_search_plugins, AsyncEvent.POST, search_results=result\n            )\n            if post.get(\"search_result\"):\n                result = post[\"search_result\"]\n\n        return result\n\n    response = await self._http_requests.post(search_url, body=body)\n    result = SearchResults(**response.json())\n\n    if self._post_search_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_search_plugins, AsyncEvent.POST, search_results=result\n        )\n        if post.get(\"search_result\"):\n            result = post[\"search_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update","title":"<code>update(primary_key)</code>  <code>async</code>","text":"<p>Update the index primary key.</p> <p>Args:</p> <pre><code>primary_key: The primary key of the documents.\n</code></pre> <p>Returns:</p> <pre><code>An instance of the AsyncIndex with the updated information.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     updated_index = await index.update()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update(self, primary_key: str) -&gt; AsyncIndex:\n    \"\"\"Update the index primary key.\n\n    Args:\n\n        primary_key: The primary key of the documents.\n\n    Returns:\n\n        An instance of the AsyncIndex with the updated information.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     updated_index = await index.update()\n    \"\"\"\n    payload = {\"primaryKey\": primary_key}\n    response = await self._http_requests.patch(self._base_url_with_uid, payload)\n    await async_wait_for_task(\n        self.http_client, response.json()[\"taskUid\"], timeout_in_ms=100000\n    )\n    index_response = await self._http_requests.get(f\"{self._base_url_with_uid}\")\n    self.primary_key = index_response.json()[\"primaryKey\"]\n    return self\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_displayed_attributes","title":"<code>update_displayed_attributes(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update displayed attributes of the index.</p> <p>Args:</p> <pre><code>body: List containing the displayed attributes.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_displayed_attributes(\n&gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n&gt;&gt;&gt;     )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_displayed_attributes(\n    self, body: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update displayed attributes of the index.\n\n    Args:\n\n        body: List containing the displayed attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_displayed_attributes(\n        &gt;&gt;&gt;         [\"title\", \"description\", \"genre\", \"release_date\"]\n        &gt;&gt;&gt;     )\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_distinct_attribute","title":"<code>update_distinct_attribute(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update distinct attribute of the index.</p> <p>Args:</p> <pre><code>body: Distinct attribute.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_distinct_attribute(\"url\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update distinct attribute of the index.\n\n    Args:\n\n        body: Distinct attribute.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_distinct_attribute(\"url\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents","title":"<code>update_documents(documents, primary_key=None, *, compress=False)</code>  <code>async</code>","text":"<p>Update documents in the index.</p> <p>Args:</p> <pre><code>documents: List of documents.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Update documents in the index.\n\n    Args:\n\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents(documents)\n    \"\"\"\n    if primary_key:\n        url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n    else:\n        url = self._documents_url\n\n    if self._pre_update_documents_plugins:\n        pre = await AsyncIndex._run_plugins(\n            self._pre_update_documents_plugins,\n            AsyncEvent.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    if self._concurrent_update_documents_plugins:\n        if not use_task_groups():\n            tasks: Any = []\n            for plugin in self._concurrent_update_documents_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tasks.append(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if _plugin_has_method(plugin, \"run_document_plugin\"):\n                    tasks.append(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            tasks.append(self._http_requests.put(url, documents, compress=compress))\n\n            responses = await asyncio.gather(*tasks)\n            result = TaskInfo(**responses[-1].json())\n            if self._post_update_documents_plugins:\n                post = await AsyncIndex._run_plugins(\n                    self._post_update_documents_plugins,\n                    AsyncEvent.POST,\n                    result=result,\n                    documents=documents,\n                    primary_key=primary_key,\n                )\n                if isinstance(post[\"generic_result\"], TaskInfo):\n                    result = post[\"generic_result\"]\n\n            return result\n\n        async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n            for plugin in self._concurrent_update_documents_plugins:\n                if _plugin_has_method(plugin, \"run_plugin\"):\n                    tg.create_task(\n                        plugin.run_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n                if _plugin_has_method(plugin, \"run_document_plugin\"):\n                    tg.create_task(\n                        plugin.run_document_plugin(  # type: ignore[union-attr]\n                            event=AsyncEvent.CONCURRENT,\n                            documents=documents,\n                            primary_key=primary_key,\n                        )\n                    )\n\n            response_coroutine = tg.create_task(\n                self._http_requests.put(url, documents, compress=compress)\n            )\n\n        response = await response_coroutine\n        result = TaskInfo(**response.json())\n        if self._post_update_documents_plugins:\n            post = await AsyncIndex._run_plugins(\n                self._post_update_documents_plugins,\n                AsyncEvent.POST,\n                result=result,\n                documents=documents,\n                primary_key=primary_key,\n            )\n\n            if isinstance(post[\"generic_result\"], TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    response = await self._http_requests.put(url, documents, compress=compress)\n    result = TaskInfo(**response.json())\n    if self._post_update_documents_plugins:\n        post = await AsyncIndex._run_plugins(\n            self._post_update_documents_plugins,\n            AsyncEvent.POST,\n            result=result,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if isinstance(post[\"generic_result\"], TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_directory","title":"<code>update_documents_from_directory(directory_path, *, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>  <code>async</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents_from_directory(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n        response = await self.update_documents(combined, primary_key, compress=compress)\n        return [response]\n\n    if not use_task_groups():\n        update_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                update_documents.append(\n                    self.update_documents(documents, primary_key, compress=compress)\n                )\n\n        _raise_on_no_documents(update_documents, document_type, directory_path)\n\n        if len(update_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = [await update_documents.pop()]\n            responses = await asyncio.gather(*update_documents)\n            responses = [*first_response, *responses]\n        else:\n            responses = [await update_documents[0]]\n\n        return responses\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = []\n        results = []\n        for i, path in enumerate(directory.iterdir()):\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                if i == 0:\n                    results = [\n                        await self.update_documents(documents, primary_key, compress=compress)\n                    ]\n                else:\n                    tasks.append(\n                        tg.create_task(\n                            self.update_documents(documents, primary_key, compress=compress)\n                        )\n                    )\n\n    results = [*results, *[x.result() for x in tasks]]\n    _raise_on_no_documents(results, document_type, directory_path)\n    return results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_directory_in_batches","title":"<code>update_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>  <code>async</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents_from_directory_in_batches(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        loop = asyncio.get_running_loop()\n        combined = await loop.run_in_executor(None, partial(_combine_documents, all_documents))\n\n        return await self.update_documents_in_batches(\n            combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    if not use_task_groups():\n        responses: list[TaskInfo] = []\n\n        update_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                update_documents.append(\n                    self.update_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        compress=compress,\n                    )\n                )\n\n        _raise_on_no_documents(update_documents, document_type, directory_path)\n\n        if len(update_documents) &gt; 1:\n            # Send the first document on its own before starting the gather. Otherwise Meilisearch\n            # returns an error because it thinks all entries are trying to create the same index.\n            first_response = await update_documents.pop()\n            responses_gather = await asyncio.gather(*update_documents)\n            responses = [*first_response, *[x for y in responses_gather for x in y]]\n        else:\n            responses = await update_documents[0]\n\n        return responses\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        results = []\n        tasks = []\n        for i, path in enumerate(directory.iterdir()):\n            if path.suffix == f\".{document_type}\":\n                documents = await _async_load_documents_from_file(path, csv_delimiter)\n                if i == 0:\n                    results = await self.update_documents_in_batches(\n                        documents,\n                        batch_size=batch_size,\n                        primary_key=primary_key,\n                        compress=compress,\n                    )\n                else:\n                    tasks.append(\n                        tg.create_task(\n                            self.update_documents_in_batches(\n                                documents,\n                                batch_size=batch_size,\n                                primary_key=primary_key,\n                                compress=compress,\n                            )\n                        )\n                    )\n\n    results = [*results, *[x for y in tasks for x in y.result()]]\n    _raise_on_no_documents(results, document_type, directory_path)\n    return results\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_file","title":"<code>update_documents_from_file(file_path, primary_key=None, csv_delimiter=None, *, compress=False)</code>  <code>async</code>","text":"<p>Add documents in the index from a json file.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents_from_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents_from_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents in the index from a json file.\n\n    Args:\n\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_file(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(file_path, csv_delimiter)\n\n    return await self.update_documents(documents, primary_key=primary_key, compress=compress)\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_file_in_batches","title":"<code>update_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, compress=False)</code>  <code>async</code>","text":"<p>Updates documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents_from_file_in_batches(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = await _async_load_documents_from_file(file_path)\n\n    return await self.update_documents_in_batches(\n        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n    )\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_from_raw_file","title":"<code>update_documents_from_raw_file(file_path, primary_key=None, csv_delimiter=None, *, compress=False)</code>  <code>async</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Args:</p> <pre><code>file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n    allowed.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n    a non-csv file.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents_from_raw_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n    if not upload_path.exists():\n        raise MeilisearchError(\"No file found at the specified path\")\n\n    if upload_path.suffix not in (\".csv\", \".ndjson\"):\n        raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n    if csv_delimiter and upload_path.suffix != \".csv\":\n        raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n    if (\n        csv_delimiter\n        and len(csv_delimiter) != 1\n        or csv_delimiter\n        and not csv_delimiter.isascii()\n    ):\n        raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n    content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n\n    if parameters:\n        url = _build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    async with aiofiles.open(upload_path, \"r\") as f:\n        data = await f.read()\n\n    response = await self._http_requests.put(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_documents_in_batches","title":"<code>update_documents_in_batches(documents, *, batch_size=1000, primary_key=None, compress=False)</code>  <code>async</code>","text":"<p>Update documents in batches to reduce RAM usage with indexing.</p> <p>Each batch tries to fill the max_payload_size</p> <p>Args:</p> <pre><code>documents: List of documents.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_documents_in_batches(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n    Each batch tries to fill the max_payload_size\n\n    Args:\n\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_documents_in_batches(documents)\n    \"\"\"\n    if not use_task_groups():\n        batches = [\n            self.update_documents(x, primary_key, compress=compress)\n            for x in _batch(documents, batch_size)\n        ]\n        return await asyncio.gather(*batches)\n\n    async with asyncio.TaskGroup() as tg:  # type: ignore[attr-defined]\n        tasks = [\n            tg.create_task(self.update_documents(x, primary_key, compress=compress))\n            for x in _batch(documents, batch_size)\n        ]\n    return [x.result() for x in tasks]\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_embedders","title":"<code>update_embedders(embedders, *, compress=False)</code>  <code>async</code>","text":"<p>Update the embedders settings for an index.</p> <p>Args:</p> <pre><code>embedders: The embedders value.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_embedders(\n&gt;&gt;&gt;         Embedders(embedders={\"default\": UserProvidedEmbedder(dimensions=512)})\n&gt;&gt;&gt;     )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the embedders settings for an index.\n\n    Args:\n\n        embedders: The embedders value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_embedders(\n        &gt;&gt;&gt;         Embedders(embedders={\"default\": UserProvidedEmbedder(dimensions=512)})\n        &gt;&gt;&gt;     )\n    \"\"\"\n    payload = {}\n    for key, embedder in embedders.embedders.items():\n        if is_pydantic_2():\n            payload[key] = {\n                k: v for k, v in embedder.model_dump(by_alias=True).items() if v is not None\n            }  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            payload[key] = {\n                k: v for k, v in embedder.dict(by_alias=True).items() if v is not None\n            }  # type: ignore[attr-defined]\n\n    response = await self._http_requests.patch(\n        f\"{self._settings_url}/embedders\", payload, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_faceting","title":"<code>update_faceting(faceting, *, compress=False)</code>  <code>async</code>","text":"<p>Partially update the faceting settings for an index.</p> <p>Args:</p> <pre><code>faceting: Faceting values.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the faceting settings for an index.\n\n    Args:\n\n        faceting: Faceting values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n    \"\"\"\n    if is_pydantic_2():\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/faceting\",\n            faceting.model_dump(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/faceting\", faceting.dict(by_alias=True), compress=compress\n        )  # type: ignore[attr-defined]\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_filterable_attributes","title":"<code>update_filterable_attributes(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update filterable attributes of the index.</p> <p>Args:</p> <pre><code>body: List containing the filterable attributes of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_filterable_attributes([\"genre\", \"director\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_filterable_attributes(\n    self, body: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update filterable attributes of the index.\n\n    Args:\n\n        body: List containing the filterable attributes of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_filterable_attributes([\"genre\", \"director\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/filterable-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_non_separator_tokens","title":"<code>update_non_separator_tokens(non_separator_tokens, *, compress=False)</code>  <code>async</code>","text":"<p>Update the non-separator tokens settings for an index.</p> <p>Args:</p> <pre><code>non_separator_tokens: List of non-separator tokens.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_non_separator_tokens(\n    self, non_separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the non-separator tokens settings for an index.\n\n    Args:\n\n        non_separator_tokens: List of non-separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_pagination","title":"<code>update_pagination(settings, *, compress=False)</code>  <code>async</code>","text":"<p>Partially update the pagination settings for an index.</p> <p>Args:</p> <pre><code>settings: settings for pagination.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_pagination(settings=Pagination(max_total_hits=123))\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the pagination settings for an index.\n\n    Args:\n\n        settings: settings for pagination.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_pagination(settings=Pagination(max_total_hits=123))\n    \"\"\"\n    if is_pydantic_2():\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/pagination\",\n            settings.model_dump(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/pagination\", settings.dict(by_alias=True), compress=compress\n        )  # type: ignore[attr-defined]\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_proximity_precision","title":"<code>update_proximity_precision(proximity_precision, *, compress=False)</code>  <code>async</code>","text":"<p>Update the proximity precision settings for an index.</p> <p>Args:</p> <pre><code>proximity_precision: The proximity precision value.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_proximity_precision(\n    self, proximity_precision: ProximityPrecision, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the proximity precision settings for an index.\n\n    Args:\n\n        proximity_precision: The proximity precision value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/proximity-precision\",\n        proximity_precision.value,\n        compress=compress,\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_ranking_rules","title":"<code>update_ranking_rules(ranking_rules, *, compress=False)</code>  <code>async</code>","text":"<p>Update ranking rules of the index.</p> <p>Args:</p> <pre><code>ranking_rules: List containing the ranking rules.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; ranking_rules=[\n&gt;&gt;&gt;      \"words\",\n&gt;&gt;&gt;      \"typo\",\n&gt;&gt;&gt;      \"proximity\",\n&gt;&gt;&gt;      \"attribute\",\n&gt;&gt;&gt;      \"sort\",\n&gt;&gt;&gt;      \"exactness\",\n&gt;&gt;&gt;      \"release_date:desc\",\n&gt;&gt;&gt;      \"rank:desc\",\n&gt;&gt;&gt; ],\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_ranking_rules(ranking_rules)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_ranking_rules(\n    self, ranking_rules: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update ranking rules of the index.\n\n    Args:\n\n        ranking_rules: List containing the ranking rules.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; ranking_rules=[\n        &gt;&gt;&gt;      \"words\",\n        &gt;&gt;&gt;      \"typo\",\n        &gt;&gt;&gt;      \"proximity\",\n        &gt;&gt;&gt;      \"attribute\",\n        &gt;&gt;&gt;      \"sort\",\n        &gt;&gt;&gt;      \"exactness\",\n        &gt;&gt;&gt;      \"release_date:desc\",\n        &gt;&gt;&gt;      \"rank:desc\",\n        &gt;&gt;&gt; ],\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_ranking_rules(ranking_rules)\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_searchable_attributes","title":"<code>update_searchable_attributes(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update searchable attributes of the index.</p> <p>Args:</p> <pre><code>body: List containing the searchable attributes.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_searchable_attributes(\n    self, body: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update searchable attributes of the index.\n\n    Args:\n\n        body: List containing the searchable attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_separator_tokens","title":"<code>update_separator_tokens(separator_tokens, *, compress=False)</code>  <code>async</code>","text":"<p>Update the separator tokens settings for an index.</p> <p>Args:</p> <pre><code>separator_tokens: List of separator tokens.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_separator_tokens(\n    self, separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the separator tokens settings for an index.\n\n    Args:\n\n        separator_tokens: List of separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_settings","title":"<code>update_settings(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update settings of the index.</p> <p>Args:</p> <pre><code>body: Settings of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n&gt;&gt;&gt; new_settings = MeilisearchSettings(\n&gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n&gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n&gt;&gt;&gt;     ranking_rules=[\n&gt;&gt;&gt;         \"words\",\n&gt;&gt;&gt;         \"typo\",\n&gt;&gt;&gt;         \"proximity\",\n&gt;&gt;&gt;         \"attribute\",\n&gt;&gt;&gt;         \"sort\",\n&gt;&gt;&gt;         \"exactness\",\n&gt;&gt;&gt;         \"release_date:desc\",\n&gt;&gt;&gt;         \"rank:desc\",\n&gt;&gt;&gt;    ],\n&gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n&gt;&gt;&gt;    distinct_attribute=\"url\",\n&gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n&gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n&gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n&gt;&gt;&gt; )\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_settings(new_settings)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_settings(\n    self, body: MeilisearchSettings, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update settings of the index.\n\n    Args:\n\n        body: Settings of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n        &gt;&gt;&gt; new_settings = MeilisearchSettings(\n        &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n        &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n        &gt;&gt;&gt;     ranking_rules=[\n        &gt;&gt;&gt;         \"words\",\n        &gt;&gt;&gt;         \"typo\",\n        &gt;&gt;&gt;         \"proximity\",\n        &gt;&gt;&gt;         \"attribute\",\n        &gt;&gt;&gt;         \"sort\",\n        &gt;&gt;&gt;         \"exactness\",\n        &gt;&gt;&gt;         \"release_date:desc\",\n        &gt;&gt;&gt;         \"rank:desc\",\n        &gt;&gt;&gt;    ],\n        &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n        &gt;&gt;&gt;    distinct_attribute=\"url\",\n        &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n        &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n        &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_settings(new_settings)\n    \"\"\"\n    if is_pydantic_2():\n        body_dict = {k: v for k, v in body.model_dump(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        body_dict = {k: v for k, v in body.dict(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n\n    response = await self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_sortable_attributes","title":"<code>update_sortable_attributes(sortable_attributes, *, compress=False)</code>  <code>async</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Args:</p> <pre><code>sortable_attributes: List of attributes for searching.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_sortable_attributes([\"title\", \"release_date\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_sortable_attributes(\n    self, sortable_attributes: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Args:\n\n        sortable_attributes: List of attributes for searching.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_sortable_attributes([\"title\", \"release_date\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_stop_words","title":"<code>update_stop_words(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update stop words of the index.</p> <p>Args:</p> <pre><code>body: List containing the stop words of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_stop_words([\"the\", \"a\", \"an\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update stop words of the index.\n\n    Args:\n\n        body: List containing the stop words of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_stop_words([\"the\", \"a\", \"an\"])\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/stop-words\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_synonyms","title":"<code>update_synonyms(body, *, compress=False)</code>  <code>async</code>","text":"<p>Update synonyms of the index.</p> <p>Args:</p> <pre><code>body: The synonyms of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_synonyms(\n&gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n&gt;&gt;&gt;     )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_synonyms(\n    self, body: dict[str, list[str]], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update synonyms of the index.\n\n    Args:\n\n        body: The synonyms of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_synonyms(\n        &gt;&gt;&gt;         {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n        &gt;&gt;&gt;     )\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/synonyms\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_typo_tolerance","title":"<code>update_typo_tolerance(typo_tolerance, *, compress=False)</code>  <code>async</code>","text":"<p>Update typo tolerance.</p> <p>Args:</p> <pre><code>typo_tolerance: Typo tolerance settings.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     TypoTolerance(enabled=False)\n&gt;&gt;&gt;     await index.update_typo_tolerance()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_typo_tolerance(\n    self, typo_tolerance: TypoTolerance, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update typo tolerance.\n\n    Args:\n\n        typo_tolerance: Typo tolerance settings.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     TypoTolerance(enabled=False)\n        &gt;&gt;&gt;     await index.update_typo_tolerance()\n    \"\"\"\n    if is_pydantic_2():\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/typo-tolerance\",\n            typo_tolerance.model_dump(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = await self._http_requests.patch(\n            f\"{self._settings_url}/typo-tolerance\",\n            typo_tolerance.dict(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"async_index_api/#meilisearch_python_sdk.index.AsyncIndex.update_word_dictionary","title":"<code>update_word_dictionary(dictionary, *, compress=False)</code>  <code>async</code>","text":"<p>Update the word dictionary settings for an index.</p> <p>Args:</p> <pre><code>dictionary: List of dictionary values.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt;     index = client.index(\"movies\")\n&gt;&gt;&gt;     await index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>async def update_word_dictionary(\n    self, dictionary: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the word dictionary settings for an index.\n\n    Args:\n\n        dictionary: List of dictionary values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; async with AsyncClient(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt;     index = client.index(\"movies\")\n        &gt;&gt;&gt;     await index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n    \"\"\"\n    response = await self._http_requests.put(\n        f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"client_api/","title":"Client","text":""},{"location":"client_api/#client-usage","title":"<code>client</code> Usage","text":""},{"location":"client_api/#create-a-client","title":"Create a client","text":"<p>To create a client:</p> <pre><code>from milisearch_python_sdk import Client\n\n\nclient = Client(\"http://localhost:7700\", \"masterKey\")\nindex = client.index(\"movies\")\n...\n</code></pre>"},{"location":"client_api/#client-api","title":"<code>Client</code> API","text":"<p>             Bases: <code>BaseClient</code></p> <p>client to connect to the Meilisearch API.</p> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>class Client(BaseClient):\n    \"\"\"client to connect to the Meilisearch API.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        api_key: str | None = None,\n        *,\n        timeout: int | None = None,\n        verify: str | bool | SSLContext = True,\n    ) -&gt; None:\n        \"\"\"Class initializer.\n\n        Args:\n\n            url: The url to the Meilisearch API (ex: http://localhost:7700)\n            api_key: The optional API key for Meilisearch. Defaults to None.\n            timeout: The amount of time in seconds that the client will wait for a response before\n                timing out. Defaults to None.\n            verify: SSL certificates (a.k.a CA bundle) used to\n                verify the identity of requested hosts. Either `True` (default CA bundle),\n                a path to an SSL certificate file, or `False` (disable verification)\n        \"\"\"\n        super().__init__(api_key)\n\n        self.http_client = HttpxClient(\n            base_url=url, timeout=timeout, headers=self._headers, verify=verify\n        )\n        self._http_requests = HttpRequests(self.http_client)\n\n    def create_dump(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch dump.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.create_dump()\n        \"\"\"\n        response = self._http_requests.post(\"dumps\")\n\n        return TaskInfo(**response.json())\n\n    def create_index(\n        self,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        plugins: IndexPlugins | None = None,\n    ) -&gt; Index:\n        \"\"\"Creates a new index.\n\n        Args:\n\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An instance of Index containing the information of the newly created index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.create_index(\"movies\")\n        \"\"\"\n        return Index.create(\n            self.http_client, uid, primary_key, settings=settings, wait=wait, plugins=plugins\n        )\n\n    def create_snapshot(self) -&gt; TaskInfo:\n        \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.create_snapshot()\n        \"\"\"\n        response = self._http_requests.post(\"snapshots\")\n\n        return TaskInfo(**response.json())\n\n    def delete_index_if_exists(self, uid: str) -&gt; bool:\n        \"\"\"Deletes an index if it already exists.\n\n        Args:\n\n            uid: The index's unique identifier.\n\n        Returns:\n\n            True if an index was deleted for False if not.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.delete_index_if_exists()\n        \"\"\"\n        response = self._http_requests.delete(f\"indexes/{uid}\")\n        status = self.wait_for_task(response.json()[\"taskUid\"], timeout_in_ms=100000)\n        if status.status == \"succeeded\":\n            return True\n        return False\n\n    def get_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[Index] | None:\n        \"\"\"Get all indexes.\n        Args:\n\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n\n            A list of all indexes.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt; indexes = client.get_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = self._http_requests.get(url)\n\n        if not response.json()[\"results\"]:\n            return None\n\n        return [\n            Index(\n                http_client=self.http_client,\n                uid=x[\"uid\"],\n                primary_key=x[\"primaryKey\"],\n                created_at=x[\"createdAt\"],\n                updated_at=x[\"updatedAt\"],\n            )\n            for x in response.json()[\"results\"]\n        ]\n\n    def get_index(self, uid: str) -&gt; Index:\n        \"\"\"Gets a single index based on the uid of the index.\n\n        Args:\n\n            uid: The index's unique identifier.\n\n        Returns:\n\n            An Index instance containing the information of the fetched index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.get_index()\n        \"\"\"\n        return Index(self.http_client, uid).fetch_info()\n\n    def index(self, uid: str, *, plugins: IndexPlugins | None = None) -&gt; Index:\n        \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n        Args:\n\n            uid: The index's unique identifier.\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An Index instance.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n        \"\"\"\n        return Index(self.http_client, uid=uid, plugins=plugins)\n\n    def get_all_stats(self) -&gt; ClientStats:\n        \"\"\"Get stats for all indexes.\n\n        Returns:\n\n            Information about database size and all indexes.\n            https://docs.meilisearch.com/reference/api/stats.html\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; stats = client.get_all_stats()\n        \"\"\"\n        response = self._http_requests.get(\"stats\")\n\n        return ClientStats(**response.json())\n\n    def get_or_create_index(\n        self, uid: str, primary_key: str | None = None, *, plugins: IndexPlugins | None = None\n    ) -&gt; Index:\n        \"\"\"Get an index, or create it if it doesn't exist.\n\n        Args:\n\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An instance of Index containing the information of the retrieved or newly created index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.get_or_create_index(\"movies\")\n        \"\"\"\n        try:\n            index_instance = self.get_index(uid)\n        except MeilisearchApiError as err:\n            if \"index_not_found\" not in err.code:\n                raise\n            index_instance = self.create_index(uid, primary_key, plugins=plugins)\n        return index_instance\n\n    def create_key(self, key: KeyCreate) -&gt; Key:\n        \"\"\"Creates a new API key.\n\n        Args:\n\n            key: The information to use in creating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n\n            The new API key.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; key_info = KeyCreate(\n            &gt;&gt;&gt;     description=\"My new key\",\n            &gt;&gt;&gt;     actions=[\"search\"],\n            &gt;&gt;&gt;     indexes=[\"movies\"],\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; keys = client.create_key(key_info)\n        \"\"\"\n        if is_pydantic_2():\n            response = self._http_requests.post(\n                \"keys\", json.loads(key.model_dump_json(by_alias=True))\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = self._http_requests.post(\"keys\", json.loads(key.json(by_alias=True)))  # type: ignore[attr-defined]\n\n        return Key(**response.json())\n\n    def delete_key(self, key: str) -&gt; int:\n        \"\"\"Deletes an API key.\n\n        Args:\n\n            key: The key or uid to delete.\n\n        Returns:\n\n            The Response status code. 204 signifies a successful delete.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.delete_key(\"abc123\")\n        \"\"\"\n        response = self._http_requests.delete(f\"keys/{key}\")\n        return response.status_code\n\n    def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n        \"\"\"Gets the Meilisearch API keys.\n        Args:\n\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns:\n\n            API keys.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; keys = client.get_keys()\n        \"\"\"\n        url = _build_offset_limit_url(\"keys\", offset, limit)\n        response = self._http_requests.get(url)\n\n        return KeySearch(**response.json())\n\n    def get_key(self, key: str) -&gt; Key:\n        \"\"\"Gets information about a specific API key.\n\n        Args:\n\n            key: The key for which to retrieve the information.\n\n        Returns:\n\n            The API key, or `None` if the key is not found.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; keys = client.get_key(\"abc123\")\n        \"\"\"\n        response = self._http_requests.get(f\"keys/{key}\")\n\n        return Key(**response.json())\n\n    def update_key(self, key: KeyUpdate) -&gt; Key:\n        \"\"\"Update an API key.\n\n        Args:\n\n            key: The information to use in updating the key. Note that if an expires_at value\n                is included it should be in UTC time.\n\n        Returns:\n\n            The updated API key.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; key_info = KeyUpdate(\n                    key=\"abc123\",\n            &gt;&gt;&gt;     indexes=[\"*\"],\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; keys = client.update_key(key_info)\n        \"\"\"\n        payload = _build_update_key_payload(key)\n        response = self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n        return Key(**response.json())\n\n    def multi_search(self, queries: list[SearchParams]) -&gt; list[SearchResultsWithUID]:\n        \"\"\"Multi-index search.\n\n        Args:\n\n            queries: List of SearchParameters\n\n        Returns:\n\n            Results of the search\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; queries = [\n            &gt;&gt;&gt;     SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n            &gt;&gt;&gt;     SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; search_results = client.search(queries)\n        \"\"\"\n        url = \"multi-search\"\n        if is_pydantic_2():\n            response = self._http_requests.post(\n                url,\n                body={\"queries\": [x.model_dump(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n            )\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = self._http_requests.post(\n                url,\n                body={\"queries\": [x.dict(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n            )\n\n        return [SearchResultsWithUID(**x) for x in response.json()[\"results\"]]\n\n    def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n        \"\"\"Gets the index and returns all the index information rather than an Index instance.\n\n        Args:\n\n            uid: The index's unique identifier.\n\n        Returns:\n\n            Index information rather than an Index instance.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.get_raw_index(\"movies\")\n        \"\"\"\n        response = self.http_client.get(f\"indexes/{uid}\")\n\n        if response.status_code == 404:\n            return None\n\n        return IndexInfo(**response.json())\n\n    def get_raw_indexes(\n        self, *, offset: int | None = None, limit: int | None = None\n    ) -&gt; list[IndexInfo] | None:\n        \"\"\"Gets all the indexes.\n        Args:\n\n            offset: Number of indexes to skip. The default of None will use the Meilisearch\n                default.\n            limit: Number of indexes to return. The default of None will use the Meilisearch\n                default.\n\n        Returns all the index information rather than an AsyncIndex instance.\n\n        Returns:\n\n            A list of the Index information rather than an AsyncIndex instances.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.get_raw_indexes()\n        \"\"\"\n        url = _build_offset_limit_url(\"indexes\", offset, limit)\n        response = self._http_requests.get(url)\n\n        if not response.json()[\"results\"]:\n            return None\n\n        return [IndexInfo(**x) for x in response.json()[\"results\"]]\n\n    def get_version(self) -&gt; Version:\n        \"\"\"Get the Meilisearch version.\n\n        Returns:\n\n            Information about the version of Meilisearch.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; version = client.get_version()\n        \"\"\"\n        response = self._http_requests.get(\"version\")\n\n        return Version(**response.json())\n\n    def health(self) -&gt; Health:\n        \"\"\"Get health of the Meilisearch server.\n\n        Returns:\n\n            The status of the Meilisearch server.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; health = client.get_health()\n        \"\"\"\n        response = self._http_requests.get(\"health\")\n\n        return Health(**response.json())\n\n    def swap_indexes(self, indexes: list[tuple[str, str]]) -&gt; TaskInfo:\n        \"\"\"Swap two indexes.\n\n        Args:\n\n            indexes: A list of tuples, each tuple should contain the indexes to swap.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.swap_indexes([(\"index_a\", \"index_b\")])\n        \"\"\"\n        processed_indexes = [{\"indexes\": x} for x in indexes]\n        response = self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n        return TaskInfo(**response.json())\n\n    def cancel_tasks(\n        self,\n        *,\n        uids: list[str] | None = None,\n        index_uids: list[str] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Cancel a list of enqueued or processing tasks.\n\n        Defaults to cancelling all tasks.\n\n        Args:\n\n            uids: A list of task UIDs to cancel.\n            index_uids: A list of index UIDs for which to cancel tasks.\n            statuses: A list of statuses to cancel.\n            types: A list of types to cancel.\n            before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n            after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n            before_started_at: Cancel tasks that were started before the specified date time.\n            after_finished_at: Cancel tasks that were finished after the specified date time.\n\n        Returns:\n\n            The details of the task\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.task import cancel_tasks\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.cancel_tasks(uids=[1, 2])\n        \"\"\"\n        return _task.cancel_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    def delete_tasks(\n        self,\n        *,\n        uids: list[str] | None = None,\n        index_uids: list[str] | None = None,\n        statuses: list[str] | None = None,\n        types: list[str] | None = None,\n        before_enqueued_at: datetime | None = None,\n        after_enqueued_at: datetime | None = None,\n        before_started_at: datetime | None = None,\n        after_finished_at: datetime | None = None,\n    ) -&gt; TaskInfo:\n        \"\"\"Delete a list of tasks.\n\n        Defaults to deleting all tasks.\n\n        Args:\n\n            uids: A list of task UIDs to cancel.\n            index_uids: A list of index UIDs for which to cancel tasks.\n            statuses: A list of statuses to cancel.\n            types: A list of types to cancel.\n            before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n            after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n            before_started_at: Cancel tasks that were started before the specified date time.\n            after_finished_at: Cancel tasks that were finished after the specified date time.\n\n        Returns:\n\n            The details of the task\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.delete_tasks(client, uids=[1, 2])\n        \"\"\"\n        return _task.delete_tasks(\n            self.http_client,\n            uids=uids,\n            index_uids=index_uids,\n            statuses=statuses,\n            types=types,\n            before_enqueued_at=before_enqueued_at,\n            after_enqueued_at=after_enqueued_at,\n            before_started_at=before_started_at,\n            after_finished_at=after_finished_at,\n        )\n\n    def get_task(self, task_id: int) -&gt; TaskResult:\n        \"\"\"Get a single task from it's task id.\n\n        Args:\n\n            task_id: Identifier of the task to retrieve.\n\n        Returns:\n\n            Results of a task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; get_task(client, 1244)\n        \"\"\"\n        return _task.get_task(self.http_client, task_id=task_id)\n\n    def get_tasks(\n        self,\n        *,\n        index_ids: list[str] | None = None,\n        types: str | list[str] | None = None,\n    ) -&gt; TaskStatus:\n        \"\"\"Get multiple tasks.\n\n        Args:\n\n            index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n                tasks only for the specified indexes, if not all tasks will be returned. Default = None\n            types: Specify specific task types to retrieve. Default = None\n\n        Returns:\n\n            Task statuses.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; client.get_tasks(client)\n        \"\"\"\n        return _task.get_tasks(self.http_client, index_ids=index_ids, types=types)\n\n    def wait_for_task(\n        self,\n        task_id: int,\n        *,\n        timeout_in_ms: int | None = 5000,\n        interval_in_ms: int = 50,\n        raise_for_status: bool = False,\n    ) -&gt; TaskResult:\n        \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n        Args:\n\n            client: An httpx HttpxClient or meilisearch_python_sdk Client instance.\n            task_id: Identifier of the task to retrieve.\n            timeout_in_ms: Amount of time in milliseconds to wait before raising a\n                MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n                if the `None` option is used the wait time could be very long. Defaults to 5000.\n            interval_in_ms: Time interval in miliseconds to sleep between requests. Defaults to 50.\n            raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n                has a failed status. Defaults to False.\n\n        Returns:\n\n            Details of the processed update status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n            MeilisearchTimeoutError: If the connection times out.\n            MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; response = await index.add_documents(documents)\n            &gt;&gt;&gt; client.wait_for_task(response.update_id)\n        \"\"\"\n        return _task.wait_for_task(\n            self.http_client,\n            task_id=task_id,\n            timeout_in_ms=timeout_in_ms,\n            interval_in_ms=interval_in_ms,\n            raise_for_status=raise_for_status,\n        )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.__init__","title":"<code>__init__(url, api_key=None, *, timeout=None, verify=True)</code>","text":"<p>Class initializer.</p> <p>Args:</p> <pre><code>url: The url to the Meilisearch API (ex: http://localhost:7700)\napi_key: The optional API key for Meilisearch. Defaults to None.\ntimeout: The amount of time in seconds that the client will wait for a response before\n    timing out. Defaults to None.\nverify: SSL certificates (a.k.a CA bundle) used to\n    verify the identity of requested hosts. Either `True` (default CA bundle),\n    a path to an SSL certificate file, or `False` (disable verification)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    api_key: str | None = None,\n    *,\n    timeout: int | None = None,\n    verify: str | bool | SSLContext = True,\n) -&gt; None:\n    \"\"\"Class initializer.\n\n    Args:\n\n        url: The url to the Meilisearch API (ex: http://localhost:7700)\n        api_key: The optional API key for Meilisearch. Defaults to None.\n        timeout: The amount of time in seconds that the client will wait for a response before\n            timing out. Defaults to None.\n        verify: SSL certificates (a.k.a CA bundle) used to\n            verify the identity of requested hosts. Either `True` (default CA bundle),\n            a path to an SSL certificate file, or `False` (disable verification)\n    \"\"\"\n    super().__init__(api_key)\n\n    self.http_client = HttpxClient(\n        base_url=url, timeout=timeout, headers=self._headers, verify=verify\n    )\n    self._http_requests = HttpRequests(self.http_client)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.cancel_tasks","title":"<code>cancel_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>","text":"<p>Cancel a list of enqueued or processing tasks.</p> <p>Defaults to cancelling all tasks.</p> <p>Args:</p> <pre><code>uids: A list of task UIDs to cancel.\nindex_uids: A list of index UIDs for which to cancel tasks.\nstatuses: A list of statuses to cancel.\ntypes: A list of types to cancel.\nbefore_enqueued_at: Cancel tasks that were enqueued before the specified date time.\nafter_enqueued_at: Cancel tasks that were enqueued after the specified date time.\nbefore_started_at: Cancel tasks that were started before the specified date time.\nafter_finished_at: Cancel tasks that were finished after the specified date time.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.task import cancel_tasks\n&gt;&gt;&gt;\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.cancel_tasks(uids=[1, 2])\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def cancel_tasks(\n    self,\n    *,\n    uids: list[str] | None = None,\n    index_uids: list[str] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Cancel a list of enqueued or processing tasks.\n\n    Defaults to cancelling all tasks.\n\n    Args:\n\n        uids: A list of task UIDs to cancel.\n        index_uids: A list of index UIDs for which to cancel tasks.\n        statuses: A list of statuses to cancel.\n        types: A list of types to cancel.\n        before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n        after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n        before_started_at: Cancel tasks that were started before the specified date time.\n        after_finished_at: Cancel tasks that were finished after the specified date time.\n\n    Returns:\n\n        The details of the task\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.task import cancel_tasks\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.cancel_tasks(uids=[1, 2])\n    \"\"\"\n    return _task.cancel_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_dump","title":"<code>create_dump()</code>","text":"<p>Trigger the creation of a Meilisearch dump.</p> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.create_dump()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_dump(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch dump.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.create_dump()\n    \"\"\"\n    response = self._http_requests.post(\"dumps\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_index","title":"<code>create_index(uid, primary_key=None, *, settings=None, wait=True, plugins=None)</code>","text":"<p>Creates a new index.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\nsettings: Settings for the index. The settings can also be updated independently of\n    creating the index. The advantage to updating them here is updating the settings after\n    adding documents will cause the documents to be re-indexed. Because of this it will be\n    faster to update them before adding documents. Defaults to None (i.e. default\n    Meilisearch index settings).\nwait: If set to True and settings are being updated, the index will be returned after\n    the settings update has completed. If False it will not wait for settings to complete.\n    Default: True\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An instance of Index containing the information of the newly created index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.create_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_index(\n    self,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    plugins: IndexPlugins | None = None,\n) -&gt; Index:\n    \"\"\"Creates a new index.\n\n    Args:\n\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An instance of Index containing the information of the newly created index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.create_index(\"movies\")\n    \"\"\"\n    return Index.create(\n        self.http_client, uid, primary_key, settings=settings, wait=wait, plugins=plugins\n    )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_key","title":"<code>create_key(key)</code>","text":"<p>Creates a new API key.</p> <p>Args:</p> <pre><code>key: The information to use in creating the key. Note that if an expires_at value\n    is included it should be in UTC time.\n</code></pre> <p>Returns:</p> <pre><code>The new API key.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; key_info = KeyCreate(\n&gt;&gt;&gt;     description=\"My new key\",\n&gt;&gt;&gt;     actions=[\"search\"],\n&gt;&gt;&gt;     indexes=[\"movies\"],\n&gt;&gt;&gt; )\n&gt;&gt;&gt; keys = client.create_key(key_info)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_key(self, key: KeyCreate) -&gt; Key:\n    \"\"\"Creates a new API key.\n\n    Args:\n\n        key: The information to use in creating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n\n        The new API key.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyCreate\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; key_info = KeyCreate(\n        &gt;&gt;&gt;     description=\"My new key\",\n        &gt;&gt;&gt;     actions=[\"search\"],\n        &gt;&gt;&gt;     indexes=[\"movies\"],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; keys = client.create_key(key_info)\n    \"\"\"\n    if is_pydantic_2():\n        response = self._http_requests.post(\n            \"keys\", json.loads(key.model_dump_json(by_alias=True))\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = self._http_requests.post(\"keys\", json.loads(key.json(by_alias=True)))  # type: ignore[attr-defined]\n\n    return Key(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.create_snapshot","title":"<code>create_snapshot()</code>","text":"<p>Trigger the creation of a Meilisearch snapshot.</p> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.create_snapshot()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def create_snapshot(self) -&gt; TaskInfo:\n    \"\"\"Trigger the creation of a Meilisearch snapshot.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.create_snapshot()\n    \"\"\"\n    response = self._http_requests.post(\"snapshots\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_index_if_exists","title":"<code>delete_index_if_exists(uid)</code>","text":"<p>Deletes an index if it already exists.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\n</code></pre> <p>Returns:</p> <pre><code>True if an index was deleted for False if not.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.delete_index_if_exists()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_index_if_exists(self, uid: str) -&gt; bool:\n    \"\"\"Deletes an index if it already exists.\n\n    Args:\n\n        uid: The index's unique identifier.\n\n    Returns:\n\n        True if an index was deleted for False if not.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.delete_index_if_exists()\n    \"\"\"\n    response = self._http_requests.delete(f\"indexes/{uid}\")\n    status = self.wait_for_task(response.json()[\"taskUid\"], timeout_in_ms=100000)\n    if status.status == \"succeeded\":\n        return True\n    return False\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_key","title":"<code>delete_key(key)</code>","text":"<p>Deletes an API key.</p> <p>Args:</p> <pre><code>key: The key or uid to delete.\n</code></pre> <p>Returns:</p> <pre><code>The Response status code. 204 signifies a successful delete.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.delete_key(\"abc123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_key(self, key: str) -&gt; int:\n    \"\"\"Deletes an API key.\n\n    Args:\n\n        key: The key or uid to delete.\n\n    Returns:\n\n        The Response status code. 204 signifies a successful delete.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.delete_key(\"abc123\")\n    \"\"\"\n    response = self._http_requests.delete(f\"keys/{key}\")\n    return response.status_code\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.delete_tasks","title":"<code>delete_tasks(*, uids=None, index_uids=None, statuses=None, types=None, before_enqueued_at=None, after_enqueued_at=None, before_started_at=None, after_finished_at=None)</code>","text":"<p>Delete a list of tasks.</p> <p>Defaults to deleting all tasks.</p> <p>Args:</p> <pre><code>uids: A list of task UIDs to cancel.\nindex_uids: A list of index UIDs for which to cancel tasks.\nstatuses: A list of statuses to cancel.\ntypes: A list of types to cancel.\nbefore_enqueued_at: Cancel tasks that were enqueued before the specified date time.\nafter_enqueued_at: Cancel tasks that were enqueued after the specified date time.\nbefore_started_at: Cancel tasks that were started before the specified date time.\nafter_finished_at: Cancel tasks that were finished after the specified date time.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt;\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.delete_tasks(client, uids=[1, 2])\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def delete_tasks(\n    self,\n    *,\n    uids: list[str] | None = None,\n    index_uids: list[str] | None = None,\n    statuses: list[str] | None = None,\n    types: list[str] | None = None,\n    before_enqueued_at: datetime | None = None,\n    after_enqueued_at: datetime | None = None,\n    before_started_at: datetime | None = None,\n    after_finished_at: datetime | None = None,\n) -&gt; TaskInfo:\n    \"\"\"Delete a list of tasks.\n\n    Defaults to deleting all tasks.\n\n    Args:\n\n        uids: A list of task UIDs to cancel.\n        index_uids: A list of index UIDs for which to cancel tasks.\n        statuses: A list of statuses to cancel.\n        types: A list of types to cancel.\n        before_enqueued_at: Cancel tasks that were enqueued before the specified date time.\n        after_enqueued_at: Cancel tasks that were enqueued after the specified date time.\n        before_started_at: Cancel tasks that were started before the specified date time.\n        after_finished_at: Cancel tasks that were finished after the specified date time.\n\n    Returns:\n\n        The details of the task\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.delete_tasks(client, uids=[1, 2])\n    \"\"\"\n    return _task.delete_tasks(\n        self.http_client,\n        uids=uids,\n        index_uids=index_uids,\n        statuses=statuses,\n        types=types,\n        before_enqueued_at=before_enqueued_at,\n        after_enqueued_at=after_enqueued_at,\n        before_started_at=before_started_at,\n        after_finished_at=after_finished_at,\n    )\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_all_stats","title":"<code>get_all_stats()</code>","text":"<p>Get stats for all indexes.</p> <p>Returns:</p> <pre><code>Information about database size and all indexes.\nhttps://docs.meilisearch.com/reference/api/stats.html\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; stats = client.get_all_stats()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_all_stats(self) -&gt; ClientStats:\n    \"\"\"Get stats for all indexes.\n\n    Returns:\n\n        Information about database size and all indexes.\n        https://docs.meilisearch.com/reference/api/stats.html\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; stats = client.get_all_stats()\n    \"\"\"\n    response = self._http_requests.get(\"stats\")\n\n    return ClientStats(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_index","title":"<code>get_index(uid)</code>","text":"<p>Gets a single index based on the uid of the index.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\n</code></pre> <p>Returns:</p> <pre><code>An Index instance containing the information of the fetched index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.get_index()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_index(self, uid: str) -&gt; Index:\n    \"\"\"Gets a single index based on the uid of the index.\n\n    Args:\n\n        uid: The index's unique identifier.\n\n    Returns:\n\n        An Index instance containing the information of the fetched index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.get_index()\n    \"\"\"\n    return Index(self.http_client, uid).fetch_info()\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_indexes","title":"<code>get_indexes(*, offset=None, limit=None)</code>","text":"<p>Get all indexes. Args:</p> <pre><code>offset: Number of indexes to skip. The default of None will use the Meilisearch\n    default.\nlimit: Number of indexes to return. The default of None will use the Meilisearch\n    default.\n</code></pre> <p>Returns:</p> <pre><code>A list of all indexes.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt; indexes = client.get_indexes()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[Index] | None:\n    \"\"\"Get all indexes.\n    Args:\n\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n\n        A list of all indexes.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt; indexes = client.get_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = self._http_requests.get(url)\n\n    if not response.json()[\"results\"]:\n        return None\n\n    return [\n        Index(\n            http_client=self.http_client,\n            uid=x[\"uid\"],\n            primary_key=x[\"primaryKey\"],\n            created_at=x[\"createdAt\"],\n            updated_at=x[\"updatedAt\"],\n        )\n        for x in response.json()[\"results\"]\n    ]\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_key","title":"<code>get_key(key)</code>","text":"<p>Gets information about a specific API key.</p> <p>Args:</p> <pre><code>key: The key for which to retrieve the information.\n</code></pre> <p>Returns:</p> <pre><code>The API key, or `None` if the key is not found.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; keys = client.get_key(\"abc123\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_key(self, key: str) -&gt; Key:\n    \"\"\"Gets information about a specific API key.\n\n    Args:\n\n        key: The key for which to retrieve the information.\n\n    Returns:\n\n        The API key, or `None` if the key is not found.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; keys = client.get_key(\"abc123\")\n    \"\"\"\n    response = self._http_requests.get(f\"keys/{key}\")\n\n    return Key(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_keys","title":"<code>get_keys(*, offset=None, limit=None)</code>","text":"<p>Gets the Meilisearch API keys. Args:</p> <pre><code>offset: Number of indexes to skip. The default of None will use the Meilisearch\n    default.\nlimit: Number of indexes to return. The default of None will use the Meilisearch\n    default.\n</code></pre> <p>Returns:</p> <pre><code>API keys.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; keys = client.get_keys()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_keys(self, *, offset: int | None = None, limit: int | None = None) -&gt; KeySearch:\n    \"\"\"Gets the Meilisearch API keys.\n    Args:\n\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns:\n\n        API keys.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; keys = client.get_keys()\n    \"\"\"\n    url = _build_offset_limit_url(\"keys\", offset, limit)\n    response = self._http_requests.get(url)\n\n    return KeySearch(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_or_create_index","title":"<code>get_or_create_index(uid, primary_key=None, *, plugins=None)</code>","text":"<p>Get an index, or create it if it doesn't exist.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An instance of Index containing the information of the retrieved or newly created index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.get_or_create_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_or_create_index(\n    self, uid: str, primary_key: str | None = None, *, plugins: IndexPlugins | None = None\n) -&gt; Index:\n    \"\"\"Get an index, or create it if it doesn't exist.\n\n    Args:\n\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An instance of Index containing the information of the retrieved or newly created index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.get_or_create_index(\"movies\")\n    \"\"\"\n    try:\n        index_instance = self.get_index(uid)\n    except MeilisearchApiError as err:\n        if \"index_not_found\" not in err.code:\n            raise\n        index_instance = self.create_index(uid, primary_key, plugins=plugins)\n    return index_instance\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_raw_index","title":"<code>get_raw_index(uid)</code>","text":"<p>Gets the index and returns all the index information rather than an Index instance.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\n</code></pre> <p>Returns:</p> <pre><code>Index information rather than an Index instance.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.get_raw_index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_raw_index(self, uid: str) -&gt; IndexInfo | None:\n    \"\"\"Gets the index and returns all the index information rather than an Index instance.\n\n    Args:\n\n        uid: The index's unique identifier.\n\n    Returns:\n\n        Index information rather than an Index instance.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.get_raw_index(\"movies\")\n    \"\"\"\n    response = self.http_client.get(f\"indexes/{uid}\")\n\n    if response.status_code == 404:\n        return None\n\n    return IndexInfo(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_raw_indexes","title":"<code>get_raw_indexes(*, offset=None, limit=None)</code>","text":"<p>Gets all the indexes. Args:</p> <pre><code>offset: Number of indexes to skip. The default of None will use the Meilisearch\n    default.\nlimit: Number of indexes to return. The default of None will use the Meilisearch\n    default.\n</code></pre> <p>Returns all the index information rather than an AsyncIndex instance.</p> <p>Returns:</p> <pre><code>A list of the Index information rather than an AsyncIndex instances.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.get_raw_indexes()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_raw_indexes(\n    self, *, offset: int | None = None, limit: int | None = None\n) -&gt; list[IndexInfo] | None:\n    \"\"\"Gets all the indexes.\n    Args:\n\n        offset: Number of indexes to skip. The default of None will use the Meilisearch\n            default.\n        limit: Number of indexes to return. The default of None will use the Meilisearch\n            default.\n\n    Returns all the index information rather than an AsyncIndex instance.\n\n    Returns:\n\n        A list of the Index information rather than an AsyncIndex instances.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.get_raw_indexes()\n    \"\"\"\n    url = _build_offset_limit_url(\"indexes\", offset, limit)\n    response = self._http_requests.get(url)\n\n    if not response.json()[\"results\"]:\n        return None\n\n    return [IndexInfo(**x) for x in response.json()[\"results\"]]\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_task","title":"<code>get_task(task_id)</code>","text":"<p>Get a single task from it's task id.</p> <p>Args:</p> <pre><code>task_id: Identifier of the task to retrieve.\n</code></pre> <p>Returns:</p> <pre><code>Results of a task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt;\n&gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; get_task(client, 1244)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_task(self, task_id: int) -&gt; TaskResult:\n    \"\"\"Get a single task from it's task id.\n\n    Args:\n\n        task_id: Identifier of the task to retrieve.\n\n    Returns:\n\n        Results of a task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; get_task(client, 1244)\n    \"\"\"\n    return _task.get_task(self.http_client, task_id=task_id)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_tasks","title":"<code>get_tasks(*, index_ids=None, types=None)</code>","text":"<p>Get multiple tasks.</p> <p>Args:</p> <pre><code>index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n    tasks only for the specified indexes, if not all tasks will be returned. Default = None\ntypes: Specify specific task types to retrieve. Default = None\n</code></pre> <p>Returns:</p> <pre><code>Task statuses.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt;\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; client.get_tasks(client)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_tasks(\n    self,\n    *,\n    index_ids: list[str] | None = None,\n    types: str | list[str] | None = None,\n) -&gt; TaskStatus:\n    \"\"\"Get multiple tasks.\n\n    Args:\n\n        index_ids: A list of index UIDs for which to get the tasks. If provided this will get the\n            tasks only for the specified indexes, if not all tasks will be returned. Default = None\n        types: Specify specific task types to retrieve. Default = None\n\n    Returns:\n\n        Task statuses.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; client.get_tasks(client)\n    \"\"\"\n    return _task.get_tasks(self.http_client, index_ids=index_ids, types=types)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.get_version","title":"<code>get_version()</code>","text":"<p>Get the Meilisearch version.</p> <p>Returns:</p> <pre><code>Information about the version of Meilisearch.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; version = client.get_version()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def get_version(self) -&gt; Version:\n    \"\"\"Get the Meilisearch version.\n\n    Returns:\n\n        Information about the version of Meilisearch.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; version = client.get_version()\n    \"\"\"\n    response = self._http_requests.get(\"version\")\n\n    return Version(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.health","title":"<code>health()</code>","text":"<p>Get health of the Meilisearch server.</p> <p>Returns:</p> <pre><code>The status of the Meilisearch server.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; health = client.get_health()\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def health(self) -&gt; Health:\n    \"\"\"Get health of the Meilisearch server.\n\n    Returns:\n\n        The status of the Meilisearch server.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; health = client.get_health()\n    \"\"\"\n    response = self._http_requests.get(\"health\")\n\n    return Health(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.index","title":"<code>index(uid, *, plugins=None)</code>","text":"<p>Create a local reference to an index identified by UID, without making an HTTP call.</p> <p>Args:</p> <pre><code>uid: The index's unique identifier.\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An Index instance.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def index(self, uid: str, *, plugins: IndexPlugins | None = None) -&gt; Index:\n    \"\"\"Create a local reference to an index identified by UID, without making an HTTP call.\n\n    Args:\n\n        uid: The index's unique identifier.\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An Index instance.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n    \"\"\"\n    return Index(self.http_client, uid=uid, plugins=plugins)\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.multi_search","title":"<code>multi_search(queries)</code>","text":"<p>Multi-index search.</p> <p>Args:</p> <pre><code>queries: List of SearchParameters\n</code></pre> <p>Returns:</p> <pre><code>Results of the search\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; queries = [\n&gt;&gt;&gt;     SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n&gt;&gt;&gt;     SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; search_results = client.search(queries)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def multi_search(self, queries: list[SearchParams]) -&gt; list[SearchResultsWithUID]:\n    \"\"\"Multi-index search.\n\n    Args:\n\n        queries: List of SearchParameters\n\n    Returns:\n\n        Results of the search\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.search import SearchParams\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; queries = [\n        &gt;&gt;&gt;     SearchParams(index_uid=\"my_first_index\", query\"Some search\"),\n        &gt;&gt;&gt;     SearchParams(index_uid=\"my_second_index\", query=\"Another search\")\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; search_results = client.search(queries)\n    \"\"\"\n    url = \"multi-search\"\n    if is_pydantic_2():\n        response = self._http_requests.post(\n            url,\n            body={\"queries\": [x.model_dump(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n        )\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = self._http_requests.post(\n            url,\n            body={\"queries\": [x.dict(by_alias=True) for x in queries]},  # type: ignore[attr-defined]\n        )\n\n    return [SearchResultsWithUID(**x) for x in response.json()[\"results\"]]\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.swap_indexes","title":"<code>swap_indexes(indexes)</code>","text":"<p>Swap two indexes.</p> <p>Args:</p> <pre><code>indexes: A list of tuples, each tuple should contain the indexes to swap.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.swap_indexes([(\"index_a\", \"index_b\")])\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def swap_indexes(self, indexes: list[tuple[str, str]]) -&gt; TaskInfo:\n    \"\"\"Swap two indexes.\n\n    Args:\n\n        indexes: A list of tuples, each tuple should contain the indexes to swap.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.swap_indexes([(\"index_a\", \"index_b\")])\n    \"\"\"\n    processed_indexes = [{\"indexes\": x} for x in indexes]\n    response = self._http_requests.post(\"swap-indexes\", processed_indexes)\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.update_key","title":"<code>update_key(key)</code>","text":"<p>Update an API key.</p> <p>Args:</p> <pre><code>key: The information to use in updating the key. Note that if an expires_at value\n    is included it should be in UTC time.\n</code></pre> <p>Returns:</p> <pre><code>The updated API key.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; key_info = KeyUpdate(\n        key=\"abc123\",\n&gt;&gt;&gt;     indexes=[\"*\"],\n&gt;&gt;&gt; )\n&gt;&gt;&gt; keys = client.update_key(key_info)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def update_key(self, key: KeyUpdate) -&gt; Key:\n    \"\"\"Update an API key.\n\n    Args:\n\n        key: The information to use in updating the key. Note that if an expires_at value\n            is included it should be in UTC time.\n\n    Returns:\n\n        The updated API key.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilissearch_async_client.models.client import KeyUpdate\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; key_info = KeyUpdate(\n                key=\"abc123\",\n        &gt;&gt;&gt;     indexes=[\"*\"],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; keys = client.update_key(key_info)\n    \"\"\"\n    payload = _build_update_key_payload(key)\n    response = self._http_requests.patch(f\"keys/{key.key}\", payload)\n\n    return Key(**response.json())\n</code></pre>"},{"location":"client_api/#meilisearch_python_sdk.Client.wait_for_task","title":"<code>wait_for_task(task_id, *, timeout_in_ms=5000, interval_in_ms=50, raise_for_status=False)</code>","text":"<p>Wait until Meilisearch processes a task, and get its status.</p> <p>Args:</p> <pre><code>client: An httpx HttpxClient or meilisearch_python_sdk Client instance.\ntask_id: Identifier of the task to retrieve.\ntimeout_in_ms: Amount of time in milliseconds to wait before raising a\n    MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n    if the `None` option is used the wait time could be very long. Defaults to 5000.\ninterval_in_ms: Time interval in miliseconds to sleep between requests. Defaults to 50.\nraise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n    has a failed status. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Details of the processed update status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nMeilisearchTimeoutError: If the connection times out.\nMeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; &gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; response = await index.add_documents(documents)\n&gt;&gt;&gt; client.wait_for_task(response.update_id)\n</code></pre> Source code in <code>meilisearch_python_sdk/_client.py</code> <pre><code>def wait_for_task(\n    self,\n    task_id: int,\n    *,\n    timeout_in_ms: int | None = 5000,\n    interval_in_ms: int = 50,\n    raise_for_status: bool = False,\n) -&gt; TaskResult:\n    \"\"\"Wait until Meilisearch processes a task, and get its status.\n\n    Args:\n\n        client: An httpx HttpxClient or meilisearch_python_sdk Client instance.\n        task_id: Identifier of the task to retrieve.\n        timeout_in_ms: Amount of time in milliseconds to wait before raising a\n            MeilisearchTimeoutError. `None` can also be passed to wait indefinitely. Be aware that\n            if the `None` option is used the wait time could be very long. Defaults to 5000.\n        interval_in_ms: Time interval in miliseconds to sleep between requests. Defaults to 50.\n        raise_for_status: When set to `True` a MeilisearchTaskFailedError will be raised if a task\n            has a failed status. Defaults to False.\n\n    Returns:\n\n        Details of the processed update status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        MeilisearchTimeoutError: If the connection times out.\n        MeilisearchTaskFailedError: If `raise_for_status` is `True` and a task has a failed status.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; response = await index.add_documents(documents)\n        &gt;&gt;&gt; client.wait_for_task(response.update_id)\n    \"\"\"\n    return _task.wait_for_task(\n        self.http_client,\n        task_id=task_id,\n        timeout_in_ms=timeout_in_ms,\n        interval_in_ms=interval_in_ms,\n        raise_for_status=raise_for_status,\n    )\n</code></pre>"},{"location":"decorators_api/","title":"Decorators","text":""},{"location":"decorators_api/#decorator-usage","title":"Decorator Usage","text":"<p>Various decorators are provided that can be used to help with the Meilisearch interaction.</p>"},{"location":"decorators_api/#meilisearch_python_sdk.decorators.ConnectionInfo","title":"<code>ConnectionInfo</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Infomation on how to connect to Meilisearch.</p> <p>url: URL for the Meilisearch server. api_key: The API key for the server.</p> Source code in <code>meilisearch_python_sdk/decorators.py</code> <pre><code>class ConnectionInfo(NamedTuple):\n    \"\"\"Infomation on how to connect to Meilisearch.\n\n    url: URL for the Meilisearch server.\n    api_key: The API key for the server.\n    \"\"\"\n\n    url: str\n    api_key: str\n</code></pre>"},{"location":"decorators_api/#meilisearch_python_sdk.decorators.add_documents","title":"<code>add_documents(*, index_name, connection_info, batch_size=None, primary_key=None, wait_for_task=False)</code>","text":"<p>Decorator that takes the returned documents from a function and adds them to Meilisearch.</p> <p>It is required that either an client or url is provided.</p> <p>Args:</p> <pre><code>index_name: The name of the index to which the documents should be added.\nconnection_info: Either an Client instance ConnectionInfo with informtaion on how to\n    connect to Meilisearch.\nbatch_size: If provided the documents will be sent in batches of the specified size.\n    Otherwise all documents are sent at once. Default = None.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\nwait_for_task: If set to `True` the decorator will wait for the document addition to finish\n    indexing before returning, otherwise it will return right away. Default = False.\n</code></pre> <p>Returns:</p> <pre><code>The list of documents proviced by the decorated function.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nValueError: If neither an async_client nor an url is provided.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.decorators import add_documents, ConnectionInfo\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With `Client`\n&gt;&gt;&gt; client = Client(url=\"http://localhost:7700\", api_key=\"masterKey\")\n&gt;&gt;&gt; @add_documents(index_name=\"movies\", connection_info=client)\n&gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:\n&gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With `ConnectionInfo`\n&gt;&gt;&gt; @add_documents(\n        index_name=\"movies\",\n        connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\"),\n    )\n&gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:\n&gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n</code></pre> Source code in <code>meilisearch_python_sdk/decorators.py</code> <pre><code>def add_documents(\n    *,\n    index_name: str,\n    connection_info: Client | ConnectionInfo,\n    batch_size: int | None = None,\n    primary_key: str | None = None,\n    wait_for_task: bool = False,\n) -&gt; Callable:\n    \"\"\"Decorator that takes the returned documents from a function and adds them to Meilisearch.\n\n    It is required that either an client or url is provided.\n\n    Args:\n\n        index_name: The name of the index to which the documents should be added.\n        connection_info: Either an Client instance ConnectionInfo with informtaion on how to\n            connect to Meilisearch.\n        batch_size: If provided the documents will be sent in batches of the specified size.\n            Otherwise all documents are sent at once. Default = None.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        wait_for_task: If set to `True` the decorator will wait for the document addition to finish\n            indexing before returning, otherwise it will return right away. Default = False.\n\n    Returns:\n\n        The list of documents proviced by the decorated function.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        ValueError: If neither an async_client nor an url is provided.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.decorators import add_documents, ConnectionInfo\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With `Client`\n        &gt;&gt;&gt; client = Client(url=\"http://localhost:7700\", api_key=\"masterKey\")\n        &gt;&gt;&gt; @add_documents(index_name=\"movies\", connection_info=client)\n        &gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # With `ConnectionInfo`\n        &gt;&gt;&gt; @add_documents(\n                index_name=\"movies\",\n                connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\"),\n            )\n        &gt;&gt;&gt; def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            result = func(*args, **kwargs)\n            if isinstance(connection_info, Client):\n                _add_documents(\n                    connection_info,\n                    index_name,\n                    result,\n                    batch_size,\n                    primary_key,\n                    wait_for_task,\n                )\n                return result\n\n            decorator_client = Client(url=connection_info.url, api_key=connection_info.api_key)\n            _add_documents(\n                decorator_client,\n                index_name,\n                result,\n                batch_size,\n                primary_key,\n                wait_for_task,\n            )\n\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"decorators_api/#meilisearch_python_sdk.decorators.async_add_documents","title":"<code>async_add_documents(*, index_name, connection_info, batch_size=None, primary_key=None, wait_for_task=False)</code>","text":"<p>Decorator that takes the returned documents from a function and asyncronously adds them to Meilisearch.</p> <p>It is required that either an async_client or url is provided.</p> <p>Args:</p> <pre><code>index_name: The name of the index to which the documents should be added.\nconnection_info: Either an AsyncClient instance ConnectionInfo with informtaion on how to\n    connect to Meilisearch.\nbatch_size: If provided the documents will be sent in batches of the specified size.\n    Otherwise all documents are sent at once. Default = None.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\nwait_for_task: If set to `True` the decorator will wait for the document addition to finish\n    indexing before returning, otherwise it will return right away. Default = False.\n</code></pre> <p>Returns:</p> <pre><code>The list of documents proviced by the decorated function.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\nValueError: If neither an async_client nor an url is provided.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n&gt;&gt;&gt; from meilisearch_python_sdk.decorators import async_add_documents, ConnectionInfo\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; # with `AsyncClient`\n&gt;&gt;&gt; client = AsyncClient(url=\"http://localhost:7700\", api_key=\"masterKey\")\n&gt;&gt;&gt; @async_add_documents(index_name=\"movies\", connection_info=client)\n&gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:\n&gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # with `ConnectionInfo`\n&gt;&gt;&gt; @async_add_documents(\n        index_name=\"movies\",\n        connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\",\n    )\n&gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:\n&gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n</code></pre> Source code in <code>meilisearch_python_sdk/decorators.py</code> <pre><code>def async_add_documents(\n    *,\n    index_name: str,\n    connection_info: AsyncClient | ConnectionInfo,\n    batch_size: int | None = None,\n    primary_key: str | None = None,\n    wait_for_task: bool = False,\n) -&gt; Callable:\n    \"\"\"Decorator that takes the returned documents from a function and asyncronously adds them to Meilisearch.\n\n    It is required that either an async_client or url is provided.\n\n    Args:\n\n        index_name: The name of the index to which the documents should be added.\n        connection_info: Either an AsyncClient instance ConnectionInfo with informtaion on how to\n            connect to Meilisearch.\n        batch_size: If provided the documents will be sent in batches of the specified size.\n            Otherwise all documents are sent at once. Default = None.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        wait_for_task: If set to `True` the decorator will wait for the document addition to finish\n            indexing before returning, otherwise it will return right away. Default = False.\n\n    Returns:\n\n        The list of documents proviced by the decorated function.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n        ValueError: If neither an async_client nor an url is provided.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import AsyncClient\n        &gt;&gt;&gt; from meilisearch_python_sdk.decorators import async_add_documents, ConnectionInfo\n        &gt;&gt;&gt;\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # with `AsyncClient`\n        &gt;&gt;&gt; client = AsyncClient(url=\"http://localhost:7700\", api_key=\"masterKey\")\n        &gt;&gt;&gt; @async_add_documents(index_name=\"movies\", connection_info=client)\n        &gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # with `ConnectionInfo`\n        &gt;&gt;&gt; @async_add_documents(\n                index_name=\"movies\",\n                connection_info=ConnectionInfo(url=\"http://localhost:7700\", api_key=\"masterKey\",\n            )\n        &gt;&gt;&gt; async def my_function() -&gt; list[dict[str, Any]]:\n        &gt;&gt;&gt;     return [{\"id\": 1, \"title\": \"Test 1\"}, {\"id\": 2, \"title\": \"Test 2\"}]\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            result = await func(*args, **kwargs)\n            if isinstance(connection_info, AsyncClient):\n                await _async_add_documents(\n                    connection_info,\n                    index_name,\n                    result,\n                    batch_size,\n                    primary_key,\n                    wait_for_task,\n                )\n                return result\n\n            async with AsyncClient(connection_info.url, connection_info.api_key) as client:\n                await _async_add_documents(\n                    client, index_name, result, batch_size, primary_key, wait_for_task\n                )\n\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"index_api/","title":"Index","text":""},{"location":"index_api/#index-usage","title":"<code>Index</code> Usage","text":"<p>The <code>Index</code> uses blocking methods, and and should be used when using the <code>Client</code>. When you create a new index with the <code>Client</code> it will create an <code>Index</code> instance.</p>"},{"location":"index_api/#index-api","title":"<code>Index</code> API","text":"<p>             Bases: <code>_BaseIndex</code></p> <p>Index class gives access to all indexes routes and child routes.</p> <p>https://docs.meilisearch.com/reference/api/indexes.html</p> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>class Index(_BaseIndex):\n    \"\"\"Index class gives access to all indexes routes and child routes.\n\n    https://docs.meilisearch.com/reference/api/indexes.html\n    \"\"\"\n\n    def __init__(\n        self,\n        http_client: Client,\n        uid: str,\n        primary_key: str | None = None,\n        created_at: str | datetime | None = None,\n        updated_at: str | datetime | None = None,\n        plugins: IndexPlugins | None = None,\n    ):\n        \"\"\"Class initializer.\n\n        Args:\n\n            http_client: An instance of the Client. This automatically gets passed by the\n                Client when creating and Index instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            created_at: The date and time the index was created. Defaults to None.\n            updated_at: The date and time the index was last updated. Defaults to None.\n            plugins: Optional plugins can be provided to extend functionality.\n        \"\"\"\n        super().__init__(uid, primary_key, created_at, updated_at)\n        self.http_client = http_client\n        self._http_requests = HttpRequests(http_client)\n        self.plugins = plugins\n\n    @cached_property\n    def _post_add_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.add_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_add_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.add_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.add_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_all_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_all_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_all_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_all_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_all_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_document_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_document_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_document_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_document_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_document_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_documents_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_delete_documents_by_filter_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_by_filter_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_delete_documents_by_filter_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.delete_documents_by_filter_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.delete_documents_by_filter_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_facet_search_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.facet_search_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_facet_search_plugins(self) -&gt; list[Plugin] | None:\n        if not self.plugins or not self.plugins.facet_search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.facet_search_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_search_plugins(self) -&gt; list[Plugin | PostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.search_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_search_plugins(self) -&gt; list[Plugin | PostSearchPlugin] | None:\n        if not self.plugins or not self.plugins.search_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.search_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _post_update_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.update_documents_plugins:\n            if plugin.POST_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    @cached_property\n    def _pre_update_documents_plugins(self) -&gt; list[Plugin | DocumentPlugin] | None:\n        if not self.plugins or not self.plugins.update_documents_plugins:\n            return None\n\n        plugins = []\n        for plugin in self.plugins.update_documents_plugins:\n            if plugin.PRE_EVENT:\n                plugins.append(plugin)\n\n        if not plugins:\n            return None\n\n        return plugins\n\n    def delete(self) -&gt; TaskInfo:\n        \"\"\"Deletes the index.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete()\n        \"\"\"\n        response = self._http_requests.delete(self._base_url_with_uid)\n        return TaskInfo(**response.json())\n\n    def delete_if_exists(self) -&gt; bool:\n        \"\"\"Delete the index if it already exists.\n\n        Returns:\n\n            True if the index was deleted or False if not.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete_if_exists()\n        \"\"\"\n        response = self.delete()\n        status = wait_for_task(self.http_client, response.task_uid, timeout_in_ms=100000)\n        if status.status == \"succeeded\":\n            return True\n\n        return False\n\n    def update(self, primary_key: str) -&gt; Index:\n        \"\"\"Update the index primary key.\n\n        Args:\n\n            primary_key: The primary key of the documents.\n\n        Returns:\n\n            An instance of the AsyncIndex with the updated information.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; updated_index = index.update()\n        \"\"\"\n        payload = {\"primaryKey\": primary_key}\n        response = self._http_requests.patch(self._base_url_with_uid, payload)\n        wait_for_task(self.http_client, response.json()[\"taskUid\"], timeout_in_ms=100000)\n        index_response = self._http_requests.get(self._base_url_with_uid)\n        self.primary_key = index_response.json()[\"primaryKey\"]\n        return self\n\n    def fetch_info(self) -&gt; Index:\n        \"\"\"Gets the infromation about the index.\n\n        Returns:\n\n            An instance of the AsyncIndex containing the retrieved information.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index_info = index.fetch_info()\n        \"\"\"\n        response = self._http_requests.get(self._base_url_with_uid)\n        index_dict = response.json()\n        self._set_fetch_info(\n            index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n        )\n        return self\n\n    def get_primary_key(self) -&gt; str | None:\n        \"\"\"Get the primary key.\n\n        Returns:\n\n            The primary key for the documents in the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; primary_key = index.get_primary_key()\n        \"\"\"\n        info = self.fetch_info()\n        return info.primary_key\n\n    @classmethod\n    def create(\n        cls,\n        http_client: Client,\n        uid: str,\n        primary_key: str | None = None,\n        *,\n        settings: MeilisearchSettings | None = None,\n        wait: bool = True,\n        plugins: IndexPlugins | None = None,\n    ) -&gt; Index:\n        \"\"\"Creates a new index.\n\n        In general this method should not be used directly and instead the index should be created\n        through the `Client`.\n\n        Args:\n\n            http_client: An instance of the Client. This automatically gets passed by the Client\n                when creating an Index instance.\n            uid: The index's unique identifier.\n            primary_key: The primary key of the documents. Defaults to None.\n            settings: Settings for the index. The settings can also be updated independently of\n                creating the index. The advantage to updating them here is updating the settings after\n                adding documents will cause the documents to be re-indexed. Because of this it will be\n                faster to update them before adding documents. Defaults to None (i.e. default\n                Meilisearch index settings).\n            wait: If set to True and settings are being updated, the index will be returned after\n                the settings update has completed. If False it will not wait for settings to complete.\n                Default: True\n            plugins: Optional plugins can be provided to extend functionality.\n\n        Returns:\n\n            An instance of Index containing the information of the newly created index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = index.create(client, \"movies\")\n        \"\"\"\n        if not primary_key:\n            payload = {\"uid\": uid}\n        else:\n            payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n        url = \"indexes\"\n        http_request = HttpRequests(http_client)\n        response = http_request.post(url, payload)\n        wait_for_task(http_client, response.json()[\"taskUid\"], timeout_in_ms=None)\n        index_response = http_request.get(f\"{url}/{uid}\")\n        index_dict = index_response.json()\n        index = cls(\n            http_client=http_client,\n            uid=index_dict[\"uid\"],\n            primary_key=index_dict[\"primaryKey\"],\n            created_at=index_dict[\"createdAt\"],\n            updated_at=index_dict[\"updatedAt\"],\n            plugins=plugins,\n        )\n\n        if settings:\n            settings_task = index.update_settings(settings)\n            if wait:\n                wait_for_task(http_client, settings_task.task_uid, timeout_in_ms=None)\n\n        return index\n\n    def get_stats(self) -&gt; IndexStats:\n        \"\"\"Get stats of the index.\n\n        Returns:\n\n            Stats of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; stats = index.get_stats()\n        \"\"\"\n        response = self._http_requests.get(self._stats_url)\n\n        return IndexStats(**response.json())\n\n    def search(\n        self,\n        query: str | None = None,\n        *,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] = [\"*\"],\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: str = \"all\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        vector: list[float] | None = None,\n        hybrid: Hybrid | None = None,\n    ) -&gt; SearchResults:\n        \"\"\"Search the index.\n\n        Args:\n\n            query: String containing the word(s) to search\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximun number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the matches should be\n                returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words excedes the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n            hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n                In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n\n        Returns:\n\n            Results of the search\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; search_results = index.search(\"Tron\")\n        \"\"\"\n        body = _process_search_parameters(\n            q=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n        )\n\n        if self._pre_search_plugins:\n            Index._run_plugins(\n                self._pre_search_plugins,\n                Event.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                vector=vector,\n                hybrid=hybrid,\n            )\n\n        response = self._http_requests.post(f\"{self._base_url_with_uid}/search\", body=body)\n        result = SearchResults(**response.json())\n        if self._post_search_plugins:\n            post = Index._run_plugins(self._post_search_plugins, Event.POST, search_results=result)\n            if post.get(\"search_result\"):\n                result = post[\"search_result\"]\n\n        return result\n\n    def facet_search(\n        self,\n        query: str | None = None,\n        *,\n        facet_name: str,\n        facet_query: str,\n        offset: int = 0,\n        limit: int = 20,\n        filter: Filter | None = None,\n        facets: list[str] | None = None,\n        attributes_to_retrieve: list[str] = [\"*\"],\n        attributes_to_crop: list[str] | None = None,\n        crop_length: int = 200,\n        attributes_to_highlight: list[str] | None = None,\n        sort: list[str] | None = None,\n        show_matches_position: bool = False,\n        highlight_pre_tag: str = \"&lt;em&gt;\",\n        highlight_post_tag: str = \"&lt;/em&gt;\",\n        crop_marker: str = \"...\",\n        matching_strategy: str = \"all\",\n        hits_per_page: int | None = None,\n        page: int | None = None,\n        attributes_to_search_on: list[str] | None = None,\n        show_ranking_score: bool = False,\n        show_ranking_score_details: bool = False,\n        vector: list[float] | None = None,\n    ) -&gt; FacetSearchResults:\n        \"\"\"Search the index.\n\n        Args:\n\n            query: String containing the word(s) to search\n            facet_name: The name of the facet to search\n            facet_query: The facet search value\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returned. Defaults to 20.\n            filter: Filter queries by an attribute value. Defaults to None.\n            facets: Facets for which to retrieve the matching count. Defaults to None.\n            attributes_to_retrieve: Attributes to display in the returned documents.\n                Defaults to [\"*\"].\n            attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n            crop_length: The maximun number of words to display. Defaults to 200.\n            attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n                Defaults to None.\n            sort: Attributes by which to sort the results. Defaults to None.\n            show_matches_position: Defines whether an object that contains information about the matches should be\n                returned or not. Defaults to False.\n            highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n            highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n            crop_marker: Marker to display when the number of words excedes the `crop_length`.\n                Defaults to ...\n            matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n            hits_per_page: Sets the number of results returned per page.\n            page: Sets the specific results page to fetch.\n            attributes_to_search_on: List of field names. Allow search over a subset of searchable\n                attributes without modifying the index settings. Defaults to None.\n            show_ranking_score: If set to True the ranking score will be returned with each document\n                in the search. Defaults to False.\n            show_ranking_score_details: If set to True the ranking details will be returned with\n                each document in the search. Defaults to False. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n                to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n                sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n                Because this feature is experimental it may be removed or updated causing breaking\n                changes in this library without a major version bump so use with caution. This\n                feature became stable in Meiliseach v1.7.0.\n            vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n                only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n                In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n                feature by sending a PATCH request to /experimental-features with\n                { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n                updated causing breaking changes in this library without a major version bump so use\n                with caution.\n\n        Returns:\n\n            Results of the search\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; search_results = index.search(\n            &gt;&gt;&gt;     \"Tron\",\n            &gt;&gt;&gt;     facet_name=\"genre\",\n            &gt;&gt;&gt;     facet_query=\"Sci-fi\"\n            &gt;&gt;&gt; )\n        \"\"\"\n        body = _process_search_parameters(\n            q=query,\n            facet_name=facet_name,\n            facet_query=facet_query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n        )\n\n        if self._pre_facet_search_plugins:\n            Index._run_plugins(\n                self._pre_facet_search_plugins,\n                Event.PRE,\n                query=query,\n                offset=offset,\n                limit=limit,\n                filter=filter,\n                facets=facets,\n                attributes_to_retrieve=attributes_to_retrieve,\n                attributes_to_crop=attributes_to_crop,\n                crop_length=crop_length,\n                attributes_to_highlight=attributes_to_highlight,\n                sort=sort,\n                show_matches_position=show_matches_position,\n                highlight_pre_tag=highlight_pre_tag,\n                highlight_post_tag=highlight_post_tag,\n                crop_marker=crop_marker,\n                matching_strategy=matching_strategy,\n                hits_per_page=hits_per_page,\n                page=page,\n                attributes_to_search_on=attributes_to_search_on,\n                show_ranking_score=show_ranking_score,\n                show_ranking_score_details=show_ranking_score_details,\n                vector=vector,\n            )\n\n        response = self._http_requests.post(f\"{self._base_url_with_uid}/facet-search\", body=body)\n        result = FacetSearchResults(**response.json())\n        if self._post_facet_search_plugins:\n            post = Index._run_plugins(self._post_facet_search_plugins, Event.POST, result=result)\n            if isinstance(post[\"generic_result\"], FacetSearchResults):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def get_document(self, document_id: str) -&gt; JsonDict:\n        \"\"\"Get one document with given document identifier.\n\n        Args:\n\n            document_id: Unique identifier of the document.\n\n        Returns:\n\n            The document information\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; document = index.get_document(\"1234\")\n        \"\"\"\n        response = self._http_requests.get(f\"{self._documents_url}/{document_id}\")\n\n        return response.json()\n\n    def get_documents(\n        self,\n        *,\n        offset: int = 0,\n        limit: int = 20,\n        fields: list[str] | None = None,\n        filter: Filter | None = None,\n    ) -&gt; DocumentsInfo:\n        \"\"\"Get a batch documents from the index.\n\n        Args:\n\n            offset: Number of documents to skip. Defaults to 0.\n            limit: Maximum number of documents returnedd. Defaults to 20.\n            fields: Document attributes to show. If this value is None then all\n                attributes are retrieved. Defaults to None.\n            filter: Filter value information. Defaults to None. Note: This parameter can only be\n                used with Meilisearch &gt;= v1.2.0\n\n        Returns:\n\n            Documents info.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; documents = index.get_documents()\n        \"\"\"\n        parameters: JsonDict = {\n            \"offset\": offset,\n            \"limit\": limit,\n        }\n\n        if not filter:\n            if fields:\n                parameters[\"fields\"] = \",\".join(fields)\n\n            url = _build_encoded_url(self._documents_url, parameters)\n            response = self._http_requests.get(url)\n\n            return DocumentsInfo(**response.json())\n\n        if fields:\n            parameters[\"fields\"] = fields\n\n        parameters[\"filter\"] = filter\n        response = self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n        return DocumentsInfo(**response.json())\n\n    def add_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index.\n\n        Args:\n\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents(documents)\n        \"\"\"\n        if primary_key:\n            url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n        else:\n            url = self._documents_url\n\n        if self._pre_add_documents_plugins:\n            pre = Index._run_plugins(\n                self._pre_add_documents_plugins,\n                Event.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        response = self._http_requests.post(url, documents, compress=compress)\n        result = TaskInfo(**response.json())\n        if self._post_add_documents_plugins:\n            post = Index._run_plugins(self._post_add_documents_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def add_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n        Args:\n\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents_in_batches(documents)\n        \"\"\"\n        return [\n            self.add_documents(x, primary_key, compress=compress)\n            for x in _batch(documents, batch_size)\n        ]\n\n    def add_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(path, csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = _combine_documents(all_documents)\n\n            response = self.add_documents(combined, primary_key, compress=compress)\n\n            return [response]\n\n        responses = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                responses.append(self.add_documents(documents, primary_key, compress=compress))\n\n        _raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def add_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(path, csv_delimiter=csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = _combine_documents(all_documents)\n\n            return self.add_documents_in_batches(\n                combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n            )\n\n        responses: list[TaskInfo] = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                responses.extend(\n                    self.add_documents_in_batches(\n                        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n                    )\n                )\n\n        _raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def add_documents_from_file(\n        self, file_path: Path | str, primary_key: str | None = None, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents to the index from a json file.\n\n        Args:\n\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents_from_file(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(file_path)\n\n        return self.add_documents(documents, primary_key=primary_key, compress=compress)\n\n    def add_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(file_path, csv_delimiter)\n\n        return self.add_documents_in_batches(\n            documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    def add_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        *,\n        csv_delimiter: str | None = None,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.add_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n        if not upload_path.exists():\n            raise MeilisearchError(\"No file found at the specified path\")\n\n        if upload_path.suffix not in (\".csv\", \".ndjson\"):\n            raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n        if csv_delimiter and upload_path.suffix != \".csv\":\n            raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n        if (\n            csv_delimiter\n            and len(csv_delimiter) != 1\n            or csv_delimiter\n            and not csv_delimiter.isascii()\n        ):\n            raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n        content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n\n        if parameters:\n            url = _build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        with open(upload_path) as f:\n            data = f.read()\n\n        response = self._http_requests.post(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def update_documents(\n        self,\n        documents: Sequence[JsonMapping],\n        primary_key: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Update documents in the index.\n\n        Args:\n\n            documents: List of documents.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents(documents)\n        \"\"\"\n        if primary_key:\n            url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n        else:\n            url = self._documents_url\n\n        if self._pre_update_documents_plugins:\n            pre = Index._run_plugins(\n                self._pre_update_documents_plugins,\n                Event.PRE,\n                documents=documents,\n                primary_key=primary_key,\n            )\n            if pre.get(\"document_result\"):\n                documents = pre[\"document_result\"]\n\n        response = self._http_requests.put(url, documents, compress=compress)\n        result = TaskInfo(**response.json())\n        if self._post_update_documents_plugins:\n            post = Index._run_plugins(\n                self._post_update_documents_plugins, Event.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def update_documents_in_batches(\n        self,\n        documents: Sequence[JsonMapping],\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n        Each batch tries to fill the max_payload_size\n\n        Args:\n\n            documents: List of documents.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; documents = [\n            &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n            &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents_in_batches(documents)\n        \"\"\"\n        return [\n            self.update_documents(x, primary_key, compress=compress)\n            for x in _batch(documents, batch_size)\n        ]\n\n    def update_documents_from_directory(\n        self,\n        directory_path: Path | str,\n        *,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents_from_directory(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(path, csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = _combine_documents(all_documents)\n\n            response = self.update_documents(combined, primary_key, compress=compress)\n            return [response]\n\n        responses = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                responses.append(self.update_documents(documents, primary_key, compress=compress))\n\n        _raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def update_documents_from_directory_in_batches(\n        self,\n        directory_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        document_type: str = \"json\",\n        csv_delimiter: str | None = None,\n        combine_documents: bool = True,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Load all json files from a directory and update the documents.\n\n        Args:\n\n            directory_path: Path to the directory that contains the json files.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            document_type: The type of document being added. Accepted types are json, csv, and\n                ndjson. For csv files the first row of the document should be a header row contining\n                the field names, and ever for should have a title.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            combine_documents: If set to True this will combine the documents from all the files\n                before indexing them. Defaults to True.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents_from_directory_in_batches(directory_path)\n        \"\"\"\n        directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n        if combine_documents:\n            all_documents = []\n            for path in directory.iterdir():\n                if path.suffix == f\".{document_type}\":\n                    documents = _load_documents_from_file(path, csv_delimiter)\n                    all_documents.append(documents)\n\n            _raise_on_no_documents(all_documents, document_type, directory_path)\n\n            combined = _combine_documents(all_documents)\n\n            return self.update_documents_in_batches(\n                combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n            )\n\n        responses: list[TaskInfo] = []\n\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                responses.extend(\n                    self.update_documents_in_batches(\n                        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n                    )\n                )\n\n        _raise_on_no_documents(responses, document_type, directory_path)\n\n        return responses\n\n    def update_documents_from_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Add documents in the index from a json file.\n\n        Args:\n\n            file_path: Path to the json file.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents_from_file(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(file_path, csv_delimiter)\n\n        return self.update_documents(documents, primary_key=primary_key, compress=compress)\n\n    def update_documents_from_file_in_batches(\n        self,\n        file_path: Path | str,\n        *,\n        batch_size: int = 1000,\n        primary_key: str | None = None,\n        compress: bool = False,\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n        Args:\n\n            file_path: Path to the json file.\n            batch_size: The number of documents that should be included in each batch.\n                Defaults to 1000.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents_from_file_in_batches(file_path)\n        \"\"\"\n        documents = _load_documents_from_file(file_path)\n\n        return self.update_documents_in_batches(\n            documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    def update_documents_from_raw_file(\n        self,\n        file_path: Path | str,\n        primary_key: str | None = None,\n        csv_delimiter: str | None = None,\n        *,\n        compress: bool = False,\n    ) -&gt; TaskInfo:\n        \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n        The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n        for batching.\n\n        Args:\n\n            file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n                allowed.\n            primary_key: The primary key of the documents. This will be ignored if already set.\n                Defaults to None.\n            csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n                can only be used if the file is a csv file. Defaults to comma.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n                a non-csv file.\n            MeilisearchError: If the file path is not valid\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_documents_from_raw_file(file_path)\n        \"\"\"\n        upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n        if not upload_path.exists():\n            raise MeilisearchError(\"No file found at the specified path\")\n\n        if upload_path.suffix not in (\".csv\", \".ndjson\"):\n            raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n        if csv_delimiter and upload_path.suffix != \".csv\":\n            raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n        if (\n            csv_delimiter\n            and len(csv_delimiter) != 1\n            or csv_delimiter\n            and not csv_delimiter.isascii()\n        ):\n            raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n        content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n        parameters = {}\n\n        if primary_key:\n            parameters[\"primaryKey\"] = primary_key\n        if csv_delimiter:\n            parameters[\"csvDelimiter\"] = csv_delimiter\n\n        if parameters:\n            url = _build_encoded_url(self._documents_url, parameters)\n        else:\n            url = self._documents_url\n\n        with open(upload_path) as f:\n            data = f.read()\n\n        response = self._http_requests.put(\n            url, body=data, content_type=content_type, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def delete_document(self, document_id: str) -&gt; TaskInfo:\n        \"\"\"Delete one document from the index.\n\n        Args:\n\n            document_id: Unique identifier of the document.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete_document(\"1234\")\n        \"\"\"\n        if self._pre_delete_document_plugins:\n            Index._run_plugins(\n                self._pre_delete_document_plugins, Event.PRE, document_id=document_id\n            )\n\n        response = self._http_requests.delete(f\"{self._documents_url}/{document_id}\")\n        result = TaskInfo(**response.json())\n        if self._post_delete_document_plugins:\n            post = Index._run_plugins(self._post_delete_document_plugins, Event.POST, result=result)\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def delete_documents(self, ids: list[str]) -&gt; TaskInfo:\n        \"\"\"Delete multiple documents from the index.\n\n        Args:\n\n            ids: List of unique identifiers of documents.\n\n        Returns:\n\n            List of update ids to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete_documents([\"1234\", \"5678\"])\n        \"\"\"\n        if self._pre_delete_documents_plugins:\n            Index._run_plugins(self._pre_delete_documents_plugins, Event.PRE, ids=ids)\n\n        response = self._http_requests.post(f\"{self._documents_url}/delete-batch\", ids)\n        result = TaskInfo(**response.json())\n        if self._post_delete_documents_plugins:\n            post = Index._run_plugins(\n                self._post_delete_documents_plugins, Event.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def delete_documents_by_filter(self, filter: Filter) -&gt; TaskInfo:\n        \"\"\"Delete documents from the index by filter.\n\n        Args:\n\n            filter: The filter value information.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete_documents_by_filter(\"genre=horor\"))\n        \"\"\"\n        if self._pre_delete_documents_by_filter_plugins:\n            Index._run_plugins(\n                self._pre_delete_documents_by_filter_plugins, Event.PRE, filter=filter\n            )\n\n        response = self._http_requests.post(\n            f\"{self._documents_url}/delete\", body={\"filter\": filter}\n        )\n        result = TaskInfo(**response.json())\n        if self._post_delete_documents_by_filter_plugins:\n            post = Index._run_plugins(\n                self._post_delete_documents_by_filter_plugins, Event.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def delete_documents_in_batches_by_filter(\n        self, filters: list[str | list[str | list[str]]]\n    ) -&gt; list[TaskInfo]:\n        \"\"\"Delete batches of documents from the index by filter.\n\n        Args:\n\n            filters: A list of filter value information.\n\n        Returns:\n\n            The a list of details of the task statuses.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete_documents_in_batches_by_filter(\n            &gt;&gt;&gt;     [\n            &gt;&gt;&gt;         \"genre=horor\"),\n            &gt;&gt;&gt;         \"release_date=1520035200\"),\n            &gt;&gt;&gt;     ]\n            &gt;&gt;&gt; )\n        \"\"\"\n        return [self.delete_documents_by_filter(filter) for filter in filters]\n\n    def delete_all_documents(self) -&gt; TaskInfo:\n        \"\"\"Delete all documents from the index.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.delete_all_document()\n        \"\"\"\n        if self._pre_delete_all_documents_plugins:\n            Index._run_plugins(self._pre_delete_all_documents_plugins, Event.PRE)\n\n        response = self._http_requests.delete(self._documents_url)\n        result = TaskInfo(**response.json())\n        if self._post_delete_all_documents_plugins:\n            post = Index._run_plugins(\n                self._post_delete_all_documents_plugins, Event.POST, result=result\n            )\n            if isinstance(post.get(\"generic_result\"), TaskInfo):\n                result = post[\"generic_result\"]\n\n        return result\n\n    def get_settings(self) -&gt; MeilisearchSettings:\n        \"\"\"Get settings of the index.\n\n        Returns:\n\n            Settings of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; settings = index.get_settings()\n        \"\"\"\n        response = self._http_requests.get(self._settings_url)\n        response_json = response.json()\n        settings = MeilisearchSettings(**response_json)\n\n        if response_json.get(\"embedders\"):\n            settings.embedders = _embedder_json_to_settings_model(response_json[\"embedders\"])\n\n        return settings\n\n    def update_settings(self, body: MeilisearchSettings, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update settings of the index.\n\n        Args:\n\n            body: Settings of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n            &gt;&gt;&gt; new_settings = MeilisearchSettings(\n            &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n            &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n            &gt;&gt;&gt;     ranking_rules=[\n            &gt;&gt;&gt;         \"words\",\n            &gt;&gt;&gt;         \"typo\",\n            &gt;&gt;&gt;         \"proximity\",\n            &gt;&gt;&gt;         \"attribute\",\n            &gt;&gt;&gt;         \"sort\",\n            &gt;&gt;&gt;         \"exactness\",\n            &gt;&gt;&gt;         \"release_date:desc\",\n            &gt;&gt;&gt;         \"rank:desc\",\n            &gt;&gt;&gt;    ],\n            &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n            &gt;&gt;&gt;    distinct_attribute=\"url\",\n            &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n            &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n            &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n            &gt;&gt;&gt; )\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_settings(new_settings)\n        \"\"\"\n        if is_pydantic_2():\n            body_dict = {k: v for k, v in body.model_dump(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            body_dict = {k: v for k, v in body.dict(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n\n        response = self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n        return TaskInfo(**response.json())\n\n    def reset_settings(self) -&gt; TaskInfo:\n        \"\"\"Reset settings of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_settings()\n        \"\"\"\n        response = self._http_requests.delete(self._settings_url)\n\n        return TaskInfo(**response.json())\n\n    def get_ranking_rules(self) -&gt; list[str]:\n        \"\"\"Get ranking rules of the index.\n\n        Returns:\n\n            List containing the ranking rules of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; ranking_rules = index.get_ranking_rules()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n        return response.json()\n\n    def update_ranking_rules(self, ranking_rules: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update ranking rules of the index.\n\n        Args:\n\n            ranking_rules: List containing the ranking rules.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; ranking_rules=[\n            &gt;&gt;&gt;      \"words\",\n            &gt;&gt;&gt;      \"typo\",\n            &gt;&gt;&gt;      \"proximity\",\n            &gt;&gt;&gt;      \"attribute\",\n            &gt;&gt;&gt;      \"sort\",\n            &gt;&gt;&gt;      \"exactness\",\n            &gt;&gt;&gt;      \"release_date:desc\",\n            &gt;&gt;&gt;      \"rank:desc\",\n            &gt;&gt;&gt; ],\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_ranking_rules(ranking_rules)\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_ranking_rules(self) -&gt; TaskInfo:\n        \"\"\"Reset ranking rules of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_ranking_rules()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n        return TaskInfo(**response.json())\n\n    def get_distinct_attribute(self) -&gt; str | None:\n        \"\"\"Get distinct attribute of the index.\n\n        Returns:\n\n            String containing the distinct attribute of the index. If no distinct attribute\n                `None` is returned.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; distinct_attribute = index.get_distinct_attribute()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n        if not response.json():\n            None\n\n        return response.json()\n\n    def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update distinct attribute of the index.\n\n        Args:\n\n            body: Distinct attribute.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_distinct_attribute(\"url\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_distinct_attribute(self) -&gt; TaskInfo:\n        \"\"\"Reset distinct attribute of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_distinct_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n        return TaskInfo(**response.json())\n\n    def get_searchable_attributes(self) -&gt; list[str]:\n        \"\"\"Get searchable attributes of the index.\n\n        Returns:\n\n            List containing the searchable attributes of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; searchable_attributes = index.get_searchable_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n        return response.json()\n\n    def update_searchable_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update searchable attributes of the index.\n\n        Args:\n\n            body: List containing the searchable attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_searchable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset searchable attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_searchable_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n        return TaskInfo(**response.json())\n\n    def get_displayed_attributes(self) -&gt; list[str]:\n        \"\"\"Get displayed attributes of the index.\n\n        Returns:\n\n            List containing the displayed attributes of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; displayed_attributes = index.get_displayed_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n        return response.json()\n\n    def update_displayed_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update displayed attributes of the index.\n\n        Args:\n\n            body: List containing the displayed attributes.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_displayed_attributes(\n            &gt;&gt;&gt;     [\"title\", \"description\", \"genre\", \"release_date\"]\n            &gt;&gt;&gt; )\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_displayed_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset displayed attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_displayed_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n        return TaskInfo(**response.json())\n\n    def get_stop_words(self) -&gt; list[str] | None:\n        \"\"\"Get stop words of the index.\n\n        Returns:\n\n            List containing the stop words of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; stop_words = index.get_stop_words()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n        if not response.json():\n            return None\n\n        return response.json()\n\n    def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update stop words of the index.\n\n        Args:\n\n            body: List containing the stop words of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_stop_words([\"the\", \"a\", \"an\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/stop-words\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_stop_words(self) -&gt; TaskInfo:\n        \"\"\"Reset stop words of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_stop_words()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n        return TaskInfo(**response.json())\n\n    def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n        \"\"\"Get synonyms of the index.\n\n        Returns:\n\n            The synonyms of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; synonyms = index.get_synonyms()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n        if not response.json():\n            return None\n\n        return response.json()\n\n    def update_synonyms(self, body: dict[str, list[str]], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update synonyms of the index.\n\n        Args:\n\n            body: The synonyms of the index.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_synonyms(\n            &gt;&gt;&gt;     {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n            &gt;&gt;&gt; )\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/synonyms\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_synonyms(self) -&gt; TaskInfo:\n        \"\"\"Reset synonyms of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_synonyms()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n        return TaskInfo(**response.json())\n\n    def get_filterable_attributes(self) -&gt; list[str] | None:\n        \"\"\"Get filterable attributes of the index.\n\n        Returns:\n\n            List containing the filterable attributes of the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; filterable_attributes = index.get_filterable_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n        if not response.json():\n            return None\n\n        return response.json()\n\n    def update_filterable_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update filterable attributes of the index.\n\n        Args:\n\n            body: List containing the filterable attributes of the index.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_filterable_attributes([\"genre\", \"director\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/filterable-attributes\", body, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_filterable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset filterable attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_filterable_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n        return TaskInfo(**response.json())\n\n    def get_sortable_attributes(self) -&gt; list[str]:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Returns:\n\n            List containing the sortable attributes of the AsyncIndex.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; sortable_attributes = index.get_sortable_attributes()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n        return response.json()\n\n    def update_sortable_attributes(\n        self, sortable_attributes: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Get sortable attributes of the AsyncIndex.\n\n        Args:\n\n            sortable_attributes: List of attributes for searching.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_sortable_attributes([\"title\", \"release_date\"])\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_sortable_attributes(self) -&gt; TaskInfo:\n        \"\"\"Reset sortable attributes of the index to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_sortable_attributes()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n        return TaskInfo(**response.json())\n\n    def get_typo_tolerance(self) -&gt; TypoTolerance:\n        \"\"\"Get typo tolerance for the index.\n\n        Returns:\n\n            TypoTolerance for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; sortable_attributes = index.get_typo_tolerance()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n        return TypoTolerance(**response.json())\n\n    def update_typo_tolerance(\n        self, typo_tolerance: TypoTolerance, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update typo tolerance.\n\n        Args:\n\n            typo_tolerance: Typo tolerance settings.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; TypoTolerance(enabled=False)\n            &gt;&gt;&gt; index.update_typo_tolerance()\n        \"\"\"\n        if is_pydantic_2():\n            response = self._http_requests.patch(\n                f\"{self._settings_url}/typo-tolerance\",\n                typo_tolerance.model_dump(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = self._http_requests.patch(\n                f\"{self._settings_url}/typo-tolerance\",\n                typo_tolerance.dict(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n\n        return TaskInfo(**response.json())\n\n    def reset_typo_tolerance(self) -&gt; TaskInfo:\n        \"\"\"Reset typo tolerance to default values.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_typo_tolerance()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n        return TaskInfo(**response.json())\n\n    def get_faceting(self) -&gt; Faceting:\n        \"\"\"Get faceting for the index.\n\n        Returns:\n\n            Faceting for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; faceting = index.get_faceting()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n        return Faceting(**response.json())\n\n    def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the faceting settings for an index.\n\n        Args:\n\n            faceting: Faceting values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n        \"\"\"\n        if is_pydantic_2():\n            response = self._http_requests.patch(\n                f\"{self._settings_url}/faceting\",\n                faceting.model_dump(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = self._http_requests.patch(\n                f\"{self._settings_url}/faceting\", faceting.dict(by_alias=True), compress=compress\n            )  # type: ignore[attr-defined]\n\n        return TaskInfo(**response.json())\n\n    def reset_faceting(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's faceting settings to their default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_faceting()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n        return TaskInfo(**response.json())\n\n    def get_pagination(self) -&gt; Pagination:\n        \"\"\"Get pagination settings for the index.\n\n        Returns:\n\n            Pagination for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; pagination_settings = index.get_pagination()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n        return Pagination(**response.json())\n\n    def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Partially update the pagination settings for an index.\n\n        Args:\n\n            settings: settings for pagination.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_pagination(settings=Pagination(max_total_hits=123))\n        \"\"\"\n        if is_pydantic_2():\n            response = self._http_requests.patch(\n                f\"{self._settings_url}/pagination\",\n                settings.model_dump(by_alias=True),\n                compress=compress,\n            )  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            response = self._http_requests.patch(\n                f\"{self._settings_url}/pagination\", settings.dict(by_alias=True), compress=compress\n            )  # type: ignore[attr-defined]\n\n        return TaskInfo(**response.json())\n\n    def reset_pagination(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's pagination settings to their default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_pagination()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n        return TaskInfo(**response.json())\n\n    def get_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get separator token settings for the index.\n\n        Returns:\n\n            Separator tokens for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; separator_token_settings = index.get_separator_tokens()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n        return response.json()\n\n    def update_separator_tokens(\n        self, separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the separator tokens settings for an index.\n\n        Args:\n\n            separator_tokens: List of separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's separator tokens settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_separator_tokens()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n        return TaskInfo(**response.json())\n\n    def get_non_separator_tokens(self) -&gt; list[str]:\n        \"\"\"Get non-separator token settings for the index.\n\n        Returns:\n\n            Non-separator tokens for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; non_separator_token_settings = index.get_non_separator_tokens()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n        return response.json()\n\n    def update_non_separator_tokens(\n        self, non_separator_tokens: list[str], *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the non-separator tokens settings for an index.\n\n        Args:\n\n            non_separator_tokens: List of non-separator tokens.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_non_separator_tokens(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_non_separator_tokens()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n        return TaskInfo(**response.json())\n\n    def get_word_dictionary(self) -&gt; list[str]:\n        \"\"\"Get word dictionary settings for the index.\n\n        Returns:\n\n            Word dictionary for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; word_dictionary = index.get_word_dictionary()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n        return response.json()\n\n    def update_word_dictionary(self, dictionary: list[str], *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the word dictionary settings for an index.\n\n        Args:\n\n            dictionary: List of dictionary values.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_word_dictionary(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's word dictionary settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_word_dictionary()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n        return TaskInfo(**response.json())\n\n    def get_proximity_precision(self) -&gt; ProximityPrecision:\n        \"\"\"Get proximity precision settings for the index.\n\n        Returns:\n\n            Proximity precision for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; proximity_precision = index.get_proximity_precision()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n        return ProximityPrecision[to_snake(response.json()).upper()]\n\n    def update_proximity_precision(\n        self, proximity_precision: ProximityPrecision, *, compress: bool = False\n    ) -&gt; TaskInfo:\n        \"\"\"Update the proximity precision settings for an index.\n\n        Args:\n\n            proximity_precision: The proximity precision value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n        \"\"\"\n        response = self._http_requests.put(\n            f\"{self._settings_url}/proximity-precision\",\n            proximity_precision.value,\n            compress=compress,\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_proximity_precision(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's proximity precision settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_proximity_precision()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n        return TaskInfo(**response.json())\n\n    def get_embedders(self) -&gt; Embedders | None:\n        \"\"\"Get embedder settings for the index.\n\n        Returns:\n\n            Embedders for the index.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; embedders = await index.get_embedders()\n        \"\"\"\n        response = self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n        return _embedder_json_to_embedders_model(response.json())\n\n    def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n        \"\"\"Update the embedders settings for an index.\n\n        Args:\n\n            embedders: The embedders value.\n            compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n        Returns:\n\n            Task to track the action.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_python_sdk import Client\n            &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n            &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.update_embedders(\n            &gt;&gt;&gt;     Embedders(embedders={dimensions=512)})\n            &gt;&gt;&gt; )\n        \"\"\"\n        payload = {}\n        for key, embedder in embedders.embedders.items():\n            if is_pydantic_2():\n                payload[key] = {\n                    k: v for k, v in embedder.model_dump(by_alias=True).items() if v is not None\n                }  # type: ignore[attr-defined]\n            else:  # pragma: no cover\n                warn(\n                    \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                    DeprecationWarning,\n                )\n                payload[key] = {\n                    k: v for k, v in embedder.dict(by_alias=True).items() if v is not None\n                }  # type: ignore[attr-defined]\n\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/embedders\", payload, compress=compress\n        )\n\n        return TaskInfo(**response.json())\n\n    def reset_embedders(self) -&gt; TaskInfo:\n        \"\"\"Reset an index's embedders settings to the default value.\n\n        Returns:\n\n            The details of the task status.\n\n        Raises:\n\n            MeilisearchCommunicationError: If there was an error communicating with the server.\n            MeilisearchApiError: If the Meilisearch API returned an error.\n\n        Examples:\n\n            &gt;&gt;&gt; from meilisearch_async_client import Client\n            &gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n            &gt;&gt;&gt; index = client.index(\"movies\")\n            &gt;&gt;&gt; index.reset_embedders()\n        \"\"\"\n        response = self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n        return TaskInfo(**response.json())\n\n    @staticmethod\n    def _run_plugins(\n        plugins: Sequence[Plugin | DocumentPlugin | PostSearchPlugin],\n        event: Event,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        results: dict[str, Any] = {\n            \"generic_result\": None,\n            \"document_result\": None,\n            \"search_result\": None,\n        }\n        generic_tasks = []\n        document_tasks = []\n        search_tasks = []\n        for plugin in plugins:\n            if _plugin_has_method(plugin, \"run_plugin\"):\n                generic_tasks.append(plugin.run_plugin(event=event, **kwargs))  # type: ignore[union-attr]\n            if _plugin_has_method(plugin, \"run_document_plugin\"):\n                document_tasks.append(\n                    plugin.run_document_plugin(event=event, **kwargs)  # type: ignore[union-attr]\n                )\n            if _plugin_has_method(plugin, \"run_post_search_plugin\"):\n                search_tasks.append(\n                    plugin.run_post_search_plugin(event=event, **kwargs)  # type: ignore[union-attr]\n                )\n\n        if generic_tasks:\n            for result in reversed(generic_tasks):\n                if result:\n                    results[\"generic_result\"] = result\n                    break\n\n        if document_tasks:\n            results[\"document_result\"] = document_tasks[-1]\n\n        if search_tasks:\n            results[\"search_result\"] = search_tasks[-1]\n\n        return results\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.__init__","title":"<code>__init__(http_client, uid, primary_key=None, created_at=None, updated_at=None, plugins=None)</code>","text":"<p>Class initializer.</p> <p>Args:</p> <pre><code>http_client: An instance of the Client. This automatically gets passed by the\n    Client when creating and Index instance.\nuid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\ncreated_at: The date and time the index was created. Defaults to None.\nupdated_at: The date and time the index was last updated. Defaults to None.\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def __init__(\n    self,\n    http_client: Client,\n    uid: str,\n    primary_key: str | None = None,\n    created_at: str | datetime | None = None,\n    updated_at: str | datetime | None = None,\n    plugins: IndexPlugins | None = None,\n):\n    \"\"\"Class initializer.\n\n    Args:\n\n        http_client: An instance of the Client. This automatically gets passed by the\n            Client when creating and Index instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        created_at: The date and time the index was created. Defaults to None.\n        updated_at: The date and time the index was last updated. Defaults to None.\n        plugins: Optional plugins can be provided to extend functionality.\n    \"\"\"\n    super().__init__(uid, primary_key, created_at, updated_at)\n    self.http_client = http_client\n    self._http_requests = HttpRequests(http_client)\n    self.plugins = plugins\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents","title":"<code>add_documents(documents, primary_key=None, *, compress=False)</code>","text":"<p>Add documents to the index.</p> <p>Args:</p> <pre><code>documents: List of documents.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index.\n\n    Args:\n\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents(documents)\n    \"\"\"\n    if primary_key:\n        url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n    else:\n        url = self._documents_url\n\n    if self._pre_add_documents_plugins:\n        pre = Index._run_plugins(\n            self._pre_add_documents_plugins,\n            Event.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    response = self._http_requests.post(url, documents, compress=compress)\n    result = TaskInfo(**response.json())\n    if self._post_add_documents_plugins:\n        post = Index._run_plugins(self._post_add_documents_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_directory","title":"<code>add_documents_from_directory(directory_path, *, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>","text":"<p>Load all json files from a directory and add the documents to the index.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents_from_directory(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = _combine_documents(all_documents)\n\n        response = self.add_documents(combined, primary_key, compress=compress)\n\n        return [response]\n\n    responses = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(path, csv_delimiter)\n            responses.append(self.add_documents(documents, primary_key, compress=compress))\n\n    _raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_directory_in_batches","title":"<code>add_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>","text":"<p>Load all json files from a directory and add the documents to the index in batches.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents_from_directory_in_batches(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and add the documents to the index in batches.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter=csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = _combine_documents(all_documents)\n\n        return self.add_documents_in_batches(\n            combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    responses: list[TaskInfo] = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(path, csv_delimiter)\n            responses.extend(\n                self.add_documents_in_batches(\n                    documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n                )\n            )\n\n    _raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_file","title":"<code>add_documents_from_file(file_path, primary_key=None, *, compress=False)</code>","text":"<p>Add documents to the index from a json file.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents_from_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents_from_file(\n    self, file_path: Path | str, primary_key: str | None = None, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Add documents to the index from a json file.\n\n    Args:\n\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents_from_file(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(file_path)\n\n    return self.add_documents(documents, primary_key=primary_key, compress=compress)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_file_in_batches","title":"<code>add_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, csv_delimiter=None, compress=False)</code>","text":"<p>Adds documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents_from_file_in_batches(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(file_path, csv_delimiter)\n\n    return self.add_documents_in_batches(\n        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_from_raw_file","title":"<code>add_documents_from_raw_file(file_path, primary_key=None, *, csv_delimiter=None, compress=False)</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Args:</p> <pre><code>file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n    allowed.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n    a non-csv file.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents_from_raw_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    *,\n    csv_delimiter: str | None = None,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n    if not upload_path.exists():\n        raise MeilisearchError(\"No file found at the specified path\")\n\n    if upload_path.suffix not in (\".csv\", \".ndjson\"):\n        raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n    if csv_delimiter and upload_path.suffix != \".csv\":\n        raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n    if (\n        csv_delimiter\n        and len(csv_delimiter) != 1\n        or csv_delimiter\n        and not csv_delimiter.isascii()\n    ):\n        raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n    content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n\n    if parameters:\n        url = _build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    with open(upload_path) as f:\n        data = f.read()\n\n    response = self._http_requests.post(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.add_documents_in_batches","title":"<code>add_documents_in_batches(documents, *, batch_size=1000, primary_key=None, compress=False)</code>","text":"<p>Adds documents in batches to reduce RAM usage with indexing.</p> <p>Args:</p> <pre><code>documents: List of documents.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; &gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.add_documents_in_batches(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def add_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Adds documents in batches to reduce RAM usage with indexing.\n\n    Args:\n\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.add_documents_in_batches(documents)\n    \"\"\"\n    return [\n        self.add_documents(x, primary_key, compress=compress)\n        for x in _batch(documents, batch_size)\n    ]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.create","title":"<code>create(http_client, uid, primary_key=None, *, settings=None, wait=True, plugins=None)</code>  <code>classmethod</code>","text":"<p>Creates a new index.</p> <p>In general this method should not be used directly and instead the index should be created through the <code>Client</code>.</p> <p>Args:</p> <pre><code>http_client: An instance of the Client. This automatically gets passed by the Client\n    when creating an Index instance.\nuid: The index's unique identifier.\nprimary_key: The primary key of the documents. Defaults to None.\nsettings: Settings for the index. The settings can also be updated independently of\n    creating the index. The advantage to updating them here is updating the settings after\n    adding documents will cause the documents to be re-indexed. Because of this it will be\n    faster to update them before adding documents. Defaults to None (i.e. default\n    Meilisearch index settings).\nwait: If set to True and settings are being updated, the index will be returned after\n    the settings update has completed. If False it will not wait for settings to complete.\n    Default: True\nplugins: Optional plugins can be provided to extend functionality.\n</code></pre> <p>Returns:</p> <pre><code>An instance of Index containing the information of the newly created index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = index.create(client, \"movies\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    http_client: Client,\n    uid: str,\n    primary_key: str | None = None,\n    *,\n    settings: MeilisearchSettings | None = None,\n    wait: bool = True,\n    plugins: IndexPlugins | None = None,\n) -&gt; Index:\n    \"\"\"Creates a new index.\n\n    In general this method should not be used directly and instead the index should be created\n    through the `Client`.\n\n    Args:\n\n        http_client: An instance of the Client. This automatically gets passed by the Client\n            when creating an Index instance.\n        uid: The index's unique identifier.\n        primary_key: The primary key of the documents. Defaults to None.\n        settings: Settings for the index. The settings can also be updated independently of\n            creating the index. The advantage to updating them here is updating the settings after\n            adding documents will cause the documents to be re-indexed. Because of this it will be\n            faster to update them before adding documents. Defaults to None (i.e. default\n            Meilisearch index settings).\n        wait: If set to True and settings are being updated, the index will be returned after\n            the settings update has completed. If False it will not wait for settings to complete.\n            Default: True\n        plugins: Optional plugins can be provided to extend functionality.\n\n    Returns:\n\n        An instance of Index containing the information of the newly created index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = index.create(client, \"movies\")\n    \"\"\"\n    if not primary_key:\n        payload = {\"uid\": uid}\n    else:\n        payload = {\"primaryKey\": primary_key, \"uid\": uid}\n\n    url = \"indexes\"\n    http_request = HttpRequests(http_client)\n    response = http_request.post(url, payload)\n    wait_for_task(http_client, response.json()[\"taskUid\"], timeout_in_ms=None)\n    index_response = http_request.get(f\"{url}/{uid}\")\n    index_dict = index_response.json()\n    index = cls(\n        http_client=http_client,\n        uid=index_dict[\"uid\"],\n        primary_key=index_dict[\"primaryKey\"],\n        created_at=index_dict[\"createdAt\"],\n        updated_at=index_dict[\"updatedAt\"],\n        plugins=plugins,\n    )\n\n    if settings:\n        settings_task = index.update_settings(settings)\n        if wait:\n            wait_for_task(http_client, settings_task.task_uid, timeout_in_ms=None)\n\n    return index\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete","title":"<code>delete()</code>","text":"<p>Deletes the index.</p> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete(self) -&gt; TaskInfo:\n    \"\"\"Deletes the index.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete()\n    \"\"\"\n    response = self._http_requests.delete(self._base_url_with_uid)\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_all_documents","title":"<code>delete_all_documents()</code>","text":"<p>Delete all documents from the index.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete_all_document()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete_all_documents(self) -&gt; TaskInfo:\n    \"\"\"Delete all documents from the index.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete_all_document()\n    \"\"\"\n    if self._pre_delete_all_documents_plugins:\n        Index._run_plugins(self._pre_delete_all_documents_plugins, Event.PRE)\n\n    response = self._http_requests.delete(self._documents_url)\n    result = TaskInfo(**response.json())\n    if self._post_delete_all_documents_plugins:\n        post = Index._run_plugins(\n            self._post_delete_all_documents_plugins, Event.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_document","title":"<code>delete_document(document_id)</code>","text":"<p>Delete one document from the index.</p> <p>Args:</p> <pre><code>document_id: Unique identifier of the document.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete_document(\"1234\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete_document(self, document_id: str) -&gt; TaskInfo:\n    \"\"\"Delete one document from the index.\n\n    Args:\n\n        document_id: Unique identifier of the document.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete_document(\"1234\")\n    \"\"\"\n    if self._pre_delete_document_plugins:\n        Index._run_plugins(\n            self._pre_delete_document_plugins, Event.PRE, document_id=document_id\n        )\n\n    response = self._http_requests.delete(f\"{self._documents_url}/{document_id}\")\n    result = TaskInfo(**response.json())\n    if self._post_delete_document_plugins:\n        post = Index._run_plugins(self._post_delete_document_plugins, Event.POST, result=result)\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_documents","title":"<code>delete_documents(ids)</code>","text":"<p>Delete multiple documents from the index.</p> <p>Args:</p> <pre><code>ids: List of unique identifiers of documents.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete_documents([\"1234\", \"5678\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete_documents(self, ids: list[str]) -&gt; TaskInfo:\n    \"\"\"Delete multiple documents from the index.\n\n    Args:\n\n        ids: List of unique identifiers of documents.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete_documents([\"1234\", \"5678\"])\n    \"\"\"\n    if self._pre_delete_documents_plugins:\n        Index._run_plugins(self._pre_delete_documents_plugins, Event.PRE, ids=ids)\n\n    response = self._http_requests.post(f\"{self._documents_url}/delete-batch\", ids)\n    result = TaskInfo(**response.json())\n    if self._post_delete_documents_plugins:\n        post = Index._run_plugins(\n            self._post_delete_documents_plugins, Event.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_documents_by_filter","title":"<code>delete_documents_by_filter(filter)</code>","text":"<p>Delete documents from the index by filter.</p> <p>Args:</p> <pre><code>filter: The filter value information.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete_documents_by_filter(\"genre=horor\"))\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete_documents_by_filter(self, filter: Filter) -&gt; TaskInfo:\n    \"\"\"Delete documents from the index by filter.\n\n    Args:\n\n        filter: The filter value information.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete_documents_by_filter(\"genre=horor\"))\n    \"\"\"\n    if self._pre_delete_documents_by_filter_plugins:\n        Index._run_plugins(\n            self._pre_delete_documents_by_filter_plugins, Event.PRE, filter=filter\n        )\n\n    response = self._http_requests.post(\n        f\"{self._documents_url}/delete\", body={\"filter\": filter}\n    )\n    result = TaskInfo(**response.json())\n    if self._post_delete_documents_by_filter_plugins:\n        post = Index._run_plugins(\n            self._post_delete_documents_by_filter_plugins, Event.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_documents_in_batches_by_filter","title":"<code>delete_documents_in_batches_by_filter(filters)</code>","text":"<p>Delete batches of documents from the index by filter.</p> <p>Args:</p> <pre><code>filters: A list of filter value information.\n</code></pre> <p>Returns:</p> <pre><code>The a list of details of the task statuses.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete_documents_in_batches_by_filter(\n&gt;&gt;&gt;     [\n&gt;&gt;&gt;         \"genre=horor\"),\n&gt;&gt;&gt;         \"release_date=1520035200\"),\n&gt;&gt;&gt;     ]\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete_documents_in_batches_by_filter(\n    self, filters: list[str | list[str | list[str]]]\n) -&gt; list[TaskInfo]:\n    \"\"\"Delete batches of documents from the index by filter.\n\n    Args:\n\n        filters: A list of filter value information.\n\n    Returns:\n\n        The a list of details of the task statuses.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete_documents_in_batches_by_filter(\n        &gt;&gt;&gt;     [\n        &gt;&gt;&gt;         \"genre=horor\"),\n        &gt;&gt;&gt;         \"release_date=1520035200\"),\n        &gt;&gt;&gt;     ]\n        &gt;&gt;&gt; )\n    \"\"\"\n    return [self.delete_documents_by_filter(filter) for filter in filters]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.delete_if_exists","title":"<code>delete_if_exists()</code>","text":"<p>Delete the index if it already exists.</p> <p>Returns:</p> <pre><code>True if the index was deleted or False if not.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.delete_if_exists()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def delete_if_exists(self) -&gt; bool:\n    \"\"\"Delete the index if it already exists.\n\n    Returns:\n\n        True if the index was deleted or False if not.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.delete_if_exists()\n    \"\"\"\n    response = self.delete()\n    status = wait_for_task(self.http_client, response.task_uid, timeout_in_ms=100000)\n    if status.status == \"succeeded\":\n        return True\n\n    return False\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.facet_search","title":"<code>facet_search(query=None, *, facet_name, facet_query, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=['*'], attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='all', hits_per_page=None, page=None, attributes_to_search_on=None, show_ranking_score=False, show_ranking_score_details=False, vector=None)</code>","text":"<p>Search the index.</p> <p>Args:</p> <pre><code>query: String containing the word(s) to search\nfacet_name: The name of the facet to search\nfacet_query: The facet search value\noffset: Number of documents to skip. Defaults to 0.\nlimit: Maximum number of documents returned. Defaults to 20.\nfilter: Filter queries by an attribute value. Defaults to None.\nfacets: Facets for which to retrieve the matching count. Defaults to None.\nattributes_to_retrieve: Attributes to display in the returned documents.\n    Defaults to [\"*\"].\nattributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\ncrop_length: The maximun number of words to display. Defaults to 200.\nattributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n    Defaults to None.\nsort: Attributes by which to sort the results. Defaults to None.\nshow_matches_position: Defines whether an object that contains information about the matches should be\n    returned or not. Defaults to False.\nhighlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\nhighlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\ncrop_marker: Marker to display when the number of words excedes the `crop_length`.\n    Defaults to ...\nmatching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\nhits_per_page: Sets the number of results returned per page.\npage: Sets the specific results page to fetch.\nattributes_to_search_on: List of field names. Allow search over a subset of searchable\n    attributes without modifying the index settings. Defaults to None.\nshow_ranking_score: If set to True the ranking score will be returned with each document\n    in the search. Defaults to False.\nshow_ranking_score_details: If set to True the ranking details will be returned with\n    each document in the search. Defaults to False. Note: This parameter can only be\n    used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n    to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n    sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n    Because this feature is experimental it may be removed or updated causing breaking\n    changes in this library without a major version bump so use with caution. This\n    feature became stable in Meiliseach v1.7.0.\nvector: List of vectors for vector search. Defaults to None. Note: This parameter can\n    only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n    In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n    feature by sending a PATCH request to /experimental-features with\n    { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n    updated causing breaking changes in this library without a major version bump so use\n    with caution.\n</code></pre> <p>Returns:</p> <pre><code>Results of the search\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; search_results = index.search(\n&gt;&gt;&gt;     \"Tron\",\n&gt;&gt;&gt;     facet_name=\"genre\",\n&gt;&gt;&gt;     facet_query=\"Sci-fi\"\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def facet_search(\n    self,\n    query: str | None = None,\n    *,\n    facet_name: str,\n    facet_query: str,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] = [\"*\"],\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: str = \"all\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    vector: list[float] | None = None,\n) -&gt; FacetSearchResults:\n    \"\"\"Search the index.\n\n    Args:\n\n        query: String containing the word(s) to search\n        facet_name: The name of the facet to search\n        facet_query: The facet search value\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximun number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the matches should be\n            returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words excedes the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n\n    Returns:\n\n        Results of the search\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; search_results = index.search(\n        &gt;&gt;&gt;     \"Tron\",\n        &gt;&gt;&gt;     facet_name=\"genre\",\n        &gt;&gt;&gt;     facet_query=\"Sci-fi\"\n        &gt;&gt;&gt; )\n    \"\"\"\n    body = _process_search_parameters(\n        q=query,\n        facet_name=facet_name,\n        facet_query=facet_query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        vector=vector,\n    )\n\n    if self._pre_facet_search_plugins:\n        Index._run_plugins(\n            self._pre_facet_search_plugins,\n            Event.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n        )\n\n    response = self._http_requests.post(f\"{self._base_url_with_uid}/facet-search\", body=body)\n    result = FacetSearchResults(**response.json())\n    if self._post_facet_search_plugins:\n        post = Index._run_plugins(self._post_facet_search_plugins, Event.POST, result=result)\n        if isinstance(post[\"generic_result\"], FacetSearchResults):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.fetch_info","title":"<code>fetch_info()</code>","text":"<p>Gets the infromation about the index.</p> <p>Returns:</p> <pre><code>An instance of the AsyncIndex containing the retrieved information.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index_info = index.fetch_info()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def fetch_info(self) -&gt; Index:\n    \"\"\"Gets the infromation about the index.\n\n    Returns:\n\n        An instance of the AsyncIndex containing the retrieved information.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index_info = index.fetch_info()\n    \"\"\"\n    response = self._http_requests.get(self._base_url_with_uid)\n    index_dict = response.json()\n    self._set_fetch_info(\n        index_dict[\"primaryKey\"], index_dict[\"createdAt\"], index_dict[\"updatedAt\"]\n    )\n    return self\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_displayed_attributes","title":"<code>get_displayed_attributes()</code>","text":"<p>Get displayed attributes of the index.</p> <p>Returns:</p> <pre><code>List containing the displayed attributes of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; displayed_attributes = index.get_displayed_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_displayed_attributes(self) -&gt; list[str]:\n    \"\"\"Get displayed attributes of the index.\n\n    Returns:\n\n        List containing the displayed attributes of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; displayed_attributes = index.get_displayed_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/displayed-attributes\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_distinct_attribute","title":"<code>get_distinct_attribute()</code>","text":"<p>Get distinct attribute of the index.</p> <p>Returns:</p> <pre><code>String containing the distinct attribute of the index. If no distinct attribute\n    `None` is returned.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; distinct_attribute = index.get_distinct_attribute()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_distinct_attribute(self) -&gt; str | None:\n    \"\"\"Get distinct attribute of the index.\n\n    Returns:\n\n        String containing the distinct attribute of the index. If no distinct attribute\n            `None` is returned.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; distinct_attribute = index.get_distinct_attribute()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/distinct-attribute\")\n\n    if not response.json():\n        None\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_document","title":"<code>get_document(document_id)</code>","text":"<p>Get one document with given document identifier.</p> <p>Args:</p> <pre><code>document_id: Unique identifier of the document.\n</code></pre> <p>Returns:</p> <pre><code>The document information\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; document = index.get_document(\"1234\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_document(self, document_id: str) -&gt; JsonDict:\n    \"\"\"Get one document with given document identifier.\n\n    Args:\n\n        document_id: Unique identifier of the document.\n\n    Returns:\n\n        The document information\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; document = index.get_document(\"1234\")\n    \"\"\"\n    response = self._http_requests.get(f\"{self._documents_url}/{document_id}\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_documents","title":"<code>get_documents(*, offset=0, limit=20, fields=None, filter=None)</code>","text":"<p>Get a batch documents from the index.</p> <p>Args:</p> <pre><code>offset: Number of documents to skip. Defaults to 0.\nlimit: Maximum number of documents returnedd. Defaults to 20.\nfields: Document attributes to show. If this value is None then all\n    attributes are retrieved. Defaults to None.\nfilter: Filter value information. Defaults to None. Note: This parameter can only be\n    used with Meilisearch &gt;= v1.2.0\n</code></pre> <p>Returns:</p> <pre><code>Documents info.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; documents = index.get_documents()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_documents(\n    self,\n    *,\n    offset: int = 0,\n    limit: int = 20,\n    fields: list[str] | None = None,\n    filter: Filter | None = None,\n) -&gt; DocumentsInfo:\n    \"\"\"Get a batch documents from the index.\n\n    Args:\n\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returnedd. Defaults to 20.\n        fields: Document attributes to show. If this value is None then all\n            attributes are retrieved. Defaults to None.\n        filter: Filter value information. Defaults to None. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.2.0\n\n    Returns:\n\n        Documents info.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; documents = index.get_documents()\n    \"\"\"\n    parameters: JsonDict = {\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    if not filter:\n        if fields:\n            parameters[\"fields\"] = \",\".join(fields)\n\n        url = _build_encoded_url(self._documents_url, parameters)\n        response = self._http_requests.get(url)\n\n        return DocumentsInfo(**response.json())\n\n    if fields:\n        parameters[\"fields\"] = fields\n\n    parameters[\"filter\"] = filter\n    response = self._http_requests.post(f\"{self._documents_url}/fetch\", body=parameters)\n\n    return DocumentsInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_embedders","title":"<code>get_embedders()</code>","text":"<p>Get embedder settings for the index.</p> <p>Returns:</p> <pre><code>Embedders for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; embedders = await index.get_embedders()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_embedders(self) -&gt; Embedders | None:\n    \"\"\"Get embedder settings for the index.\n\n    Returns:\n\n        Embedders for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; embedders = await index.get_embedders()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/embedders\")\n\n    return _embedder_json_to_embedders_model(response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_faceting","title":"<code>get_faceting()</code>","text":"<p>Get faceting for the index.</p> <p>Returns:</p> <pre><code>Faceting for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; faceting = index.get_faceting()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_faceting(self) -&gt; Faceting:\n    \"\"\"Get faceting for the index.\n\n    Returns:\n\n        Faceting for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; faceting = index.get_faceting()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/faceting\")\n\n    return Faceting(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_filterable_attributes","title":"<code>get_filterable_attributes()</code>","text":"<p>Get filterable attributes of the index.</p> <p>Returns:</p> <pre><code>List containing the filterable attributes of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; filterable_attributes = index.get_filterable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_filterable_attributes(self) -&gt; list[str] | None:\n    \"\"\"Get filterable attributes of the index.\n\n    Returns:\n\n        List containing the filterable attributes of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; filterable_attributes = index.get_filterable_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/filterable-attributes\")\n\n    if not response.json():\n        return None\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_non_separator_tokens","title":"<code>get_non_separator_tokens()</code>","text":"<p>Get non-separator token settings for the index.</p> <p>Returns:</p> <pre><code>Non-separator tokens for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; non_separator_token_settings = index.get_non_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_non_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get non-separator token settings for the index.\n\n    Returns:\n\n        Non-separator tokens for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; non_separator_token_settings = index.get_non_separator_tokens()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/non-separator-tokens\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_pagination","title":"<code>get_pagination()</code>","text":"<p>Get pagination settings for the index.</p> <p>Returns:</p> <pre><code>Pagination for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; pagination_settings = index.get_pagination()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_pagination(self) -&gt; Pagination:\n    \"\"\"Get pagination settings for the index.\n\n    Returns:\n\n        Pagination for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; pagination_settings = index.get_pagination()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/pagination\")\n\n    return Pagination(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_primary_key","title":"<code>get_primary_key()</code>","text":"<p>Get the primary key.</p> <p>Returns:</p> <pre><code>The primary key for the documents in the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; primary_key = index.get_primary_key()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_primary_key(self) -&gt; str | None:\n    \"\"\"Get the primary key.\n\n    Returns:\n\n        The primary key for the documents in the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; primary_key = index.get_primary_key()\n    \"\"\"\n    info = self.fetch_info()\n    return info.primary_key\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_proximity_precision","title":"<code>get_proximity_precision()</code>","text":"<p>Get proximity precision settings for the index.</p> <p>Returns:</p> <pre><code>Proximity precision for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; proximity_precision = index.get_proximity_precision()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_proximity_precision(self) -&gt; ProximityPrecision:\n    \"\"\"Get proximity precision settings for the index.\n\n    Returns:\n\n        Proximity precision for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; proximity_precision = index.get_proximity_precision()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/proximity-precision\")\n\n    return ProximityPrecision[to_snake(response.json()).upper()]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_ranking_rules","title":"<code>get_ranking_rules()</code>","text":"<p>Get ranking rules of the index.</p> <p>Returns:</p> <pre><code>List containing the ranking rules of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; ranking_rules = index.get_ranking_rules()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_ranking_rules(self) -&gt; list[str]:\n    \"\"\"Get ranking rules of the index.\n\n    Returns:\n\n        List containing the ranking rules of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; ranking_rules = index.get_ranking_rules()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/ranking-rules\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_searchable_attributes","title":"<code>get_searchable_attributes()</code>","text":"<p>Get searchable attributes of the index.</p> <p>Returns:</p> <pre><code>List containing the searchable attributes of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; searchable_attributes = index.get_searchable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_searchable_attributes(self) -&gt; list[str]:\n    \"\"\"Get searchable attributes of the index.\n\n    Returns:\n\n        List containing the searchable attributes of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; searchable_attributes = index.get_searchable_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/searchable-attributes\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_separator_tokens","title":"<code>get_separator_tokens()</code>","text":"<p>Get separator token settings for the index.</p> <p>Returns:</p> <pre><code>Separator tokens for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; separator_token_settings = index.get_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_separator_tokens(self) -&gt; list[str]:\n    \"\"\"Get separator token settings for the index.\n\n    Returns:\n\n        Separator tokens for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; separator_token_settings = index.get_separator_tokens()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/separator-tokens\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_settings","title":"<code>get_settings()</code>","text":"<p>Get settings of the index.</p> <p>Returns:</p> <pre><code>Settings of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; settings = index.get_settings()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_settings(self) -&gt; MeilisearchSettings:\n    \"\"\"Get settings of the index.\n\n    Returns:\n\n        Settings of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; settings = index.get_settings()\n    \"\"\"\n    response = self._http_requests.get(self._settings_url)\n    response_json = response.json()\n    settings = MeilisearchSettings(**response_json)\n\n    if response_json.get(\"embedders\"):\n        settings.embedders = _embedder_json_to_settings_model(response_json[\"embedders\"])\n\n    return settings\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_sortable_attributes","title":"<code>get_sortable_attributes()</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Returns:</p> <pre><code>List containing the sortable attributes of the AsyncIndex.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; sortable_attributes = index.get_sortable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_sortable_attributes(self) -&gt; list[str]:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Returns:\n\n        List containing the sortable attributes of the AsyncIndex.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; sortable_attributes = index.get_sortable_attributes()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/sortable-attributes\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_stats","title":"<code>get_stats()</code>","text":"<p>Get stats of the index.</p> <p>Returns:</p> <pre><code>Stats of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; stats = index.get_stats()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_stats(self) -&gt; IndexStats:\n    \"\"\"Get stats of the index.\n\n    Returns:\n\n        Stats of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; stats = index.get_stats()\n    \"\"\"\n    response = self._http_requests.get(self._stats_url)\n\n    return IndexStats(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_stop_words","title":"<code>get_stop_words()</code>","text":"<p>Get stop words of the index.</p> <p>Returns:</p> <pre><code>List containing the stop words of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; stop_words = index.get_stop_words()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_stop_words(self) -&gt; list[str] | None:\n    \"\"\"Get stop words of the index.\n\n    Returns:\n\n        List containing the stop words of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; stop_words = index.get_stop_words()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/stop-words\")\n\n    if not response.json():\n        return None\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_synonyms","title":"<code>get_synonyms()</code>","text":"<p>Get synonyms of the index.</p> <p>Returns:</p> <pre><code>The synonyms of the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; synonyms = index.get_synonyms()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_synonyms(self) -&gt; dict[str, list[str]] | None:\n    \"\"\"Get synonyms of the index.\n\n    Returns:\n\n        The synonyms of the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; synonyms = index.get_synonyms()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/synonyms\")\n\n    if not response.json():\n        return None\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_typo_tolerance","title":"<code>get_typo_tolerance()</code>","text":"<p>Get typo tolerance for the index.</p> <p>Returns:</p> <pre><code>TypoTolerance for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; sortable_attributes = index.get_typo_tolerance()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_typo_tolerance(self) -&gt; TypoTolerance:\n    \"\"\"Get typo tolerance for the index.\n\n    Returns:\n\n        TypoTolerance for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; sortable_attributes = index.get_typo_tolerance()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/typo-tolerance\")\n\n    return TypoTolerance(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.get_word_dictionary","title":"<code>get_word_dictionary()</code>","text":"<p>Get word dictionary settings for the index.</p> <p>Returns:</p> <pre><code>Word dictionary for the index.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; word_dictionary = index.get_word_dictionary()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def get_word_dictionary(self) -&gt; list[str]:\n    \"\"\"Get word dictionary settings for the index.\n\n    Returns:\n\n        Word dictionary for the index.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; word_dictionary = index.get_word_dictionary()\n    \"\"\"\n    response = self._http_requests.get(f\"{self._settings_url}/dictionary\")\n\n    return response.json()\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_displayed_attributes","title":"<code>reset_displayed_attributes()</code>","text":"<p>Reset displayed attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_displayed_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_displayed_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset displayed attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_displayed_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/displayed-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_distinct_attribute","title":"<code>reset_distinct_attribute()</code>","text":"<p>Reset distinct attribute of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_distinct_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_distinct_attribute(self) -&gt; TaskInfo:\n    \"\"\"Reset distinct attribute of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_distinct_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/distinct-attribute\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_embedders","title":"<code>reset_embedders()</code>","text":"<p>Reset an index's embedders settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_embedders()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_embedders(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's embedders settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = AsyncClient(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_embedders()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/embedders\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_faceting","title":"<code>reset_faceting()</code>","text":"<p>Reset an index's faceting settings to their default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_faceting()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_faceting(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's faceting settings to their default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_faceting()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/faceting\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_filterable_attributes","title":"<code>reset_filterable_attributes()</code>","text":"<p>Reset filterable attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_filterable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_filterable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset filterable attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_filterable_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/filterable-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_non_separator_tokens","title":"<code>reset_non_separator_tokens()</code>","text":"<p>Reset an index's non-separator tokens settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_non_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_non_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's non-separator tokens settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_non_separator_tokens()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/non-separator-tokens\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_pagination","title":"<code>reset_pagination()</code>","text":"<p>Reset an index's pagination settings to their default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_pagination()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_pagination(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's pagination settings to their default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_pagination()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/pagination\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_proximity_precision","title":"<code>reset_proximity_precision()</code>","text":"<p>Reset an index's proximity precision settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_proximity_precision()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_proximity_precision(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's proximity precision settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_proximity_precision()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/proximity-precision\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_ranking_rules","title":"<code>reset_ranking_rules()</code>","text":"<p>Reset ranking rules of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_ranking_rules()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_ranking_rules(self) -&gt; TaskInfo:\n    \"\"\"Reset ranking rules of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_ranking_rules()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/ranking-rules\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_searchable_attributes","title":"<code>reset_searchable_attributes()</code>","text":"<p>Reset searchable attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_searchable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_searchable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset searchable attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_searchable_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/searchable-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_separator_tokens","title":"<code>reset_separator_tokens()</code>","text":"<p>Reset an index's separator tokens settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_separator_tokens()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_separator_tokens(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's separator tokens settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_separator_tokens()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/separator-tokens\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_settings","title":"<code>reset_settings()</code>","text":"<p>Reset settings of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_settings()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_settings(self) -&gt; TaskInfo:\n    \"\"\"Reset settings of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_settings()\n    \"\"\"\n    response = self._http_requests.delete(self._settings_url)\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_sortable_attributes","title":"<code>reset_sortable_attributes()</code>","text":"<p>Reset sortable attributes of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_sortable_attributes()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_sortable_attributes(self) -&gt; TaskInfo:\n    \"\"\"Reset sortable attributes of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_sortable_attributes()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/sortable-attributes\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_stop_words","title":"<code>reset_stop_words()</code>","text":"<p>Reset stop words of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_stop_words()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_stop_words(self) -&gt; TaskInfo:\n    \"\"\"Reset stop words of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_stop_words()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/stop-words\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_synonyms","title":"<code>reset_synonyms()</code>","text":"<p>Reset synonyms of the index to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_synonyms()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_synonyms(self) -&gt; TaskInfo:\n    \"\"\"Reset synonyms of the index to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_synonyms()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/synonyms\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_typo_tolerance","title":"<code>reset_typo_tolerance()</code>","text":"<p>Reset typo tolerance to default values.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_typo_tolerance()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_typo_tolerance(self) -&gt; TaskInfo:\n    \"\"\"Reset typo tolerance to default values.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_typo_tolerance()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/typo-tolerance\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.reset_word_dictionary","title":"<code>reset_word_dictionary()</code>","text":"<p>Reset an index's word dictionary settings to the default value.</p> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_async_client import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.reset_word_dictionary()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def reset_word_dictionary(self) -&gt; TaskInfo:\n    \"\"\"Reset an index's word dictionary settings to the default value.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_async_client import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.reset_word_dictionary()\n    \"\"\"\n    response = self._http_requests.delete(f\"{self._settings_url}/dictionary\")\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.search","title":"<code>search(query=None, *, offset=0, limit=20, filter=None, facets=None, attributes_to_retrieve=['*'], attributes_to_crop=None, crop_length=200, attributes_to_highlight=None, sort=None, show_matches_position=False, highlight_pre_tag='&lt;em&gt;', highlight_post_tag='&lt;/em&gt;', crop_marker='...', matching_strategy='all', hits_per_page=None, page=None, attributes_to_search_on=None, show_ranking_score=False, show_ranking_score_details=False, vector=None, hybrid=None)</code>","text":"<p>Search the index.</p> <p>Args:</p> <pre><code>query: String containing the word(s) to search\noffset: Number of documents to skip. Defaults to 0.\nlimit: Maximum number of documents returned. Defaults to 20.\nfilter: Filter queries by an attribute value. Defaults to None.\nfacets: Facets for which to retrieve the matching count. Defaults to None.\nattributes_to_retrieve: Attributes to display in the returned documents.\n    Defaults to [\"*\"].\nattributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\ncrop_length: The maximun number of words to display. Defaults to 200.\nattributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n    Defaults to None.\nsort: Attributes by which to sort the results. Defaults to None.\nshow_matches_position: Defines whether an object that contains information about the matches should be\n    returned or not. Defaults to False.\nhighlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\nhighlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\ncrop_marker: Marker to display when the number of words excedes the `crop_length`.\n    Defaults to ...\nmatching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\nhits_per_page: Sets the number of results returned per page.\npage: Sets the specific results page to fetch.\nattributes_to_search_on: List of field names. Allow search over a subset of searchable\n    attributes without modifying the index settings. Defaults to None.\nshow_ranking_score: If set to True the ranking score will be returned with each document\n    in the search. Defaults to False.\nshow_ranking_score_details: If set to True the ranking details will be returned with\n    each document in the search. Defaults to False. Note: This parameter can only be\n    used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n    to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n    sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n    Because this feature is experimental it may be removed or updated causing breaking\n    changes in this library without a major version bump so use with caution. This\n    feature became stable in Meiliseach v1.7.0.\nvector: List of vectors for vector search. Defaults to None. Note: This parameter can\n    only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n    In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n    feature by sending a PATCH request to /experimental-features with\n    { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n    updated causing breaking changes in this library without a major version bump so use\n    with caution.\nhybrid: Hybrid search information. Defaults to None. Note: This parameter can\n    only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n    In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n    feature by sending a PATCH request to /experimental-features with\n    { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n    updated causing breaking changes in this library without a major version bump so use\n    with caution.\n</code></pre> <p>Returns:</p> <pre><code>Results of the search\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; search_results = index.search(\"Tron\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def search(\n    self,\n    query: str | None = None,\n    *,\n    offset: int = 0,\n    limit: int = 20,\n    filter: Filter | None = None,\n    facets: list[str] | None = None,\n    attributes_to_retrieve: list[str] = [\"*\"],\n    attributes_to_crop: list[str] | None = None,\n    crop_length: int = 200,\n    attributes_to_highlight: list[str] | None = None,\n    sort: list[str] | None = None,\n    show_matches_position: bool = False,\n    highlight_pre_tag: str = \"&lt;em&gt;\",\n    highlight_post_tag: str = \"&lt;/em&gt;\",\n    crop_marker: str = \"...\",\n    matching_strategy: str = \"all\",\n    hits_per_page: int | None = None,\n    page: int | None = None,\n    attributes_to_search_on: list[str] | None = None,\n    show_ranking_score: bool = False,\n    show_ranking_score_details: bool = False,\n    vector: list[float] | None = None,\n    hybrid: Hybrid | None = None,\n) -&gt; SearchResults:\n    \"\"\"Search the index.\n\n    Args:\n\n        query: String containing the word(s) to search\n        offset: Number of documents to skip. Defaults to 0.\n        limit: Maximum number of documents returned. Defaults to 20.\n        filter: Filter queries by an attribute value. Defaults to None.\n        facets: Facets for which to retrieve the matching count. Defaults to None.\n        attributes_to_retrieve: Attributes to display in the returned documents.\n            Defaults to [\"*\"].\n        attributes_to_crop: Attributes whose values have to be cropped. Defaults to None.\n        crop_length: The maximun number of words to display. Defaults to 200.\n        attributes_to_highlight: Attributes whose values will contain highlighted matching terms.\n            Defaults to None.\n        sort: Attributes by which to sort the results. Defaults to None.\n        show_matches_position: Defines whether an object that contains information about the matches should be\n            returned or not. Defaults to False.\n        highlight_pre_tag: The opening tag for highlighting text. Defaults to &lt;em&gt;.\n        highlight_post_tag: The closing tag for highlighting text. Defaults to &lt;/em&gt;\n        crop_marker: Marker to display when the number of words excedes the `crop_length`.\n            Defaults to ...\n        matching_strategy: Specifies the matching strategy Meilisearch should use. Defaults to `all`.\n        hits_per_page: Sets the number of results returned per page.\n        page: Sets the specific results page to fetch.\n        attributes_to_search_on: List of field names. Allow search over a subset of searchable\n            attributes without modifying the index settings. Defaults to None.\n        show_ranking_score: If set to True the ranking score will be returned with each document\n            in the search. Defaults to False.\n        show_ranking_score_details: If set to True the ranking details will be returned with\n            each document in the search. Defaults to False. Note: This parameter can only be\n            used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0. In order\n            to use this feature in Meilisearch v1.3.0 you first need to enable the feature by\n            sending a PATCH request to /experimental-features with { \"scoreDetails\": true }.\n            Because this feature is experimental it may be removed or updated causing breaking\n            changes in this library without a major version bump so use with caution. This\n            feature became stable in Meiliseach v1.7.0.\n        vector: List of vectors for vector search. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.3.0, and is experimental in Meilisearch v1.3.0.\n            In order to use this feature in Meilisearch v1.3.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n        hybrid: Hybrid search information. Defaults to None. Note: This parameter can\n            only be used with Meilisearch &gt;= v1.6.0, and is experimental in Meilisearch v1.6.0.\n            In order to use this feature in Meilisearch v1.6.0 you first need to enable the\n            feature by sending a PATCH request to /experimental-features with\n            { \"vectorStore\": true }. Because this feature is experimental it may be removed or\n            updated causing breaking changes in this library without a major version bump so use\n            with caution.\n\n    Returns:\n\n        Results of the search\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; search_results = index.search(\"Tron\")\n    \"\"\"\n    body = _process_search_parameters(\n        q=query,\n        offset=offset,\n        limit=limit,\n        filter=filter,\n        facets=facets,\n        attributes_to_retrieve=attributes_to_retrieve,\n        attributes_to_crop=attributes_to_crop,\n        crop_length=crop_length,\n        attributes_to_highlight=attributes_to_highlight,\n        sort=sort,\n        show_matches_position=show_matches_position,\n        highlight_pre_tag=highlight_pre_tag,\n        highlight_post_tag=highlight_post_tag,\n        crop_marker=crop_marker,\n        matching_strategy=matching_strategy,\n        hits_per_page=hits_per_page,\n        page=page,\n        attributes_to_search_on=attributes_to_search_on,\n        show_ranking_score=show_ranking_score,\n        show_ranking_score_details=show_ranking_score_details,\n        vector=vector,\n        hybrid=hybrid,\n    )\n\n    if self._pre_search_plugins:\n        Index._run_plugins(\n            self._pre_search_plugins,\n            Event.PRE,\n            query=query,\n            offset=offset,\n            limit=limit,\n            filter=filter,\n            facets=facets,\n            attributes_to_retrieve=attributes_to_retrieve,\n            attributes_to_crop=attributes_to_crop,\n            crop_length=crop_length,\n            attributes_to_highlight=attributes_to_highlight,\n            sort=sort,\n            show_matches_position=show_matches_position,\n            highlight_pre_tag=highlight_pre_tag,\n            highlight_post_tag=highlight_post_tag,\n            crop_marker=crop_marker,\n            matching_strategy=matching_strategy,\n            hits_per_page=hits_per_page,\n            page=page,\n            attributes_to_search_on=attributes_to_search_on,\n            show_ranking_score=show_ranking_score,\n            show_ranking_score_details=show_ranking_score_details,\n            vector=vector,\n            hybrid=hybrid,\n        )\n\n    response = self._http_requests.post(f\"{self._base_url_with_uid}/search\", body=body)\n    result = SearchResults(**response.json())\n    if self._post_search_plugins:\n        post = Index._run_plugins(self._post_search_plugins, Event.POST, search_results=result)\n        if post.get(\"search_result\"):\n            result = post[\"search_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update","title":"<code>update(primary_key)</code>","text":"<p>Update the index primary key.</p> <p>Args:</p> <pre><code>primary_key: The primary key of the documents.\n</code></pre> <p>Returns:</p> <pre><code>An instance of the AsyncIndex with the updated information.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; updated_index = index.update()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update(self, primary_key: str) -&gt; Index:\n    \"\"\"Update the index primary key.\n\n    Args:\n\n        primary_key: The primary key of the documents.\n\n    Returns:\n\n        An instance of the AsyncIndex with the updated information.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; updated_index = index.update()\n    \"\"\"\n    payload = {\"primaryKey\": primary_key}\n    response = self._http_requests.patch(self._base_url_with_uid, payload)\n    wait_for_task(self.http_client, response.json()[\"taskUid\"], timeout_in_ms=100000)\n    index_response = self._http_requests.get(self._base_url_with_uid)\n    self.primary_key = index_response.json()[\"primaryKey\"]\n    return self\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_displayed_attributes","title":"<code>update_displayed_attributes(body, *, compress=False)</code>","text":"<p>Update displayed attributes of the index.</p> <p>Args:</p> <pre><code>body: List containing the displayed attributes.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_displayed_attributes(\n&gt;&gt;&gt;     [\"title\", \"description\", \"genre\", \"release_date\"]\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_displayed_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update displayed attributes of the index.\n\n    Args:\n\n        body: List containing the displayed attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_displayed_attributes(\n        &gt;&gt;&gt;     [\"title\", \"description\", \"genre\", \"release_date\"]\n        &gt;&gt;&gt; )\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/displayed-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_distinct_attribute","title":"<code>update_distinct_attribute(body, *, compress=False)</code>","text":"<p>Update distinct attribute of the index.</p> <p>Args:</p> <pre><code>body: Distinct attribute.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_distinct_attribute(\"url\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_distinct_attribute(self, body: str, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update distinct attribute of the index.\n\n    Args:\n\n        body: Distinct attribute.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_distinct_attribute(\"url\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/distinct-attribute\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents","title":"<code>update_documents(documents, primary_key=None, *, compress=False)</code>","text":"<p>Update documents in the index.</p> <p>Args:</p> <pre><code>documents: List of documents.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents(\n    self,\n    documents: Sequence[JsonMapping],\n    primary_key: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Update documents in the index.\n\n    Args:\n\n        documents: List of documents.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents(documents)\n    \"\"\"\n    if primary_key:\n        url = _build_encoded_url(self._documents_url, {\"primaryKey\": primary_key})\n    else:\n        url = self._documents_url\n\n    if self._pre_update_documents_plugins:\n        pre = Index._run_plugins(\n            self._pre_update_documents_plugins,\n            Event.PRE,\n            documents=documents,\n            primary_key=primary_key,\n        )\n        if pre.get(\"document_result\"):\n            documents = pre[\"document_result\"]\n\n    response = self._http_requests.put(url, documents, compress=compress)\n    result = TaskInfo(**response.json())\n    if self._post_update_documents_plugins:\n        post = Index._run_plugins(\n            self._post_update_documents_plugins, Event.POST, result=result\n        )\n        if isinstance(post.get(\"generic_result\"), TaskInfo):\n            result = post[\"generic_result\"]\n\n    return result\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_directory","title":"<code>update_documents_from_directory(directory_path, *, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents_from_directory(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents_from_directory(\n    self,\n    directory_path: Path | str,\n    *,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents_from_directory(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = _combine_documents(all_documents)\n\n        response = self.update_documents(combined, primary_key, compress=compress)\n        return [response]\n\n    responses = []\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(path, csv_delimiter)\n            responses.append(self.update_documents(documents, primary_key, compress=compress))\n\n    _raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_directory_in_batches","title":"<code>update_documents_from_directory_in_batches(directory_path, *, batch_size=1000, primary_key=None, document_type='json', csv_delimiter=None, combine_documents=True, compress=False)</code>","text":"<p>Load all json files from a directory and update the documents.</p> <p>Args:</p> <pre><code>directory_path: Path to the directory that contains the json files.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ndocument_type: The type of document being added. Accepted types are json, csv, and\n    ndjson. For csv files the first row of the document should be a header row contining\n    the field names, and ever for should have a title.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncombine_documents: If set to True this will combine the documents from all the files\n    before indexing them. Defaults to True.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents_from_directory_in_batches(directory_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents_from_directory_in_batches(\n    self,\n    directory_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    document_type: str = \"json\",\n    csv_delimiter: str | None = None,\n    combine_documents: bool = True,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Load all json files from a directory and update the documents.\n\n    Args:\n\n        directory_path: Path to the directory that contains the json files.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        document_type: The type of document being added. Accepted types are json, csv, and\n            ndjson. For csv files the first row of the document should be a header row contining\n            the field names, and ever for should have a title.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        combine_documents: If set to True this will combine the documents from all the files\n            before indexing them. Defaults to True.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        InvalidDocumentError: If the docucment is not a valid format for Meilisearch.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; directory_path = Path(\"/path/to/directory/containing/files\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents_from_directory_in_batches(directory_path)\n    \"\"\"\n    directory = Path(directory_path) if isinstance(directory_path, str) else directory_path\n\n    if combine_documents:\n        all_documents = []\n        for path in directory.iterdir():\n            if path.suffix == f\".{document_type}\":\n                documents = _load_documents_from_file(path, csv_delimiter)\n                all_documents.append(documents)\n\n        _raise_on_no_documents(all_documents, document_type, directory_path)\n\n        combined = _combine_documents(all_documents)\n\n        return self.update_documents_in_batches(\n            combined, batch_size=batch_size, primary_key=primary_key, compress=compress\n        )\n\n    responses: list[TaskInfo] = []\n\n    for path in directory.iterdir():\n        if path.suffix == f\".{document_type}\":\n            documents = _load_documents_from_file(path, csv_delimiter)\n            responses.extend(\n                self.update_documents_in_batches(\n                    documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n                )\n            )\n\n    _raise_on_no_documents(responses, document_type, directory_path)\n\n    return responses\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_file","title":"<code>update_documents_from_file(file_path, primary_key=None, csv_delimiter=None, *, compress=False)</code>","text":"<p>Add documents in the index from a json file.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents_from_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents_from_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Add documents in the index from a json file.\n\n    Args:\n\n        file_path: Path to the json file.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents_from_file(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(file_path, csv_delimiter)\n\n    return self.update_documents(documents, primary_key=primary_key, compress=compress)\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_file_in_batches","title":"<code>update_documents_from_file_in_batches(file_path, *, batch_size=1000, primary_key=None, compress=False)</code>","text":"<p>Updates documents form a json file in batches to reduce RAM usage with indexing.</p> <p>Args:</p> <pre><code>file_path: Path to the json file.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents_from_file_in_batches(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents_from_file_in_batches(\n    self,\n    file_path: Path | str,\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Updates documents form a json file in batches to reduce RAM usage with indexing.\n\n    Args:\n\n        file_path: Path to the json file.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.json\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents_from_file_in_batches(file_path)\n    \"\"\"\n    documents = _load_documents_from_file(file_path)\n\n    return self.update_documents_in_batches(\n        documents, batch_size=batch_size, primary_key=primary_key, compress=compress\n    )\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_from_raw_file","title":"<code>update_documents_from_raw_file(file_path, primary_key=None, csv_delimiter=None, *, compress=False)</code>","text":"<p>Directly send csv or ndjson files to Meilisearch without pre-processing.</p> <p>The can reduce RAM usage from Meilisearch during indexing, but does not include the option for batching.</p> <p>Args:</p> <pre><code>file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n    allowed.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncsv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n    can only be used if the file is a csv file. Defaults to comma.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n    a non-csv file.\nMeilisearchError: If the file path is not valid\nMeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents_from_raw_file(file_path)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents_from_raw_file(\n    self,\n    file_path: Path | str,\n    primary_key: str | None = None,\n    csv_delimiter: str | None = None,\n    *,\n    compress: bool = False,\n) -&gt; TaskInfo:\n    \"\"\"Directly send csv or ndjson files to Meilisearch without pre-processing.\n\n    The can reduce RAM usage from Meilisearch during indexing, but does not include the option\n    for batching.\n\n    Args:\n\n        file_path: The path to the file to send to Meilisearch. Only csv and ndjson files are\n            allowed.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        csv_delimiter: A single ASCII character to specify the delimiter for csv files. This\n            can only be used if the file is a csv file. Defaults to comma.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        ValueError: If the file is not a csv or ndjson file, or if a csv_delimiter is sent for\n            a non-csv file.\n        MeilisearchError: If the file path is not valid\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; file_path = Path(\"/path/to/file.csv\")\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents_from_raw_file(file_path)\n    \"\"\"\n    upload_path = Path(file_path) if isinstance(file_path, str) else file_path\n    if not upload_path.exists():\n        raise MeilisearchError(\"No file found at the specified path\")\n\n    if upload_path.suffix not in (\".csv\", \".ndjson\"):\n        raise ValueError(\"Only csv and ndjson files can be sent as binary files\")\n\n    if csv_delimiter and upload_path.suffix != \".csv\":\n        raise ValueError(\"A csv_delimiter can only be used with csv files\")\n\n    if (\n        csv_delimiter\n        and len(csv_delimiter) != 1\n        or csv_delimiter\n        and not csv_delimiter.isascii()\n    ):\n        raise ValueError(\"csv_delimiter must be a single ascii character\")\n\n    content_type = \"text/csv\" if upload_path.suffix == \".csv\" else \"application/x-ndjson\"\n    parameters = {}\n\n    if primary_key:\n        parameters[\"primaryKey\"] = primary_key\n    if csv_delimiter:\n        parameters[\"csvDelimiter\"] = csv_delimiter\n\n    if parameters:\n        url = _build_encoded_url(self._documents_url, parameters)\n    else:\n        url = self._documents_url\n\n    with open(upload_path) as f:\n        data = f.read()\n\n    response = self._http_requests.put(\n        url, body=data, content_type=content_type, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_documents_in_batches","title":"<code>update_documents_in_batches(documents, *, batch_size=1000, primary_key=None, compress=False)</code>","text":"<p>Update documents in batches to reduce RAM usage with indexing.</p> <p>Each batch tries to fill the max_payload_size</p> <p>Args:</p> <pre><code>documents: List of documents.\nbatch_size: The number of documents that should be included in each batch.\n    Defaults to 1000.\nprimary_key: The primary key of the documents. This will be ignored if already set.\n    Defaults to None.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>List of update ids to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; documents = [\n&gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n&gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_documents_in_batches(documents)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_documents_in_batches(\n    self,\n    documents: Sequence[JsonMapping],\n    *,\n    batch_size: int = 1000,\n    primary_key: str | None = None,\n    compress: bool = False,\n) -&gt; list[TaskInfo]:\n    \"\"\"Update documents in batches to reduce RAM usage with indexing.\n\n    Each batch tries to fill the max_payload_size\n\n    Args:\n\n        documents: List of documents.\n        batch_size: The number of documents that should be included in each batch.\n            Defaults to 1000.\n        primary_key: The primary key of the documents. This will be ignored if already set.\n            Defaults to None.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        List of update ids to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; documents = [\n        &gt;&gt;&gt;     {\"id\": 1, \"title\": \"Movie 1\", \"genre\": \"comedy\"},\n        &gt;&gt;&gt;     {\"id\": 2, \"title\": \"Movie 2\", \"genre\": \"drama\"},\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_documents_in_batches(documents)\n    \"\"\"\n    return [\n        self.update_documents(x, primary_key, compress=compress)\n        for x in _batch(documents, batch_size)\n    ]\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_embedders","title":"<code>update_embedders(embedders, *, compress=False)</code>","text":"<p>Update the embedders settings for an index.</p> <p>Args:</p> <pre><code>embedders: The embedders value.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_embedders(\n&gt;&gt;&gt;     Embedders(embedders={dimensions=512)})\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_embedders(self, embedders: Embedders, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the embedders settings for an index.\n\n    Args:\n\n        embedders: The embedders value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Embedders, UserProvidedEmbedder\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_embedders(\n        &gt;&gt;&gt;     Embedders(embedders={dimensions=512)})\n        &gt;&gt;&gt; )\n    \"\"\"\n    payload = {}\n    for key, embedder in embedders.embedders.items():\n        if is_pydantic_2():\n            payload[key] = {\n                k: v for k, v in embedder.model_dump(by_alias=True).items() if v is not None\n            }  # type: ignore[attr-defined]\n        else:  # pragma: no cover\n            warn(\n                \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n                DeprecationWarning,\n            )\n            payload[key] = {\n                k: v for k, v in embedder.dict(by_alias=True).items() if v is not None\n            }  # type: ignore[attr-defined]\n\n    response = self._http_requests.patch(\n        f\"{self._settings_url}/embedders\", payload, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_faceting","title":"<code>update_faceting(faceting, *, compress=False)</code>","text":"<p>Partially update the faceting settings for an index.</p> <p>Args:</p> <pre><code>faceting: Faceting values.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_faceting(self, faceting: Faceting, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the faceting settings for an index.\n\n    Args:\n\n        faceting: Faceting values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_faceting(faceting=Faceting(max_values_per_facet=100))\n    \"\"\"\n    if is_pydantic_2():\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/faceting\",\n            faceting.model_dump(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/faceting\", faceting.dict(by_alias=True), compress=compress\n        )  # type: ignore[attr-defined]\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_filterable_attributes","title":"<code>update_filterable_attributes(body, *, compress=False)</code>","text":"<p>Update filterable attributes of the index.</p> <p>Args:</p> <pre><code>body: List containing the filterable attributes of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_filterable_attributes([\"genre\", \"director\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_filterable_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update filterable attributes of the index.\n\n    Args:\n\n        body: List containing the filterable attributes of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_filterable_attributes([\"genre\", \"director\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/filterable-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_non_separator_tokens","title":"<code>update_non_separator_tokens(non_separator_tokens, *, compress=False)</code>","text":"<p>Update the non-separator tokens settings for an index.</p> <p>Args:</p> <pre><code>non_separator_tokens: List of non-separator tokens.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_non_separator_tokens(\n    self, non_separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the non-separator tokens settings for an index.\n\n    Args:\n\n        non_separator_tokens: List of non-separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_non_separator_tokens(non_separator_tokens=[\"@\", \"#\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/non-separator-tokens\", non_separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_pagination","title":"<code>update_pagination(settings, *, compress=False)</code>","text":"<p>Partially update the pagination settings for an index.</p> <p>Args:</p> <pre><code>settings: settings for pagination.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_pagination(settings=Pagination(max_total_hits=123))\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_pagination(self, settings: Pagination, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Partially update the pagination settings for an index.\n\n    Args:\n\n        settings: settings for pagination.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import Pagination\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_pagination(settings=Pagination(max_total_hits=123))\n    \"\"\"\n    if is_pydantic_2():\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/pagination\",\n            settings.model_dump(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/pagination\", settings.dict(by_alias=True), compress=compress\n        )  # type: ignore[attr-defined]\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_proximity_precision","title":"<code>update_proximity_precision(proximity_precision, *, compress=False)</code>","text":"<p>Update the proximity precision settings for an index.</p> <p>Args:</p> <pre><code>proximity_precision: The proximity precision value.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_proximity_precision(\n    self, proximity_precision: ProximityPrecision, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the proximity precision settings for an index.\n\n    Args:\n\n        proximity_precision: The proximity precision value.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk.models.settings import ProximityPrecision\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/proximity-precision\",\n        proximity_precision.value,\n        compress=compress,\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_ranking_rules","title":"<code>update_ranking_rules(ranking_rules, *, compress=False)</code>","text":"<p>Update ranking rules of the index.</p> <p>Args:</p> <pre><code>ranking_rules: List containing the ranking rules.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; ranking_rules=[\n&gt;&gt;&gt;      \"words\",\n&gt;&gt;&gt;      \"typo\",\n&gt;&gt;&gt;      \"proximity\",\n&gt;&gt;&gt;      \"attribute\",\n&gt;&gt;&gt;      \"sort\",\n&gt;&gt;&gt;      \"exactness\",\n&gt;&gt;&gt;      \"release_date:desc\",\n&gt;&gt;&gt;      \"rank:desc\",\n&gt;&gt;&gt; ],\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_ranking_rules(ranking_rules)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_ranking_rules(self, ranking_rules: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update ranking rules of the index.\n\n    Args:\n\n        ranking_rules: List containing the ranking rules.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; ranking_rules=[\n        &gt;&gt;&gt;      \"words\",\n        &gt;&gt;&gt;      \"typo\",\n        &gt;&gt;&gt;      \"proximity\",\n        &gt;&gt;&gt;      \"attribute\",\n        &gt;&gt;&gt;      \"sort\",\n        &gt;&gt;&gt;      \"exactness\",\n        &gt;&gt;&gt;      \"release_date:desc\",\n        &gt;&gt;&gt;      \"rank:desc\",\n        &gt;&gt;&gt; ],\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_ranking_rules(ranking_rules)\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/ranking-rules\", ranking_rules, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_searchable_attributes","title":"<code>update_searchable_attributes(body, *, compress=False)</code>","text":"<p>Update searchable attributes of the index.</p> <p>Args:</p> <pre><code>body: List containing the searchable attributes.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_searchable_attributes(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update searchable attributes of the index.\n\n    Args:\n\n        body: List containing the searchable attributes.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_searchable_attributes([\"title\", \"description\", \"genre\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/searchable-attributes\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_separator_tokens","title":"<code>update_separator_tokens(separator_tokens, *, compress=False)</code>","text":"<p>Update the separator tokens settings for an index.</p> <p>Args:</p> <pre><code>separator_tokens: List of separator tokens.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_separator_tokens(\n    self, separator_tokens: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update the separator tokens settings for an index.\n\n    Args:\n\n        separator_tokens: List of separator tokens.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_separator_tokens(separator_tokenes=[\"|\", \"/\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/separator-tokens\", separator_tokens, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_settings","title":"<code>update_settings(body, *, compress=False)</code>","text":"<p>Update settings of the index.</p> <p>Args:</p> <pre><code>body: Settings of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n&gt;&gt;&gt; new_settings = MeilisearchSettings(\n&gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n&gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n&gt;&gt;&gt;     ranking_rules=[\n&gt;&gt;&gt;         \"words\",\n&gt;&gt;&gt;         \"typo\",\n&gt;&gt;&gt;         \"proximity\",\n&gt;&gt;&gt;         \"attribute\",\n&gt;&gt;&gt;         \"sort\",\n&gt;&gt;&gt;         \"exactness\",\n&gt;&gt;&gt;         \"release_date:desc\",\n&gt;&gt;&gt;         \"rank:desc\",\n&gt;&gt;&gt;    ],\n&gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n&gt;&gt;&gt;    distinct_attribute=\"url\",\n&gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n&gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n&gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n&gt;&gt;&gt; )\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_settings(new_settings)\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_settings(self, body: MeilisearchSettings, *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update settings of the index.\n\n    Args:\n\n        body: Settings of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; from meilisearch_python_sdk import MeilisearchSettings\n        &gt;&gt;&gt; new_settings = MeilisearchSettings(\n        &gt;&gt;&gt;     synonyms={\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]},\n        &gt;&gt;&gt;     stop_words=[\"the\", \"a\", \"an\"],\n        &gt;&gt;&gt;     ranking_rules=[\n        &gt;&gt;&gt;         \"words\",\n        &gt;&gt;&gt;         \"typo\",\n        &gt;&gt;&gt;         \"proximity\",\n        &gt;&gt;&gt;         \"attribute\",\n        &gt;&gt;&gt;         \"sort\",\n        &gt;&gt;&gt;         \"exactness\",\n        &gt;&gt;&gt;         \"release_date:desc\",\n        &gt;&gt;&gt;         \"rank:desc\",\n        &gt;&gt;&gt;    ],\n        &gt;&gt;&gt;    filterable_attributes=[\"genre\", \"director\"],\n        &gt;&gt;&gt;    distinct_attribute=\"url\",\n        &gt;&gt;&gt;    searchable_attributes=[\"title\", \"description\", \"genre\"],\n        &gt;&gt;&gt;    displayed_attributes=[\"title\", \"description\", \"genre\", \"release_date\"],\n        &gt;&gt;&gt;    sortable_attributes=[\"title\", \"release_date\"],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_settings(new_settings)\n    \"\"\"\n    if is_pydantic_2():\n        body_dict = {k: v for k, v in body.model_dump(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        body_dict = {k: v for k, v in body.dict(by_alias=True).items() if v is not None}  # type: ignore[attr-defined]\n\n    response = self._http_requests.patch(self._settings_url, body_dict, compress=compress)\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_sortable_attributes","title":"<code>update_sortable_attributes(sortable_attributes, *, compress=False)</code>","text":"<p>Get sortable attributes of the AsyncIndex.</p> <p>Args:</p> <pre><code>sortable_attributes: List of attributes for searching.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_sortable_attributes([\"title\", \"release_date\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_sortable_attributes(\n    self, sortable_attributes: list[str], *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Get sortable attributes of the AsyncIndex.\n\n    Args:\n\n        sortable_attributes: List of attributes for searching.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_sortable_attributes([\"title\", \"release_date\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/sortable-attributes\", sortable_attributes, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_stop_words","title":"<code>update_stop_words(body, *, compress=False)</code>","text":"<p>Update stop words of the index.</p> <p>Args:</p> <pre><code>body: List containing the stop words of the index.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_stop_words([\"the\", \"a\", \"an\"])\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_stop_words(self, body: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update stop words of the index.\n\n    Args:\n\n        body: List containing the stop words of the index.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_stop_words([\"the\", \"a\", \"an\"])\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/stop-words\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_synonyms","title":"<code>update_synonyms(body, *, compress=False)</code>","text":"<p>Update synonyms of the index.</p> <p>Args:</p> <pre><code>body: The synonyms of the index.\n</code></pre> <p>Returns:</p> <pre><code>The details of the task status.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_synonyms(\n&gt;&gt;&gt;     {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_synonyms(self, body: dict[str, list[str]], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update synonyms of the index.\n\n    Args:\n\n        body: The synonyms of the index.\n\n    Returns:\n\n        The details of the task status.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\") as client:\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_synonyms(\n        &gt;&gt;&gt;     {\"wolverine\": [\"xmen\", \"logan\"], \"logan\": [\"wolverine\"]}\n        &gt;&gt;&gt; )\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/synonyms\", body, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_typo_tolerance","title":"<code>update_typo_tolerance(typo_tolerance, *, compress=False)</code>","text":"<p>Update typo tolerance.</p> <p>Args:</p> <pre><code>typo_tolerance: Typo tolerance settings.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; TypoTolerance(enabled=False)\n&gt;&gt;&gt; index.update_typo_tolerance()\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_typo_tolerance(\n    self, typo_tolerance: TypoTolerance, *, compress: bool = False\n) -&gt; TaskInfo:\n    \"\"\"Update typo tolerance.\n\n    Args:\n\n        typo_tolerance: Typo tolerance settings.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; TypoTolerance(enabled=False)\n        &gt;&gt;&gt; index.update_typo_tolerance()\n    \"\"\"\n    if is_pydantic_2():\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/typo-tolerance\",\n            typo_tolerance.model_dump(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n    else:  # pragma: no cover\n        warn(\n            \"The use of Pydantic less than version 2 is depreciated and will be removed in a future release\",\n            DeprecationWarning,\n        )\n        response = self._http_requests.patch(\n            f\"{self._settings_url}/typo-tolerance\",\n            typo_tolerance.dict(by_alias=True),\n            compress=compress,\n        )  # type: ignore[attr-defined]\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"index_api/#meilisearch_python_sdk.index.Index.update_word_dictionary","title":"<code>update_word_dictionary(dictionary, *, compress=False)</code>","text":"<p>Update the word dictionary settings for an index.</p> <p>Args:</p> <pre><code>dictionary: List of dictionary values.\ncompress: If set to True the data will be sent in gzip format. Defaults to False.\n</code></pre> <p>Returns:</p> <pre><code>Task to track the action.\n</code></pre> <p>Raises:</p> <pre><code>MeilisearchCommunicationError: If there was an error communicating with the server.\nMeilisearchApiError: If the Meilisearch API returned an error.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from meilisearch_python_sdk import Client\n&gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n&gt;&gt;&gt; index = client.index(\"movies\")\n&gt;&gt;&gt; index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n</code></pre> Source code in <code>meilisearch_python_sdk/index.py</code> <pre><code>def update_word_dictionary(self, dictionary: list[str], *, compress: bool = False) -&gt; TaskInfo:\n    \"\"\"Update the word dictionary settings for an index.\n\n    Args:\n\n        dictionary: List of dictionary values.\n        compress: If set to True the data will be sent in gzip format. Defaults to False.\n\n    Returns:\n\n        Task to track the action.\n\n    Raises:\n\n        MeilisearchCommunicationError: If there was an error communicating with the server.\n        MeilisearchApiError: If the Meilisearch API returned an error.\n\n    Examples:\n\n        &gt;&gt;&gt; from meilisearch_python_sdk import Client\n        &gt;&gt;&gt; client = Client(\"http://localhost.com\", \"masterKey\")\n        &gt;&gt;&gt; index = client.index(\"movies\")\n        &gt;&gt;&gt; index.update_word_dictionary(dictionary=[\"S.O.S\", \"S.O\")\n    \"\"\"\n    response = self._http_requests.put(\n        f\"{self._settings_url}/dictionary\", dictionary, compress=compress\n    )\n\n    return TaskInfo(**response.json())\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":"<p>Plugins can be used to extend the functionality of certain methods, currently plugins are only supported for indexes. To create plugins you creat a class that implements the Protocol for the plugin, then add an instance of your class to the plugins when creating an index. Passing protocols is done through a named tuple that specifies where the plugin should run. The options are:</p> <ul> <li>add_documents_plugins: Runs the plugins when adding documents. This runs for all the add documents   methods, i.e. <code>add_documents_in_batches</code>.</li> <li>delete_all_documents_plugins: Run on the <code>delete_all_documents</code> method.</li> <li>delete_document_plugins: Run on the <code>delete_document</code> method.</li> <li>delete_documents_plugins: Run on the <code>delete_documents</code> method.</li> <li>delete_documents_by_filter_plugins: Run on the <code>delete_documents_by_filter</code> method.</li> <li>search_plugins: Run on the <code>search</code> and <code>facet_search</code> methods.</li> <li>update_documents_plugins: Run on the <code>update_document</code> method.</li> </ul> <p>When creating your plugin you specify if you want it to run before or after the default functionality. Additionaly plugins for async indexes can be run concurrently with the default functionality.</p>"},{"location":"plugins/#examples","title":"Examples:","text":""},{"location":"plugins/#search-metrics","title":"Search metrics","text":"<p>It is common to want to know what users are searching for, however Meilisearch doesn't provide a way to track this out of the box. A search plugin could be used to implement this functionality yourself.</p> <p>Note that in these examples the protocol is satisfied by providing the <code>CONNECURRENT_EVENT</code>, <code>POST_EVENT</code>, and <code>PRE_EVENT</code> vairables and the <code>async def run_plugin(self, event: AsyncEvent, **kwargs: Any) -&gt; None:</code> method for an async index, or the <code>POST_EVENT</code> and <code>PRE_EVENT</code> vairables , and <code>def run_plugin(self, event: Event, **kwargs: Any) -&gt; None:</code> method for a non-async index. You class can contain any additional methods/variables needed as long as the protocol requirements have been satisfied.</p>"},{"location":"plugins/#async-index","title":"Async index","text":"<pre><code>import asyncio\nimport json\nimport sqlite3\nfrom typing import Any\n\nfrom meilisearch_python_sdk import AsyncClient\nfrom meilisearch_python_sdk.plugins import AsyncEvent, AsyncIndexPlugins\n\n\nclass SearchTrackerPlugin:\n    CONCURRENT_EVENT = True  # Specifies the plugin should be run concurrently with the search\n    POST_EVENT = False\n    PRE_EVENT = False\n\n    def __init__(self) -&gt; None:\n        self.conn = sqlite3.Connection(\"examples/search_tracker.db\")\n        self.create_table()\n\n    def create_table(self) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"CREATE TABLE IF NOT EXISTS searches(query STRING)\")\n        finally:\n            cursor.close()\n\n    async def run_plugin(self, event: AsyncEvent, **kwargs: Any) -&gt; None:\n        \"\"\"Note that this example uses sqlite which does not provide an async driver.\n\n        Typically if you are using the AsyncClient you would also be using an async driver for the\n        database. sqlite is used in this example for simplicity.\n        \"\"\"\n        if kwargs.get(\"query\"):\n            self.save_search_query(kwargs[\"query\"])\n\n    def save_search_query(self, query: str) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"INSERT INTO searches VALUES(?)\", (query,))\n            self.conn.commit()\n        finally:\n            cursor.close()\n\n\nasync def main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    client = AsyncClient(\"http://127.0.0.1:7700\", \"masterKey\")\n    plugins = AsyncIndexPlugins(search_plugins=(SearchTrackerPlugin(),))\n    index = await client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n    task = await index.add_documents(documents)\n    await client.wait_for_task(task.task_uid)\n    result = await index.search(\"Cars\")\n    print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(asyncio.run(main()))\n</code></pre>"},{"location":"plugins/#index","title":"Index","text":"<pre><code>import json\nimport sqlite3\nfrom typing import Any\n\nfrom meilisearch_python_sdk import Client\nfrom meilisearch_python_sdk.plugins import Event, IndexPlugins\n\n\nclass SearchTrackerPlugin:\n    POST_EVENT = False\n    PRE_EVENT = True  # Specifies the plugin should be run before the search\n\n    def __init__(self) -&gt; None:\n        self.conn = sqlite3.Connection(\"examples/search_tracker.db\")\n        self.create_table()\n\n    def create_table(self) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"CREATE TABLE IF NOT EXISTS searches(query STRING)\")\n        finally:\n            cursor.close()\n\n    def run_plugin(self, event: Event, **kwargs: Any) -&gt; None:\n        if kwargs.get(\"query\"):\n            self.save_search_query(kwargs[\"query\"])\n\n    def save_search_query(self, query: str) -&gt; None:\n        try:\n            cursor = self.conn.cursor()\n            cursor.execute(\"INSERT INTO searches VALUES(?)\", (query,))\n            self.conn.commit()\n        finally:\n            cursor.close()\n\n\ndef main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    client = Client(\"http://127.0.0.1:7700\", \"masterKey\")\n    plugins = IndexPlugins(search_plugins=(SearchTrackerPlugin(),))\n    index = client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n    task = index.add_documents(documents)\n    client.wait_for_task(task.task_uid)\n    result = index.search(\"Cars\")\n    print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n</code></pre>"},{"location":"plugins/#modify-documents-and-search-results","title":"Modify documents and search results","text":"<p>A pre event plugin can be used to modify the documents before sending for indexing. In this example a new <code>access</code> field will be added to the doocuments before they are added or updated. The example will set every other record to <code>admin</code> access with the other records being set to <code>read</code>. This will illustrate the idea of modifing documents even it if doesn't make real world sense.</p> <p>A post search plugin, this type of search plugin can only be used post search because it requires the result of the search, will be used to remove records marked as <code>admin</code> before returing the result. In the real world this filtering would probably be done with a filterable field in Meilisearch,but again, this is just used here to illustrate the idea.</p>"},{"location":"plugins/#async-index_1","title":"Async Index","text":"<pre><code>import asyncio\nimport json\nfrom typing import Any, Sequence\n\nfrom meilisearch_python_sdk import AsyncClient\nfrom meilisearch_python_sdk.models.search import SearchResults\nfrom meilisearch_python_sdk.plugins import AsyncEvent, AsyncIndexPlugins\nfrom meilisearch_python_sdk.types import JsonMapping\n\n\nclass ModifyDocumentPlugin:\n    CONCURRENT_EVENT = False\n    POST_EVENT = False\n    PRE_EVENT = True  # Specifies the plugin should be run before adding documents\n\n    async def run_document_plugin(\n        self, event: AsyncEvent, *, documents: Sequence[JsonMapping], **kwargs: Any\n    ) -&gt; Sequence[JsonMapping]:\n        updated = []\n        for i, document in enumerate(documents):\n            if i % 2 == 0:\n                document[\"access\"] = \"admin\"\n            else:\n                document[\"access\"] = \"read\"\n\n            updated.append(document)\n\n        return updated\n\n\nclass FilterSearchResultsPlugin:\n    CONCURRENT_EVENT = False\n    POST_EVENT = True  # Specifies the plugin should be run after the search\n    PRE_EVENT = False\n\n    async def run_post_search_plugin(\n        self, event: AsyncEvent, *, search_results: SearchResults, **kwargs: Any\n    ) -&gt; SearchResults:\n        filtered_hits = []\n        for hit in search_results.hits:\n            if hit[\"access\"] != \"admin\":\n                filtered_hits.append(hit)\n\n        search_results.hits = filtered_hits\n\n        return search_results\n\n\nasync def main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    client = AsyncClient(\"http://127.0.0.1:7700\", \"masterKey\")\n    plugins = AsyncIndexPlugins(\n        add_documents_plugins=(ModifyDocumentPlugin(),),\n        update_documents_plugins=(ModifyDocumentPlugin(),),\n        search_plugins=(FilterSearchResultsPlugin(),),\n    )\n    index = await client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n    task = await index.add_documents(documents)\n    await client.wait_for_task(task.task_uid)\n    result = await index.search(\"cars\")\n    print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(asyncio.run(main()))\n</code></pre>"},{"location":"plugins/#index_1","title":"Index","text":"<pre><code>import json\nfrom typing import Any, Sequence\n\nfrom meilisearch_python_sdk import Client\nfrom meilisearch_python_sdk.models.search import SearchResults\nfrom meilisearch_python_sdk.plugins import Event, IndexPlugins\nfrom meilisearch_python_sdk.types import JsonMapping\n\n\nclass ModifyDocumentPlugin:\n    POST_EVENT = False\n    PRE_EVENT = True  # Specifies the plugin should be run before adding documents\n\n    def run_document_plugin(\n        self, event: Event, *, documents: Sequence[JsonMapping], **kwargs: Any\n    ) -&gt; Sequence[JsonMapping]:\n        updated = []\n        for i, document in enumerate(documents):\n            if i % 2 == 0:\n                document[\"access\"] = \"admin\"\n            else:\n                document[\"access\"] = \"read\"\n\n            updated.append(document)\n\n        return updated\n\n\nclass FilterSearchResultsPlugin:\n    POST_EVENT = True  # Specifies the plugin should be run after the search\n    PRE_EVENT = False\n\n    def run_post_search_plugin(\n        self, event: Event, *, search_results: SearchResults, **kwargs: Any\n    ) -&gt; SearchResults:\n        filtered_hits = []\n        for hit in search_results.hits:\n            if hit[\"access\"] != \"admin\":\n                filtered_hits.append(hit)\n\n        search_results.hits = filtered_hits\n\n        return search_results\n\n\ndef main() -&gt; int:\n    with open(\"datasets/small_movies.json\") as f:\n        documents = json.load(f)\n\n    client = Client(\"http://127.0.0.1:7700\", \"masterKey\")\n    plugins = IndexPlugins(\n        add_documents_plugins=(ModifyDocumentPlugin(),),\n        update_documents_plugins=(ModifyDocumentPlugin(),),\n        search_plugins=(FilterSearchResultsPlugin(),),\n    )\n    index = client.create_index(\"movies\", primary_key=\"id\", plugins=plugins)\n    task = index.add_documents(documents)\n    client.wait_for_task(task.task_uid)\n    result = index.search(\"cars\")\n    print(result)  # noqa: T201\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n</code></pre>"},{"location":"pydantic/","title":"Pydantic usage","text":"<p>This package uses Pydantic to serialize/deserialize the JSON from Meilisearch into Python objects wherever possible, and in the process uses <code>CamelBase</code> from camel-converter to convert the camelCaseNames from JSON into more Pythonic snake_case_names.</p> <p>In some instances it is not possible to return the data as an object because the structure will be dependant on your particular dataset and can't be known ahead of time. In these instances you can either work with the data in the dictionary that is returned, or because you will know the structure you can generate your own Pydantic models.</p> <p>As an example, if you want to get a movie from the small movies example you could put the results into an object with the following:</p> <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom camel_converter.pydantic_base import CamelBase\nfrom meilisearch_python_sdk import Client\n\n\n# Inheriting from CamelBase will allow your class to automatically convert\n# variables returned from the server in camelCase into snake_case. It will\n# also make it a Pydantic Model.\nclass Movie(CamelBase):\n    id: int\n    title: str\n    poster: str\n    overview: str\n    release_date: datetime\n    genre: Optional[str] = None\n\n\nasync with Client(\"http://127.0.0.1:7700\", \"masterKey\") as client:\n    index = client.index(\"movies\")\n    movie_dict = await index.get_document(287947)\n    movie = Movie(**movie_dict)\n</code></pre> <p>And then the movie variable would contain the movie object with the following information</p> <pre><code>Movie(\n    id = 287947,\n    title = \"Shazam!\",\n    poster = \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    overview = \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    release_date = datetime.datetime(2019, 3, 23, 0, 0, tzinfo=datetime.timezone.utc),\n    genre = \"action\",\n)\n</code></pre> <p>By inheriting from CamelBase, or any of the other provided models you will be inheriting Pydantic models and therefore have access to the funcitonality Pydantic provides such as validators and Fields. Pydantic will also automatically deserialized the data into the correct data type based on the type hint provided.</p>"}]}